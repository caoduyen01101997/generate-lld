{"ast":null,"code":"\"use strict\";\n\nconst findLast = require(\"lodash/findLast\");\n\n/**\n * Search where is the position of the comment in the token array by\n * using dichotomic search.\n * @param {*} tokens ordered array of tokens\n * @param {*} comment comment token\n * @return the position of the token next to the comment\n */\nfunction findUpperBoundToken(tokens, comment) {\n  let diff;\n  let i;\n  let current;\n  let len = tokens.length;\n  i = 0;\n  while (len) {\n    diff = len >>> 1;\n    current = i + diff;\n    if (tokens[current].startOffset > comment.startOffset) {\n      len = diff;\n    } else {\n      i = current + 1;\n      len -= diff + 1;\n    }\n  }\n  return i;\n}\nfunction isPrettierIgnoreComment(comment) {\n  return comment.image.match(/(\\/\\/(\\s*)prettier-ignore(\\s*))|(\\/\\*(\\s*)prettier-ignore(\\s*)\\*\\/)/gm);\n}\nfunction isFormatterOffOnComment(comment) {\n  return comment.image.match(/(\\/\\/(\\s*)@formatter:(off|on)(\\s*))|(\\/\\*(\\s*)@formatter:(off|on)(\\s*)\\*\\/)/gm);\n}\n\n/**\n * Pre-processing of tokens in order to\n * complete the parser's mostEnclosiveCstNodeByStartOffset and mostEnclosiveCstNodeByEndOffset structures.\n *\n * @param {ITokens[]} tokens - array of tokens\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n * @param {{[endOffset: number]: CSTNode}} mostEnclosiveCstNodeByEndOffset\n */\nfunction completeMostEnclosiveCSTNodeByOffset(tokens, mostEnclosiveCstNodeByStartOffset, mostEnclosiveCstNodeByEndOffset) {\n  tokens.forEach(token => {\n    if (mostEnclosiveCstNodeByStartOffset[token.startOffset] === undefined) {\n      mostEnclosiveCstNodeByStartOffset[token.startOffset] = token;\n    }\n    if (mostEnclosiveCstNodeByEndOffset[token.endOffset] === undefined) {\n      mostEnclosiveCstNodeByEndOffset[token.endOffset] = token;\n    }\n  });\n}\nfunction extendRangeOffset(comments, tokens) {\n  let position;\n  comments.forEach(comment => {\n    position = findUpperBoundToken(tokens, comment);\n    const extendedStartOffset = position - 1 < 0 ? comment.startOffset : tokens[position - 1].endOffset;\n    const extendedEndOffset = position == tokens.length ? comment.endOffset : tokens[position].startOffset;\n    comment.extendedOffset = {\n      startOffset: extendedStartOffset,\n      endOffset: extendedEndOffset\n    };\n  });\n}\n\n/**\n * Create two data structures we use to know at which offset a comment can be attached.\n * - commentsByExtendedStartOffset: map a comment by the endOffset of the previous token.\n * - commentsByExtendedEndOffset: map a comment by the startOffset of the next token\n *\n * @param {ITokens[]} tokens - array of tokens\n *\n * @return {{commentsByExtendedStartOffset: {[extendedStartOffset: number]: Comment[]}, commentsByExtendedEndOffset: {[extendedEndOffset: number]: Comment[]}}}\n */\nfunction mapCommentsByExtendedRange(comments) {\n  const commentsByExtendedEndOffset = {};\n  const commentsByExtendedStartOffset = {};\n  comments.forEach(comment => {\n    const extendedStartOffset = comment.extendedOffset.startOffset;\n    const extendedEndOffset = comment.extendedOffset.endOffset;\n    if (commentsByExtendedEndOffset[extendedEndOffset] === undefined) {\n      commentsByExtendedEndOffset[extendedEndOffset] = [comment];\n    } else {\n      commentsByExtendedEndOffset[extendedEndOffset].push(comment);\n    }\n    if (commentsByExtendedStartOffset[extendedStartOffset] === undefined) {\n      commentsByExtendedStartOffset[extendedStartOffset] = [comment];\n    } else {\n      commentsByExtendedStartOffset[extendedStartOffset].push(comment);\n    }\n  });\n  return {\n    commentsByExtendedEndOffset,\n    commentsByExtendedStartOffset\n  };\n}\n\n/**\n * Determine if a comment should be attached as a trailing comment to a specific node.\n * A comment should be trailing if it is on the same line than the previous token and\n * not on the same line than the next token\n *\n * @param {*} comment\n * @param {CSTNode} node\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n */\nfunction shouldAttachTrailingComments(comment, node, mostEnclosiveCstNodeByStartOffset) {\n  if (isPrettierIgnoreComment(comment)) {\n    return false;\n  }\n  const nextNode = mostEnclosiveCstNodeByStartOffset[comment.extendedOffset.endOffset];\n\n  // Last node of the file\n  if (nextNode === undefined) {\n    return true;\n  }\n  const nodeEndLine = node.location !== undefined ? node.location.endLine : node.endLine;\n  if (comment.startLine !== nodeEndLine) {\n    return false;\n  }\n  const nextNodeStartLine = nextNode.location !== undefined ? nextNode.location.startLine : nextNode.startLine;\n  return comment.endLine !== nextNodeStartLine;\n}\n\n/**\n * Attach comments to the most enclosive CSTNode (node or token)\n *\n * @param {ITokens[]} tokens\n * @param {*} comments\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n * @param {{[endOffset: number]: CSTNode}} mostEnclosiveCstNodeByEndOffset\n */\nfunction attachComments(tokens, comments, mostEnclosiveCstNodeByStartOffset, mostEnclosiveCstNodeByEndOffset) {\n  // Edge case: only comments in the file\n  if (tokens.length === 0) {\n    mostEnclosiveCstNodeByStartOffset[NaN].leadingComments = comments;\n    return;\n  }\n\n  // Pre-processing phase to complete the data structures we need to attach\n  // a comment to the right place\n  completeMostEnclosiveCSTNodeByOffset(tokens, mostEnclosiveCstNodeByStartOffset, mostEnclosiveCstNodeByEndOffset);\n  extendRangeOffset(comments, tokens);\n  const {\n    commentsByExtendedStartOffset,\n    commentsByExtendedEndOffset\n  } = mapCommentsByExtendedRange(comments);\n\n  /*\n    This set is here to ensure that we attach comments only once\n    If a comment is attached to a node or token, we remove it from this set\n  */\n  const commentsToAttach = new Set(comments);\n\n  // Attach comments as trailing comments if desirable\n  Object.keys(mostEnclosiveCstNodeByEndOffset).forEach(endOffset => {\n    // We look if some comments is directly following this node/token\n    if (commentsByExtendedStartOffset[endOffset] !== undefined) {\n      const nodeTrailingComments = commentsByExtendedStartOffset[endOffset].filter(comment => {\n        return shouldAttachTrailingComments(comment, mostEnclosiveCstNodeByEndOffset[endOffset], mostEnclosiveCstNodeByStartOffset) && commentsToAttach.has(comment);\n      });\n      if (nodeTrailingComments.length > 0) {\n        mostEnclosiveCstNodeByEndOffset[endOffset].trailingComments = nodeTrailingComments;\n      }\n      nodeTrailingComments.forEach(comment => {\n        commentsToAttach.delete(comment);\n      });\n    }\n  });\n\n  // Attach rest of comments as leading comments\n  Object.keys(mostEnclosiveCstNodeByStartOffset).forEach(startOffset => {\n    // We look if some comments is directly preceding this node/token\n    if (commentsByExtendedEndOffset[startOffset] !== undefined) {\n      const nodeLeadingComments = commentsByExtendedEndOffset[startOffset].filter(comment => commentsToAttach.has(comment));\n      if (nodeLeadingComments.length > 0) {\n        mostEnclosiveCstNodeByStartOffset[startOffset].leadingComments = nodeLeadingComments;\n      }\n\n      // prettier ignore support\n      for (let i = 0; i < nodeLeadingComments.length; i++) {\n        if (isPrettierIgnoreComment(nodeLeadingComments[i])) {\n          mostEnclosiveCstNodeByStartOffset[startOffset].ignore = true;\n          break;\n        }\n      }\n    }\n  });\n}\n\n/**\n * Create pairs of formatter:off and formatter:on\n * @param comments\n * @returns pairs of formatter:off and formatter:on\n */\nfunction matchFormatterOffOnPairs(comments) {\n  const onOffComments = comments.filter(comment => isFormatterOffOnComment(comment));\n  let isPreviousCommentOff = false;\n  let isCurrentCommentOff = true;\n  const pairs = [];\n  let paired = {};\n  onOffComments.forEach(comment => {\n    isCurrentCommentOff = comment.image.slice(-3) === \"off\";\n    if (!isPreviousCommentOff) {\n      if (isCurrentCommentOff) {\n        paired.off = comment;\n      }\n    } else {\n      if (!isCurrentCommentOff) {\n        paired.on = comment;\n        pairs.push(paired);\n        paired = {};\n      }\n    }\n    isPreviousCommentOff = isCurrentCommentOff;\n  });\n  if (onOffComments.length > 0 && isCurrentCommentOff) {\n    paired.on = undefined;\n    pairs.push(paired);\n  }\n  return pairs;\n}\n\n/**\n * Check if the node is between formatter:off and formatter:on and change his ignore state\n * @param node\n * @param commentPairs\n */\nfunction shouldNotFormat(node, commentPairs) {\n  const matchingPair = findLast(commentPairs, comment => comment.off.endOffset < node.location.startOffset);\n  if (matchingPair !== undefined && (matchingPair.on === undefined || matchingPair.on.startOffset > node.location.endOffset)) {\n    node.ignore = true;\n  }\n}\nmodule.exports = {\n  matchFormatterOffOnPairs,\n  shouldNotFormat,\n  attachComments\n};","map":{"version":3,"names":["findLast","require","findUpperBoundToken","tokens","comment","diff","i","current","len","length","startOffset","isPrettierIgnoreComment","image","match","isFormatterOffOnComment","completeMostEnclosiveCSTNodeByOffset","mostEnclosiveCstNodeByStartOffset","mostEnclosiveCstNodeByEndOffset","forEach","token","undefined","endOffset","extendRangeOffset","comments","position","extendedStartOffset","extendedEndOffset","extendedOffset","mapCommentsByExtendedRange","commentsByExtendedEndOffset","commentsByExtendedStartOffset","push","shouldAttachTrailingComments","node","nextNode","nodeEndLine","location","endLine","startLine","nextNodeStartLine","attachComments","NaN","leadingComments","commentsToAttach","Set","Object","keys","nodeTrailingComments","filter","has","trailingComments","delete","nodeLeadingComments","ignore","matchFormatterOffOnPairs","onOffComments","isPreviousCommentOff","isCurrentCommentOff","pairs","paired","slice","off","on","shouldNotFormat","commentPairs","matchingPair","module","exports"],"sources":["/Users/duyenpnc/Desktop/tool-tu-lam/your-app-name/node_modules/java-parser/src/comments.js"],"sourcesContent":["\"use strict\";\n\nconst findLast = require(\"lodash/findLast\");\n\n/**\n * Search where is the position of the comment in the token array by\n * using dichotomic search.\n * @param {*} tokens ordered array of tokens\n * @param {*} comment comment token\n * @return the position of the token next to the comment\n */\nfunction findUpperBoundToken(tokens, comment) {\n  let diff;\n  let i;\n  let current;\n\n  let len = tokens.length;\n  i = 0;\n\n  while (len) {\n    diff = len >>> 1;\n    current = i + diff;\n    if (tokens[current].startOffset > comment.startOffset) {\n      len = diff;\n    } else {\n      i = current + 1;\n      len -= diff + 1;\n    }\n  }\n  return i;\n}\n\nfunction isPrettierIgnoreComment(comment) {\n  return comment.image.match(\n    /(\\/\\/(\\s*)prettier-ignore(\\s*))|(\\/\\*(\\s*)prettier-ignore(\\s*)\\*\\/)/gm\n  );\n}\n\nfunction isFormatterOffOnComment(comment) {\n  return comment.image.match(\n    /(\\/\\/(\\s*)@formatter:(off|on)(\\s*))|(\\/\\*(\\s*)@formatter:(off|on)(\\s*)\\*\\/)/gm\n  );\n}\n\n/**\n * Pre-processing of tokens in order to\n * complete the parser's mostEnclosiveCstNodeByStartOffset and mostEnclosiveCstNodeByEndOffset structures.\n *\n * @param {ITokens[]} tokens - array of tokens\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n * @param {{[endOffset: number]: CSTNode}} mostEnclosiveCstNodeByEndOffset\n */\nfunction completeMostEnclosiveCSTNodeByOffset(\n  tokens,\n  mostEnclosiveCstNodeByStartOffset,\n  mostEnclosiveCstNodeByEndOffset\n) {\n  tokens.forEach(token => {\n    if (mostEnclosiveCstNodeByStartOffset[token.startOffset] === undefined) {\n      mostEnclosiveCstNodeByStartOffset[token.startOffset] = token;\n    }\n\n    if (mostEnclosiveCstNodeByEndOffset[token.endOffset] === undefined) {\n      mostEnclosiveCstNodeByEndOffset[token.endOffset] = token;\n    }\n  });\n}\n\nfunction extendRangeOffset(comments, tokens) {\n  let position;\n  comments.forEach(comment => {\n    position = findUpperBoundToken(tokens, comment);\n\n    const extendedStartOffset =\n      position - 1 < 0 ? comment.startOffset : tokens[position - 1].endOffset;\n    const extendedEndOffset =\n      position == tokens.length\n        ? comment.endOffset\n        : tokens[position].startOffset;\n    comment.extendedOffset = {\n      startOffset: extendedStartOffset,\n      endOffset: extendedEndOffset\n    };\n  });\n}\n\n/**\n * Create two data structures we use to know at which offset a comment can be attached.\n * - commentsByExtendedStartOffset: map a comment by the endOffset of the previous token.\n * - commentsByExtendedEndOffset: map a comment by the startOffset of the next token\n *\n * @param {ITokens[]} tokens - array of tokens\n *\n * @return {{commentsByExtendedStartOffset: {[extendedStartOffset: number]: Comment[]}, commentsByExtendedEndOffset: {[extendedEndOffset: number]: Comment[]}}}\n */\nfunction mapCommentsByExtendedRange(comments) {\n  const commentsByExtendedEndOffset = {};\n  const commentsByExtendedStartOffset = {};\n\n  comments.forEach(comment => {\n    const extendedStartOffset = comment.extendedOffset.startOffset;\n    const extendedEndOffset = comment.extendedOffset.endOffset;\n\n    if (commentsByExtendedEndOffset[extendedEndOffset] === undefined) {\n      commentsByExtendedEndOffset[extendedEndOffset] = [comment];\n    } else {\n      commentsByExtendedEndOffset[extendedEndOffset].push(comment);\n    }\n\n    if (commentsByExtendedStartOffset[extendedStartOffset] === undefined) {\n      commentsByExtendedStartOffset[extendedStartOffset] = [comment];\n    } else {\n      commentsByExtendedStartOffset[extendedStartOffset].push(comment);\n    }\n  });\n\n  return { commentsByExtendedEndOffset, commentsByExtendedStartOffset };\n}\n\n/**\n * Determine if a comment should be attached as a trailing comment to a specific node.\n * A comment should be trailing if it is on the same line than the previous token and\n * not on the same line than the next token\n *\n * @param {*} comment\n * @param {CSTNode} node\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n */\nfunction shouldAttachTrailingComments(\n  comment,\n  node,\n  mostEnclosiveCstNodeByStartOffset\n) {\n  if (isPrettierIgnoreComment(comment)) {\n    return false;\n  }\n\n  const nextNode =\n    mostEnclosiveCstNodeByStartOffset[comment.extendedOffset.endOffset];\n\n  // Last node of the file\n  if (nextNode === undefined) {\n    return true;\n  }\n\n  const nodeEndLine =\n    node.location !== undefined ? node.location.endLine : node.endLine;\n\n  if (comment.startLine !== nodeEndLine) {\n    return false;\n  }\n\n  const nextNodeStartLine =\n    nextNode.location !== undefined\n      ? nextNode.location.startLine\n      : nextNode.startLine;\n  return comment.endLine !== nextNodeStartLine;\n}\n\n/**\n * Attach comments to the most enclosive CSTNode (node or token)\n *\n * @param {ITokens[]} tokens\n * @param {*} comments\n * @param {{[startOffset: number]: CSTNode}} mostEnclosiveCstNodeByStartOffset\n * @param {{[endOffset: number]: CSTNode}} mostEnclosiveCstNodeByEndOffset\n */\nfunction attachComments(\n  tokens,\n  comments,\n  mostEnclosiveCstNodeByStartOffset,\n  mostEnclosiveCstNodeByEndOffset\n) {\n  // Edge case: only comments in the file\n  if (tokens.length === 0) {\n    mostEnclosiveCstNodeByStartOffset[NaN].leadingComments = comments;\n    return;\n  }\n\n  // Pre-processing phase to complete the data structures we need to attach\n  // a comment to the right place\n  completeMostEnclosiveCSTNodeByOffset(\n    tokens,\n    mostEnclosiveCstNodeByStartOffset,\n    mostEnclosiveCstNodeByEndOffset\n  );\n\n  extendRangeOffset(comments, tokens);\n  const { commentsByExtendedStartOffset, commentsByExtendedEndOffset } =\n    mapCommentsByExtendedRange(comments);\n\n  /*\n    This set is here to ensure that we attach comments only once\n    If a comment is attached to a node or token, we remove it from this set\n  */\n  const commentsToAttach = new Set(comments);\n\n  // Attach comments as trailing comments if desirable\n  Object.keys(mostEnclosiveCstNodeByEndOffset).forEach(endOffset => {\n    // We look if some comments is directly following this node/token\n    if (commentsByExtendedStartOffset[endOffset] !== undefined) {\n      const nodeTrailingComments = commentsByExtendedStartOffset[\n        endOffset\n      ].filter(comment => {\n        return (\n          shouldAttachTrailingComments(\n            comment,\n            mostEnclosiveCstNodeByEndOffset[endOffset],\n            mostEnclosiveCstNodeByStartOffset\n          ) && commentsToAttach.has(comment)\n        );\n      });\n\n      if (nodeTrailingComments.length > 0) {\n        mostEnclosiveCstNodeByEndOffset[endOffset].trailingComments =\n          nodeTrailingComments;\n      }\n\n      nodeTrailingComments.forEach(comment => {\n        commentsToAttach.delete(comment);\n      });\n    }\n  });\n\n  // Attach rest of comments as leading comments\n  Object.keys(mostEnclosiveCstNodeByStartOffset).forEach(startOffset => {\n    // We look if some comments is directly preceding this node/token\n    if (commentsByExtendedEndOffset[startOffset] !== undefined) {\n      const nodeLeadingComments = commentsByExtendedEndOffset[\n        startOffset\n      ].filter(comment => commentsToAttach.has(comment));\n\n      if (nodeLeadingComments.length > 0) {\n        mostEnclosiveCstNodeByStartOffset[startOffset].leadingComments =\n          nodeLeadingComments;\n      }\n\n      // prettier ignore support\n      for (let i = 0; i < nodeLeadingComments.length; i++) {\n        if (isPrettierIgnoreComment(nodeLeadingComments[i])) {\n          mostEnclosiveCstNodeByStartOffset[startOffset].ignore = true;\n          break;\n        }\n      }\n    }\n  });\n}\n\n/**\n * Create pairs of formatter:off and formatter:on\n * @param comments\n * @returns pairs of formatter:off and formatter:on\n */\nfunction matchFormatterOffOnPairs(comments) {\n  const onOffComments = comments.filter(comment =>\n    isFormatterOffOnComment(comment)\n  );\n\n  let isPreviousCommentOff = false;\n  let isCurrentCommentOff = true;\n  const pairs = [];\n  let paired = {};\n  onOffComments.forEach(comment => {\n    isCurrentCommentOff = comment.image.slice(-3) === \"off\";\n\n    if (!isPreviousCommentOff) {\n      if (isCurrentCommentOff) {\n        paired.off = comment;\n      }\n    } else {\n      if (!isCurrentCommentOff) {\n        paired.on = comment;\n        pairs.push(paired);\n        paired = {};\n      }\n    }\n    isPreviousCommentOff = isCurrentCommentOff;\n  });\n\n  if (onOffComments.length > 0 && isCurrentCommentOff) {\n    paired.on = undefined;\n    pairs.push(paired);\n  }\n\n  return pairs;\n}\n\n/**\n * Check if the node is between formatter:off and formatter:on and change his ignore state\n * @param node\n * @param commentPairs\n */\nfunction shouldNotFormat(node, commentPairs) {\n  const matchingPair = findLast(\n    commentPairs,\n    comment => comment.off.endOffset < node.location.startOffset\n  );\n  if (\n    matchingPair !== undefined &&\n    (matchingPair.on === undefined ||\n      matchingPair.on.startOffset > node.location.endOffset)\n  ) {\n    node.ignore = true;\n  }\n}\n\nmodule.exports = {\n  matchFormatterOffOnPairs,\n  shouldNotFormat,\n  attachComments\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,iBAAiB,CAAC;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAACC,MAAM,EAAEC,OAAO,EAAE;EAC5C,IAAIC,IAAI;EACR,IAAIC,CAAC;EACL,IAAIC,OAAO;EAEX,IAAIC,GAAG,GAAGL,MAAM,CAACM,MAAM;EACvBH,CAAC,GAAG,CAAC;EAEL,OAAOE,GAAG,EAAE;IACVH,IAAI,GAAGG,GAAG,KAAK,CAAC;IAChBD,OAAO,GAAGD,CAAC,GAAGD,IAAI;IAClB,IAAIF,MAAM,CAACI,OAAO,CAAC,CAACG,WAAW,GAAGN,OAAO,CAACM,WAAW,EAAE;MACrDF,GAAG,GAAGH,IAAI;IACZ,CAAC,MAAM;MACLC,CAAC,GAAGC,OAAO,GAAG,CAAC;MACfC,GAAG,IAAIH,IAAI,GAAG,CAAC;IACjB;EACF;EACA,OAAOC,CAAC;AACV;AAEA,SAASK,uBAAuBA,CAACP,OAAO,EAAE;EACxC,OAAOA,OAAO,CAACQ,KAAK,CAACC,KAAK,CACxB,uEACF,CAAC;AACH;AAEA,SAASC,uBAAuBA,CAACV,OAAO,EAAE;EACxC,OAAOA,OAAO,CAACQ,KAAK,CAACC,KAAK,CACxB,+EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,oCAAoCA,CAC3CZ,MAAM,EACNa,iCAAiC,EACjCC,+BAA+B,EAC/B;EACAd,MAAM,CAACe,OAAO,CAACC,KAAK,IAAI;IACtB,IAAIH,iCAAiC,CAACG,KAAK,CAACT,WAAW,CAAC,KAAKU,SAAS,EAAE;MACtEJ,iCAAiC,CAACG,KAAK,CAACT,WAAW,CAAC,GAAGS,KAAK;IAC9D;IAEA,IAAIF,+BAA+B,CAACE,KAAK,CAACE,SAAS,CAAC,KAAKD,SAAS,EAAE;MAClEH,+BAA+B,CAACE,KAAK,CAACE,SAAS,CAAC,GAAGF,KAAK;IAC1D;EACF,CAAC,CAAC;AACJ;AAEA,SAASG,iBAAiBA,CAACC,QAAQ,EAAEpB,MAAM,EAAE;EAC3C,IAAIqB,QAAQ;EACZD,QAAQ,CAACL,OAAO,CAACd,OAAO,IAAI;IAC1BoB,QAAQ,GAAGtB,mBAAmB,CAACC,MAAM,EAAEC,OAAO,CAAC;IAE/C,MAAMqB,mBAAmB,GACvBD,QAAQ,GAAG,CAAC,GAAG,CAAC,GAAGpB,OAAO,CAACM,WAAW,GAAGP,MAAM,CAACqB,QAAQ,GAAG,CAAC,CAAC,CAACH,SAAS;IACzE,MAAMK,iBAAiB,GACrBF,QAAQ,IAAIrB,MAAM,CAACM,MAAM,GACrBL,OAAO,CAACiB,SAAS,GACjBlB,MAAM,CAACqB,QAAQ,CAAC,CAACd,WAAW;IAClCN,OAAO,CAACuB,cAAc,GAAG;MACvBjB,WAAW,EAAEe,mBAAmB;MAChCJ,SAAS,EAAEK;IACb,CAAC;EACH,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,0BAA0BA,CAACL,QAAQ,EAAE;EAC5C,MAAMM,2BAA2B,GAAG,CAAC,CAAC;EACtC,MAAMC,6BAA6B,GAAG,CAAC,CAAC;EAExCP,QAAQ,CAACL,OAAO,CAACd,OAAO,IAAI;IAC1B,MAAMqB,mBAAmB,GAAGrB,OAAO,CAACuB,cAAc,CAACjB,WAAW;IAC9D,MAAMgB,iBAAiB,GAAGtB,OAAO,CAACuB,cAAc,CAACN,SAAS;IAE1D,IAAIQ,2BAA2B,CAACH,iBAAiB,CAAC,KAAKN,SAAS,EAAE;MAChES,2BAA2B,CAACH,iBAAiB,CAAC,GAAG,CAACtB,OAAO,CAAC;IAC5D,CAAC,MAAM;MACLyB,2BAA2B,CAACH,iBAAiB,CAAC,CAACK,IAAI,CAAC3B,OAAO,CAAC;IAC9D;IAEA,IAAI0B,6BAA6B,CAACL,mBAAmB,CAAC,KAAKL,SAAS,EAAE;MACpEU,6BAA6B,CAACL,mBAAmB,CAAC,GAAG,CAACrB,OAAO,CAAC;IAChE,CAAC,MAAM;MACL0B,6BAA6B,CAACL,mBAAmB,CAAC,CAACM,IAAI,CAAC3B,OAAO,CAAC;IAClE;EACF,CAAC,CAAC;EAEF,OAAO;IAAEyB,2BAA2B;IAAEC;EAA8B,CAAC;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,4BAA4BA,CACnC5B,OAAO,EACP6B,IAAI,EACJjB,iCAAiC,EACjC;EACA,IAAIL,uBAAuB,CAACP,OAAO,CAAC,EAAE;IACpC,OAAO,KAAK;EACd;EAEA,MAAM8B,QAAQ,GACZlB,iCAAiC,CAACZ,OAAO,CAACuB,cAAc,CAACN,SAAS,CAAC;;EAErE;EACA,IAAIa,QAAQ,KAAKd,SAAS,EAAE;IAC1B,OAAO,IAAI;EACb;EAEA,MAAMe,WAAW,GACfF,IAAI,CAACG,QAAQ,KAAKhB,SAAS,GAAGa,IAAI,CAACG,QAAQ,CAACC,OAAO,GAAGJ,IAAI,CAACI,OAAO;EAEpE,IAAIjC,OAAO,CAACkC,SAAS,KAAKH,WAAW,EAAE;IACrC,OAAO,KAAK;EACd;EAEA,MAAMI,iBAAiB,GACrBL,QAAQ,CAACE,QAAQ,KAAKhB,SAAS,GAC3Bc,QAAQ,CAACE,QAAQ,CAACE,SAAS,GAC3BJ,QAAQ,CAACI,SAAS;EACxB,OAAOlC,OAAO,CAACiC,OAAO,KAAKE,iBAAiB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CACrBrC,MAAM,EACNoB,QAAQ,EACRP,iCAAiC,EACjCC,+BAA+B,EAC/B;EACA;EACA,IAAId,MAAM,CAACM,MAAM,KAAK,CAAC,EAAE;IACvBO,iCAAiC,CAACyB,GAAG,CAAC,CAACC,eAAe,GAAGnB,QAAQ;IACjE;EACF;;EAEA;EACA;EACAR,oCAAoC,CAClCZ,MAAM,EACNa,iCAAiC,EACjCC,+BACF,CAAC;EAEDK,iBAAiB,CAACC,QAAQ,EAAEpB,MAAM,CAAC;EACnC,MAAM;IAAE2B,6BAA6B;IAAED;EAA4B,CAAC,GAClED,0BAA0B,CAACL,QAAQ,CAAC;;EAEtC;AACF;AACA;AACA;EACE,MAAMoB,gBAAgB,GAAG,IAAIC,GAAG,CAACrB,QAAQ,CAAC;;EAE1C;EACAsB,MAAM,CAACC,IAAI,CAAC7B,+BAA+B,CAAC,CAACC,OAAO,CAACG,SAAS,IAAI;IAChE;IACA,IAAIS,6BAA6B,CAACT,SAAS,CAAC,KAAKD,SAAS,EAAE;MAC1D,MAAM2B,oBAAoB,GAAGjB,6BAA6B,CACxDT,SAAS,CACV,CAAC2B,MAAM,CAAC5C,OAAO,IAAI;QAClB,OACE4B,4BAA4B,CAC1B5B,OAAO,EACPa,+BAA+B,CAACI,SAAS,CAAC,EAC1CL,iCACF,CAAC,IAAI2B,gBAAgB,CAACM,GAAG,CAAC7C,OAAO,CAAC;MAEtC,CAAC,CAAC;MAEF,IAAI2C,oBAAoB,CAACtC,MAAM,GAAG,CAAC,EAAE;QACnCQ,+BAA+B,CAACI,SAAS,CAAC,CAAC6B,gBAAgB,GACzDH,oBAAoB;MACxB;MAEAA,oBAAoB,CAAC7B,OAAO,CAACd,OAAO,IAAI;QACtCuC,gBAAgB,CAACQ,MAAM,CAAC/C,OAAO,CAAC;MAClC,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;;EAEF;EACAyC,MAAM,CAACC,IAAI,CAAC9B,iCAAiC,CAAC,CAACE,OAAO,CAACR,WAAW,IAAI;IACpE;IACA,IAAImB,2BAA2B,CAACnB,WAAW,CAAC,KAAKU,SAAS,EAAE;MAC1D,MAAMgC,mBAAmB,GAAGvB,2BAA2B,CACrDnB,WAAW,CACZ,CAACsC,MAAM,CAAC5C,OAAO,IAAIuC,gBAAgB,CAACM,GAAG,CAAC7C,OAAO,CAAC,CAAC;MAElD,IAAIgD,mBAAmB,CAAC3C,MAAM,GAAG,CAAC,EAAE;QAClCO,iCAAiC,CAACN,WAAW,CAAC,CAACgC,eAAe,GAC5DU,mBAAmB;MACvB;;MAEA;MACA,KAAK,IAAI9C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8C,mBAAmB,CAAC3C,MAAM,EAAEH,CAAC,EAAE,EAAE;QACnD,IAAIK,uBAAuB,CAACyC,mBAAmB,CAAC9C,CAAC,CAAC,CAAC,EAAE;UACnDU,iCAAiC,CAACN,WAAW,CAAC,CAAC2C,MAAM,GAAG,IAAI;UAC5D;QACF;MACF;IACF;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASC,wBAAwBA,CAAC/B,QAAQ,EAAE;EAC1C,MAAMgC,aAAa,GAAGhC,QAAQ,CAACyB,MAAM,CAAC5C,OAAO,IAC3CU,uBAAuB,CAACV,OAAO,CACjC,CAAC;EAED,IAAIoD,oBAAoB,GAAG,KAAK;EAChC,IAAIC,mBAAmB,GAAG,IAAI;EAC9B,MAAMC,KAAK,GAAG,EAAE;EAChB,IAAIC,MAAM,GAAG,CAAC,CAAC;EACfJ,aAAa,CAACrC,OAAO,CAACd,OAAO,IAAI;IAC/BqD,mBAAmB,GAAGrD,OAAO,CAACQ,KAAK,CAACgD,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK;IAEvD,IAAI,CAACJ,oBAAoB,EAAE;MACzB,IAAIC,mBAAmB,EAAE;QACvBE,MAAM,CAACE,GAAG,GAAGzD,OAAO;MACtB;IACF,CAAC,MAAM;MACL,IAAI,CAACqD,mBAAmB,EAAE;QACxBE,MAAM,CAACG,EAAE,GAAG1D,OAAO;QACnBsD,KAAK,CAAC3B,IAAI,CAAC4B,MAAM,CAAC;QAClBA,MAAM,GAAG,CAAC,CAAC;MACb;IACF;IACAH,oBAAoB,GAAGC,mBAAmB;EAC5C,CAAC,CAAC;EAEF,IAAIF,aAAa,CAAC9C,MAAM,GAAG,CAAC,IAAIgD,mBAAmB,EAAE;IACnDE,MAAM,CAACG,EAAE,GAAG1C,SAAS;IACrBsC,KAAK,CAAC3B,IAAI,CAAC4B,MAAM,CAAC;EACpB;EAEA,OAAOD,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASK,eAAeA,CAAC9B,IAAI,EAAE+B,YAAY,EAAE;EAC3C,MAAMC,YAAY,GAAGjE,QAAQ,CAC3BgE,YAAY,EACZ5D,OAAO,IAAIA,OAAO,CAACyD,GAAG,CAACxC,SAAS,GAAGY,IAAI,CAACG,QAAQ,CAAC1B,WACnD,CAAC;EACD,IACEuD,YAAY,KAAK7C,SAAS,KACzB6C,YAAY,CAACH,EAAE,KAAK1C,SAAS,IAC5B6C,YAAY,CAACH,EAAE,CAACpD,WAAW,GAAGuB,IAAI,CAACG,QAAQ,CAACf,SAAS,CAAC,EACxD;IACAY,IAAI,CAACoB,MAAM,GAAG,IAAI;EACpB;AACF;AAEAa,MAAM,CAACC,OAAO,GAAG;EACfb,wBAAwB;EACxBS,eAAe;EACfvB;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}