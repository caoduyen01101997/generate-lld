{"ast":null,"code":"\"use strict\";\n\nconst JavaLexer = require(\"./lexer\");\nconst JavaParser = require(\"./parser\");\nconst {\n  attachComments,\n  matchFormatterOffOnPairs\n} = require(\"./comments\");\nconst parser = new JavaParser();\nconst BaseJavaCstVisitor = parser.getBaseCstVisitorConstructor();\nconst BaseJavaCstVisitorWithDefaults = parser.getBaseCstVisitorConstructorWithDefaults();\nfunction parse(inputText) {\n  let entryPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"compilationUnit\";\n  // Lex\n  const lexResult = JavaLexer.tokenize(inputText);\n  if (lexResult.errors.length > 0) {\n    const firstError = lexResult.errors[0];\n    throw Error(\"Sad sad panda, lexing errors detected in line: \" + firstError.line + \", column: \" + firstError.column + \"!\\n\" + firstError.message);\n  }\n  parser.input = lexResult.tokens;\n  parser.mostEnclosiveCstNodeByStartOffset = {};\n  parser.mostEnclosiveCstNodeByEndOffset = {};\n  parser.setOnOffCommentPairs(matchFormatterOffOnPairs(lexResult.groups.comments));\n\n  // Automatic CST created when parsing\n  const cst = parser[entryPoint]();\n  if (parser.errors.length > 0) {\n    const error = parser.errors[0];\n    throw Error(\"Sad sad panda, parsing errors detected in line: \" + error.token.startLine + \", column: \" + error.token.startColumn + \"!\\n\" + error.message + \"!\\n\\t->\" + error.context.ruleStack.join(\"\\n\\t->\"));\n  }\n  attachComments(lexResult.tokens, lexResult.groups.comments, parser.mostEnclosiveCstNodeByStartOffset, parser.mostEnclosiveCstNodeByEndOffset);\n  return cst;\n}\nmodule.exports = {\n  parse,\n  BaseJavaCstVisitor,\n  BaseJavaCstVisitorWithDefaults\n};","map":{"version":3,"names":["JavaLexer","require","JavaParser","attachComments","matchFormatterOffOnPairs","parser","BaseJavaCstVisitor","getBaseCstVisitorConstructor","BaseJavaCstVisitorWithDefaults","getBaseCstVisitorConstructorWithDefaults","parse","inputText","entryPoint","arguments","length","undefined","lexResult","tokenize","errors","firstError","Error","line","column","message","input","tokens","mostEnclosiveCstNodeByStartOffset","mostEnclosiveCstNodeByEndOffset","setOnOffCommentPairs","groups","comments","cst","error","token","startLine","startColumn","context","ruleStack","join","module","exports"],"sources":["/Users/duyenpnc/Desktop/tool-tu-lam/your-app-name/node_modules/java-parser/src/index.js"],"sourcesContent":["\"use strict\";\nconst JavaLexer = require(\"./lexer\");\nconst JavaParser = require(\"./parser\");\nconst { attachComments, matchFormatterOffOnPairs } = require(\"./comments\");\n\nconst parser = new JavaParser();\n\nconst BaseJavaCstVisitor = parser.getBaseCstVisitorConstructor();\nconst BaseJavaCstVisitorWithDefaults =\n  parser.getBaseCstVisitorConstructorWithDefaults();\n\nfunction parse(inputText, entryPoint = \"compilationUnit\") {\n  // Lex\n  const lexResult = JavaLexer.tokenize(inputText);\n\n  if (lexResult.errors.length > 0) {\n    const firstError = lexResult.errors[0];\n    throw Error(\n      \"Sad sad panda, lexing errors detected in line: \" +\n        firstError.line +\n        \", column: \" +\n        firstError.column +\n        \"!\\n\" +\n        firstError.message\n    );\n  }\n\n  parser.input = lexResult.tokens;\n  parser.mostEnclosiveCstNodeByStartOffset = {};\n  parser.mostEnclosiveCstNodeByEndOffset = {};\n\n  parser.setOnOffCommentPairs(\n    matchFormatterOffOnPairs(lexResult.groups.comments)\n  );\n\n  // Automatic CST created when parsing\n  const cst = parser[entryPoint]();\n\n  if (parser.errors.length > 0) {\n    const error = parser.errors[0];\n    throw Error(\n      \"Sad sad panda, parsing errors detected in line: \" +\n        error.token.startLine +\n        \", column: \" +\n        error.token.startColumn +\n        \"!\\n\" +\n        error.message +\n        \"!\\n\\t->\" +\n        error.context.ruleStack.join(\"\\n\\t->\")\n    );\n  }\n\n  attachComments(\n    lexResult.tokens,\n    lexResult.groups.comments,\n    parser.mostEnclosiveCstNodeByStartOffset,\n    parser.mostEnclosiveCstNodeByEndOffset\n  );\n\n  return cst;\n}\n\nmodule.exports = {\n  parse,\n  BaseJavaCstVisitor,\n  BaseJavaCstVisitorWithDefaults\n};\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC;AACpC,MAAMC,UAAU,GAAGD,OAAO,CAAC,UAAU,CAAC;AACtC,MAAM;EAAEE,cAAc;EAAEC;AAAyB,CAAC,GAAGH,OAAO,CAAC,YAAY,CAAC;AAE1E,MAAMI,MAAM,GAAG,IAAIH,UAAU,CAAC,CAAC;AAE/B,MAAMI,kBAAkB,GAAGD,MAAM,CAACE,4BAA4B,CAAC,CAAC;AAChE,MAAMC,8BAA8B,GAClCH,MAAM,CAACI,wCAAwC,CAAC,CAAC;AAEnD,SAASC,KAAKA,CAACC,SAAS,EAAkC;EAAA,IAAhCC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,iBAAiB;EACtD;EACA,MAAMG,SAAS,GAAGhB,SAAS,CAACiB,QAAQ,CAACN,SAAS,CAAC;EAE/C,IAAIK,SAAS,CAACE,MAAM,CAACJ,MAAM,GAAG,CAAC,EAAE;IAC/B,MAAMK,UAAU,GAAGH,SAAS,CAACE,MAAM,CAAC,CAAC,CAAC;IACtC,MAAME,KAAK,CACT,iDAAiD,GAC/CD,UAAU,CAACE,IAAI,GACf,YAAY,GACZF,UAAU,CAACG,MAAM,GACjB,KAAK,GACLH,UAAU,CAACI,OACf,CAAC;EACH;EAEAlB,MAAM,CAACmB,KAAK,GAAGR,SAAS,CAACS,MAAM;EAC/BpB,MAAM,CAACqB,iCAAiC,GAAG,CAAC,CAAC;EAC7CrB,MAAM,CAACsB,+BAA+B,GAAG,CAAC,CAAC;EAE3CtB,MAAM,CAACuB,oBAAoB,CACzBxB,wBAAwB,CAACY,SAAS,CAACa,MAAM,CAACC,QAAQ,CACpD,CAAC;;EAED;EACA,MAAMC,GAAG,GAAG1B,MAAM,CAACO,UAAU,CAAC,CAAC,CAAC;EAEhC,IAAIP,MAAM,CAACa,MAAM,CAACJ,MAAM,GAAG,CAAC,EAAE;IAC5B,MAAMkB,KAAK,GAAG3B,MAAM,CAACa,MAAM,CAAC,CAAC,CAAC;IAC9B,MAAME,KAAK,CACT,kDAAkD,GAChDY,KAAK,CAACC,KAAK,CAACC,SAAS,GACrB,YAAY,GACZF,KAAK,CAACC,KAAK,CAACE,WAAW,GACvB,KAAK,GACLH,KAAK,CAACT,OAAO,GACb,SAAS,GACTS,KAAK,CAACI,OAAO,CAACC,SAAS,CAACC,IAAI,CAAC,QAAQ,CACzC,CAAC;EACH;EAEAnC,cAAc,CACZa,SAAS,CAACS,MAAM,EAChBT,SAAS,CAACa,MAAM,CAACC,QAAQ,EACzBzB,MAAM,CAACqB,iCAAiC,EACxCrB,MAAM,CAACsB,+BACT,CAAC;EAED,OAAOI,GAAG;AACZ;AAEAQ,MAAM,CAACC,OAAO,GAAG;EACf9B,KAAK;EACLJ,kBAAkB;EAClBE;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}