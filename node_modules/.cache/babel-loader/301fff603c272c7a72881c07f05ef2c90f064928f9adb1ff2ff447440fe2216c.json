{"ast":null,"code":"import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes);\n  // add required tokenType and categoryMatches properties\n  assignTokenDefaultProps(tokenTypesAndParents);\n  // fill up the categoryMatches\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexport function expandCategories(tokenTypes) {\n  var result = cloneArr(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n  while (searching) {\n    categories = compact(flatten(map(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = difference(categories, result);\n    result = result.concat(newCategories);\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n  return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    }\n    // CATEGORIES? : TokenType | TokenType[]\n    if (hasCategoriesProperty(currTokType) && !isArray(currTokType.CATEGORIES)\n    // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n      currTokType.CATEGORIES = [currTokType.CATEGORIES];\n    }\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n  forEach(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode);\n    // avoids infinite loops due to cyclic categories.\n    if (!contains(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexport function hasShortKeyProperty(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n  return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n  return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n  return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}","map":{"version":3,"names":["cloneArr","compact","contains","difference","flatten","forEach","has","isArray","isEmpty","map","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","tokenTypeIdx","isParent","categoryMatchesMap","tokenStructuredMatcherNoCategories","token","tokType","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypes","tokenTypesAndParents","expandCategories","assignTokenDefaultProps","assignCategoriesMapProp","assignCategoriesTokensProp","categoryMatches","length","result","categories","searching","currTokType","CATEGORIES","newCategories","concat","hasShortKeyProperty","hasCategoriesProperty","hasExtendingTokensTypesProperty","hasExtendingTokensTypesMapProperty","val","key","push","singleAssignCategoriesToksMap","path","nextNode","pathNode","nextCategory","newPath","isTokenType"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/chevrotain/lib_esm/src/scan/tokens.js"],"sourcesContent":["import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\r\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\r\n    var instanceType = tokInstance.tokenTypeIdx;\r\n    if (instanceType === tokConstructor.tokenTypeIdx) {\r\n        return true;\r\n    }\r\n    else {\r\n        return (tokConstructor.isParent === true &&\r\n            tokConstructor.categoryMatchesMap[instanceType] === true);\r\n    }\r\n}\r\n// Optimized tokenMatcher in case our grammar does not use token categories\r\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\r\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\r\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\r\n}\r\nexport var tokenShortNameIdx = 1;\r\nexport var tokenIdxToClass = {};\r\nexport function augmentTokenTypes(tokenTypes) {\r\n    // collect the parent Token Types as well.\r\n    var tokenTypesAndParents = expandCategories(tokenTypes);\r\n    // add required tokenType and categoryMatches properties\r\n    assignTokenDefaultProps(tokenTypesAndParents);\r\n    // fill up the categoryMatches\r\n    assignCategoriesMapProp(tokenTypesAndParents);\r\n    assignCategoriesTokensProp(tokenTypesAndParents);\r\n    forEach(tokenTypesAndParents, function (tokType) {\r\n        tokType.isParent = tokType.categoryMatches.length > 0;\r\n    });\r\n}\r\nexport function expandCategories(tokenTypes) {\r\n    var result = cloneArr(tokenTypes);\r\n    var categories = tokenTypes;\r\n    var searching = true;\r\n    while (searching) {\r\n        categories = compact(flatten(map(categories, function (currTokType) { return currTokType.CATEGORIES; })));\r\n        var newCategories = difference(categories, result);\r\n        result = result.concat(newCategories);\r\n        if (isEmpty(newCategories)) {\r\n            searching = false;\r\n        }\r\n        else {\r\n            categories = newCategories;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexport function assignTokenDefaultProps(tokenTypes) {\r\n    forEach(tokenTypes, function (currTokType) {\r\n        if (!hasShortKeyProperty(currTokType)) {\r\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\r\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\r\n        }\r\n        // CATEGORIES? : TokenType | TokenType[]\r\n        if (hasCategoriesProperty(currTokType) &&\r\n            !isArray(currTokType.CATEGORIES)\r\n        // &&\r\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\r\n        ) {\r\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\r\n        }\r\n        if (!hasCategoriesProperty(currTokType)) {\r\n            currTokType.CATEGORIES = [];\r\n        }\r\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\r\n            currTokType.categoryMatches = [];\r\n        }\r\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\r\n            currTokType.categoryMatchesMap = {};\r\n        }\r\n    });\r\n}\r\nexport function assignCategoriesTokensProp(tokenTypes) {\r\n    forEach(tokenTypes, function (currTokType) {\r\n        // avoid duplications\r\n        currTokType.categoryMatches = [];\r\n        forEach(currTokType.categoryMatchesMap, function (val, key) {\r\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\r\n        });\r\n    });\r\n}\r\nexport function assignCategoriesMapProp(tokenTypes) {\r\n    forEach(tokenTypes, function (currTokType) {\r\n        singleAssignCategoriesToksMap([], currTokType);\r\n    });\r\n}\r\nexport function singleAssignCategoriesToksMap(path, nextNode) {\r\n    forEach(path, function (pathNode) {\r\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\r\n    });\r\n    forEach(nextNode.CATEGORIES, function (nextCategory) {\r\n        var newPath = path.concat(nextNode);\r\n        // avoids infinite loops due to cyclic categories.\r\n        if (!contains(newPath, nextCategory)) {\r\n            singleAssignCategoriesToksMap(newPath, nextCategory);\r\n        }\r\n    });\r\n}\r\nexport function hasShortKeyProperty(tokType) {\r\n    return has(tokType, \"tokenTypeIdx\");\r\n}\r\nexport function hasCategoriesProperty(tokType) {\r\n    return has(tokType, \"CATEGORIES\");\r\n}\r\nexport function hasExtendingTokensTypesProperty(tokType) {\r\n    return has(tokType, \"categoryMatches\");\r\n}\r\nexport function hasExtendingTokensTypesMapProperty(tokType) {\r\n    return has(tokType, \"categoryMatchesMap\");\r\n}\r\nexport function isTokenType(tokType) {\r\n    return has(tokType, \"tokenTypeIdx\");\r\n}\r\n//# sourceMappingURL=tokens.js.map"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,OAAO,EAAEC,OAAO,EAAEC,GAAG,EAAEC,OAAO,EAAEC,OAAO,EAAEC,GAAG,QAAQ,gBAAgB;AACtH,OAAO,SAASC,sBAAsBA,CAACC,WAAW,EAAEC,cAAc,EAAE;EAChE,IAAIC,YAAY,GAAGF,WAAW,CAACG,YAAY;EAC3C,IAAID,YAAY,KAAKD,cAAc,CAACE,YAAY,EAAE;IAC9C,OAAO,IAAI;EACf,CAAC,MACI;IACD,OAAQF,cAAc,CAACG,QAAQ,KAAK,IAAI,IACpCH,cAAc,CAACI,kBAAkB,CAACH,YAAY,CAAC,KAAK,IAAI;EAChE;AACJ;AACA;AACA;AACA,OAAO,SAASI,kCAAkCA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAC/D,OAAOD,KAAK,CAACJ,YAAY,KAAKK,OAAO,CAACL,YAAY;AACtD;AACA,OAAO,IAAIM,iBAAiB,GAAG,CAAC;AAChC,OAAO,IAAIC,eAAe,GAAG,CAAC,CAAC;AAC/B,OAAO,SAASC,iBAAiBA,CAACC,UAAU,EAAE;EAC1C;EACA,IAAIC,oBAAoB,GAAGC,gBAAgB,CAACF,UAAU,CAAC;EACvD;EACAG,uBAAuB,CAACF,oBAAoB,CAAC;EAC7C;EACAG,uBAAuB,CAACH,oBAAoB,CAAC;EAC7CI,0BAA0B,CAACJ,oBAAoB,CAAC;EAChDnB,OAAO,CAACmB,oBAAoB,EAAE,UAAUL,OAAO,EAAE;IAC7CA,OAAO,CAACJ,QAAQ,GAAGI,OAAO,CAACU,eAAe,CAACC,MAAM,GAAG,CAAC;EACzD,CAAC,CAAC;AACN;AACA,OAAO,SAASL,gBAAgBA,CAACF,UAAU,EAAE;EACzC,IAAIQ,MAAM,GAAG/B,QAAQ,CAACuB,UAAU,CAAC;EACjC,IAAIS,UAAU,GAAGT,UAAU;EAC3B,IAAIU,SAAS,GAAG,IAAI;EACpB,OAAOA,SAAS,EAAE;IACdD,UAAU,GAAG/B,OAAO,CAACG,OAAO,CAACK,GAAG,CAACuB,UAAU,EAAE,UAAUE,WAAW,EAAE;MAAE,OAAOA,WAAW,CAACC,UAAU;IAAE,CAAC,CAAC,CAAC,CAAC;IACzG,IAAIC,aAAa,GAAGjC,UAAU,CAAC6B,UAAU,EAAED,MAAM,CAAC;IAClDA,MAAM,GAAGA,MAAM,CAACM,MAAM,CAACD,aAAa,CAAC;IACrC,IAAI5B,OAAO,CAAC4B,aAAa,CAAC,EAAE;MACxBH,SAAS,GAAG,KAAK;IACrB,CAAC,MACI;MACDD,UAAU,GAAGI,aAAa;IAC9B;EACJ;EACA,OAAOL,MAAM;AACjB;AACA,OAAO,SAASL,uBAAuBA,CAACH,UAAU,EAAE;EAChDlB,OAAO,CAACkB,UAAU,EAAE,UAAUW,WAAW,EAAE;IACvC,IAAI,CAACI,mBAAmB,CAACJ,WAAW,CAAC,EAAE;MACnCb,eAAe,CAACD,iBAAiB,CAAC,GAAGc,WAAW;MAChDA,WAAW,CAACpB,YAAY,GAAGM,iBAAiB,EAAE;IAClD;IACA;IACA,IAAImB,qBAAqB,CAACL,WAAW,CAAC,IAClC,CAAC3B,OAAO,CAAC2B,WAAW,CAACC,UAAU;IACnC;IACA;IAAA,EACE;MACED,WAAW,CAACC,UAAU,GAAG,CAACD,WAAW,CAACC,UAAU,CAAC;IACrD;IACA,IAAI,CAACI,qBAAqB,CAACL,WAAW,CAAC,EAAE;MACrCA,WAAW,CAACC,UAAU,GAAG,EAAE;IAC/B;IACA,IAAI,CAACK,+BAA+B,CAACN,WAAW,CAAC,EAAE;MAC/CA,WAAW,CAACL,eAAe,GAAG,EAAE;IACpC;IACA,IAAI,CAACY,kCAAkC,CAACP,WAAW,CAAC,EAAE;MAClDA,WAAW,CAAClB,kBAAkB,GAAG,CAAC,CAAC;IACvC;EACJ,CAAC,CAAC;AACN;AACA,OAAO,SAASY,0BAA0BA,CAACL,UAAU,EAAE;EACnDlB,OAAO,CAACkB,UAAU,EAAE,UAAUW,WAAW,EAAE;IACvC;IACAA,WAAW,CAACL,eAAe,GAAG,EAAE;IAChCxB,OAAO,CAAC6B,WAAW,CAAClB,kBAAkB,EAAE,UAAU0B,GAAG,EAAEC,GAAG,EAAE;MACxDT,WAAW,CAACL,eAAe,CAACe,IAAI,CAACvB,eAAe,CAACsB,GAAG,CAAC,CAAC7B,YAAY,CAAC;IACvE,CAAC,CAAC;EACN,CAAC,CAAC;AACN;AACA,OAAO,SAASa,uBAAuBA,CAACJ,UAAU,EAAE;EAChDlB,OAAO,CAACkB,UAAU,EAAE,UAAUW,WAAW,EAAE;IACvCW,6BAA6B,CAAC,EAAE,EAAEX,WAAW,CAAC;EAClD,CAAC,CAAC;AACN;AACA,OAAO,SAASW,6BAA6BA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAC1D1C,OAAO,CAACyC,IAAI,EAAE,UAAUE,QAAQ,EAAE;IAC9BD,QAAQ,CAAC/B,kBAAkB,CAACgC,QAAQ,CAAClC,YAAY,CAAC,GAAG,IAAI;EAC7D,CAAC,CAAC;EACFT,OAAO,CAAC0C,QAAQ,CAACZ,UAAU,EAAE,UAAUc,YAAY,EAAE;IACjD,IAAIC,OAAO,GAAGJ,IAAI,CAACT,MAAM,CAACU,QAAQ,CAAC;IACnC;IACA,IAAI,CAAC7C,QAAQ,CAACgD,OAAO,EAAED,YAAY,CAAC,EAAE;MAClCJ,6BAA6B,CAACK,OAAO,EAAED,YAAY,CAAC;IACxD;EACJ,CAAC,CAAC;AACN;AACA,OAAO,SAASX,mBAAmBA,CAACnB,OAAO,EAAE;EACzC,OAAOb,GAAG,CAACa,OAAO,EAAE,cAAc,CAAC;AACvC;AACA,OAAO,SAASoB,qBAAqBA,CAACpB,OAAO,EAAE;EAC3C,OAAOb,GAAG,CAACa,OAAO,EAAE,YAAY,CAAC;AACrC;AACA,OAAO,SAASqB,+BAA+BA,CAACrB,OAAO,EAAE;EACrD,OAAOb,GAAG,CAACa,OAAO,EAAE,iBAAiB,CAAC;AAC1C;AACA,OAAO,SAASsB,kCAAkCA,CAACtB,OAAO,EAAE;EACxD,OAAOb,GAAG,CAACa,OAAO,EAAE,oBAAoB,CAAC;AAC7C;AACA,OAAO,SAASgC,WAAWA,CAAChC,OAAO,EAAE;EACjC,OAAOb,GAAG,CAACa,OAAO,EAAE,cAAc,CAAC;AACvC"},"metadata":{},"sourceType":"module","externalDependencies":[]}