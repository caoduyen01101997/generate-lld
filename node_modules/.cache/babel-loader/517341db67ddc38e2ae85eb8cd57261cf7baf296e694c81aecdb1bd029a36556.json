{"ast":null,"code":"import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\";\nimport * as utils from \"../utils/utils\";\nimport { first, map, reduce } from \"../utils/utils\";\nimport { NonTerminal, Rule, Terminal } from \"./grammar/gast/gast_public\";\nimport { getProductionDslName } from \"./grammar/gast/gast\";\nimport { validNestedRuleName } from \"./grammar/checks\";\nexport var defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function (_a) {\n    var expected = _a.expected,\n      actual = _a.actual,\n      previous = _a.previous,\n      ruleName = _a.ruleName;\n    var hasLabel = hasTokenLabel(expected);\n    var expectedMsg = hasLabel ? \"--> \" + tokenLabel(expected) + \" <--\" : \"token of type --> \" + expected.name + \" <--\";\n    var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function (_a) {\n    var firstRedundant = _a.firstRedundant,\n      ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function (_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n      actual = _a.actual,\n      previous = _a.previous,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = first(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\n        return \"[\" + map(currPath, function (currTokenType) {\n          return tokenLabel(currTokenType);\n        }).join(\", \") + \"]\";\n      });\n      var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \" + (idx + 1) + \". \" + itemMsg;\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function (_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n      actual = _a.actual,\n      customUserDescription = _a.customUserDescription,\n      ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \";\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n    var actualText = first(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\n        return \"[\" + map(currPath, function (currTokenType) {\n          return tokenLabel(currTokenType);\n        }).join(\",\") + \"]\";\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(defaultParserErrorProvider);\nexport var defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexport var defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = first(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = getProductionDslName(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\n    // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {\n    var msg = \"Invalid nested rule name: ->\" + nestedProd.name + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" + (\"it must match the pattern: ->\" + validNestedRuleName.toString() + \"<-.\\n\") + \"Note that this means a nested rule name must start with the '$'(dollar) sign.\";\n    return msg;\n  },\n  buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {\n    var duplicateName = first(nestedProd).name;\n    var errMsg = \"Duplicate nested rule name: ->\" + duplicateName + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" + \"A nested name must be unique in the scope of a top level grammar rule.\";\n    return errMsg;\n  },\n  buildNamespaceConflictError: function (rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function (options) {\n    var pathMsg = map(options.prefixPath, function (currTok) {\n      return tokenLabel(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" + (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function (options) {\n    var pathMsg = map(options.prefixPath, function (currtok) {\n      return tokenLabel(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" + (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") + (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function (options) {\n    var dslName = getProductionDslName(options.repetition);\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n    var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  buildTokenNameError: function (options) {\n    var tokTypeName = options.tokenType.name;\n    var errMsg = \"Invalid Grammar Token name: ->\" + tokTypeName + \"<- it must match the pattern: ->\" + options.expectedPattern.toString() + \"<-\";\n    return errMsg;\n  },\n  buildEmptyAlternationError: function (options) {\n    var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" + (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function (options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length + 1) + \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function (options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = utils.map(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = ruleName + \" --> \" + pathNames.concat([ruleName]).join(\" --> \");\n    var errMsg = \"Left Recursion found in grammar.\\n\" + (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") + (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\n    return errMsg;\n  },\n  buildInvalidRuleNameError: function (options) {\n    var ruleName = options.topLevelRule.name;\n    var expectedPatternString = options.expectedPattern.toString();\n    var errMsg = \"Invalid grammar rule name: ->\" + ruleName + \"<- it must match the pattern: ->\" + expectedPatternString + \"<-\";\n    return errMsg;\n  },\n  buildDuplicateRuleNameError: function (options) {\n    var ruleName;\n    if (options.topLevelRule instanceof Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n    var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\n    return errMsg;\n  }\n};","map":{"version":3,"names":["hasTokenLabel","tokenLabel","utils","first","map","reduce","NonTerminal","Rule","Terminal","getProductionDslName","validNestedRuleName","defaultParserErrorProvider","buildMismatchTokenMessage","_a","expected","actual","previous","ruleName","hasLabel","expectedMsg","name","msg","image","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","result","currAltPaths","concat","nextValidTokenSequences","currPath","currTokenType","join","nextValidSequenceItems","itemMsg","idx","calculatedDescription","buildEarlyExitMessage","expectedIterationPaths","Object","freeze","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","nonTerminalName","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument","prod","terminalType","topLevelName","duplicateProd","index","dslName","extraArgument","hasExplicitIndex","length","replace","buildInvalidNestedRuleNameError","nestedProd","toString","buildDuplicateNestedRuleNameError","duplicateName","errMsg","buildNamespaceConflictError","rule","buildAlternationPrefixAmbiguityError","options","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","tokTypeName","tokenType","expectedPattern","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","definition","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","expectedPatternString","buildDuplicateRuleNameError","grammarName"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/chevrotain/lib_esm/src/parse/errors_public.js"],"sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\";\r\nimport * as utils from \"../utils/utils\";\r\nimport { first, map, reduce } from \"../utils/utils\";\r\nimport { NonTerminal, Rule, Terminal } from \"./grammar/gast/gast_public\";\r\nimport { getProductionDslName } from \"./grammar/gast/gast\";\r\nimport { validNestedRuleName } from \"./grammar/checks\";\r\nexport var defaultParserErrorProvider = {\r\n    buildMismatchTokenMessage: function (_a) {\r\n        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;\r\n        var hasLabel = hasTokenLabel(expected);\r\n        var expectedMsg = hasLabel\r\n            ? \"--> \" + tokenLabel(expected) + \" <--\"\r\n            : \"token of type --> \" + expected.name + \" <--\";\r\n        var msg = \"Expecting \" + expectedMsg + \" but found --> '\" + actual.image + \"' <--\";\r\n        return msg;\r\n    },\r\n    buildNotAllInputParsedMessage: function (_a) {\r\n        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;\r\n        return (\"Redundant input, expecting EOF but found: \" + firstRedundant.image);\r\n    },\r\n    buildNoViableAltMessage: function (_a) {\r\n        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\r\n        var errPrefix = \"Expecting: \";\r\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\r\n        var actualText = first(actual).image;\r\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\r\n        if (customUserDescription) {\r\n            return errPrefix + customUserDescription + errSuffix;\r\n        }\r\n        else {\r\n            var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);\r\n            var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\r\n                return \"[\" + map(currPath, function (currTokenType) {\r\n                    return tokenLabel(currTokenType);\r\n                }).join(\", \") + \"]\";\r\n            });\r\n            var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) { return \"  \" + (idx + 1) + \". \" + itemMsg; });\r\n            var calculatedDescription = \"one of these possible Token sequences:\\n\" + nextValidSequenceItems.join(\"\\n\");\r\n            return errPrefix + calculatedDescription + errSuffix;\r\n        }\r\n    },\r\n    buildEarlyExitMessage: function (_a) {\r\n        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;\r\n        var errPrefix = \"Expecting: \";\r\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\r\n        var actualText = first(actual).image;\r\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\r\n        if (customUserDescription) {\r\n            return errPrefix + customUserDescription + errSuffix;\r\n        }\r\n        else {\r\n            var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\r\n                return \"[\" + map(currPath, function (currTokenType) {\r\n                    return tokenLabel(currTokenType);\r\n                }).join(\",\") + \"]\";\r\n            });\r\n            var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" +\r\n                (\"<\" + nextValidTokenSequences.join(\" ,\") + \">\");\r\n            return errPrefix + calculatedDescription + errSuffix;\r\n        }\r\n    }\r\n};\r\nObject.freeze(defaultParserErrorProvider);\r\nexport var defaultGrammarResolverErrorProvider = {\r\n    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {\r\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" +\r\n            undefinedRule.nonTerminalName +\r\n            \"<-\\n\" +\r\n            \"inside top level rule: ->\" +\r\n            topLevelRule.name +\r\n            \"<-\";\r\n        return msg;\r\n    }\r\n};\r\nexport var defaultGrammarValidatorErrorProvider = {\r\n    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {\r\n        function getExtraProductionArgument(prod) {\r\n            if (prod instanceof Terminal) {\r\n                return prod.terminalType.name;\r\n            }\r\n            else if (prod instanceof NonTerminal) {\r\n                return prod.nonTerminalName;\r\n            }\r\n            else {\r\n                return \"\";\r\n            }\r\n        }\r\n        var topLevelName = topLevelRule.name;\r\n        var duplicateProd = first(duplicateProds);\r\n        var index = duplicateProd.idx;\r\n        var dslName = getProductionDslName(duplicateProd);\r\n        var extraArgument = getExtraProductionArgument(duplicateProd);\r\n        var hasExplicitIndex = index > 0;\r\n        var msg = \"->\" + dslName + (hasExplicitIndex ? index : \"\") + \"<- \" + (extraArgument ? \"with argument: ->\" + extraArgument + \"<-\" : \"\") + \"\\n                  appears more than once (\" + duplicateProds.length + \" times) in the top level rule: ->\" + topLevelName + \"<-.                  \\n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \";\r\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\r\n        msg = msg.replace(/[ \\t]+/g, \" \");\r\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\r\n        return msg;\r\n    },\r\n    buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {\r\n        var msg = \"Invalid nested rule name: ->\" + nestedProd.name + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" +\r\n            (\"it must match the pattern: ->\" + validNestedRuleName.toString() + \"<-.\\n\") +\r\n            \"Note that this means a nested rule name must start with the '$'(dollar) sign.\";\r\n        return msg;\r\n    },\r\n    buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {\r\n        var duplicateName = first(nestedProd).name;\r\n        var errMsg = \"Duplicate nested rule name: ->\" + duplicateName + \"<- inside rule: ->\" + topLevelRule.name + \"<-\\n\" +\r\n            \"A nested name must be unique in the scope of a top level grammar rule.\";\r\n        return errMsg;\r\n    },\r\n    buildNamespaceConflictError: function (rule) {\r\n        var errMsg = \"Namespace conflict found in grammar.\\n\" +\r\n            (\"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\" + rule.name + \">.\\n\") +\r\n            \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" +\r\n            \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" +\r\n            \"and Non-Terminal names start with a lower case letter.\";\r\n        return errMsg;\r\n    },\r\n    buildAlternationPrefixAmbiguityError: function (options) {\r\n        var pathMsg = map(options.prefixPath, function (currTok) {\r\n            return tokenLabel(currTok);\r\n        }).join(\", \");\r\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\r\n        var errMsg = \"Ambiguous alternatives: <\" + options.ambiguityIndices.join(\" ,\") + \"> due to common lookahead prefix\\n\" +\r\n            (\"in <OR\" + occurrence + \"> inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\r\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\") +\r\n            \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" +\r\n            \"For Further details.\";\r\n        return errMsg;\r\n    },\r\n    buildAlternationAmbiguityError: function (options) {\r\n        var pathMsg = map(options.prefixPath, function (currtok) {\r\n            return tokenLabel(currtok);\r\n        }).join(\", \");\r\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\r\n        var currMessage = \"Ambiguous Alternatives Detected: <\" + options.ambiguityIndices.join(\" ,\") + \"> in <OR\" + occurrence + \">\" +\r\n            (\" inside <\" + options.topLevelRule.name + \"> Rule,\\n\") +\r\n            (\"<\" + pathMsg + \"> may appears as a prefix path in all these alternatives.\\n\");\r\n        currMessage =\r\n            currMessage +\r\n                \"See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" +\r\n                \"For Further details.\";\r\n        return currMessage;\r\n    },\r\n    buildEmptyRepetitionError: function (options) {\r\n        var dslName = getProductionDslName(options.repetition);\r\n        if (options.repetition.idx !== 0) {\r\n            dslName += options.repetition.idx;\r\n        }\r\n        var errMsg = \"The repetition <\" + dslName + \"> within Rule <\" + options.topLevelRule.name + \"> can never consume any tokens.\\n\" +\r\n            \"This could lead to an infinite loop.\";\r\n        return errMsg;\r\n    },\r\n    buildTokenNameError: function (options) {\r\n        var tokTypeName = options.tokenType.name;\r\n        var errMsg = \"Invalid Grammar Token name: ->\" + tokTypeName + \"<- it must match the pattern: ->\" + options.expectedPattern.toString() + \"<-\";\r\n        return errMsg;\r\n    },\r\n    buildEmptyAlternationError: function (options) {\r\n        var errMsg = \"Ambiguous empty alternative: <\" + (options.emptyChoiceIdx + 1) + \">\" +\r\n            (\" in <OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n\") +\r\n            \"Only the last alternative may be an empty alternative.\";\r\n        return errMsg;\r\n    },\r\n    buildTooManyAlternativesError: function (options) {\r\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" +\r\n            (\"<OR\" + options.alternation.idx + \"> inside <\" + options.topLevelRule.name + \"> Rule.\\n has \" + (options.alternation.definition.length +\r\n                1) + \" alternatives.\");\r\n        return errMsg;\r\n    },\r\n    buildLeftRecursionError: function (options) {\r\n        var ruleName = options.topLevelRule.name;\r\n        var pathNames = utils.map(options.leftRecursionPath, function (currRule) { return currRule.name; });\r\n        var leftRecursivePath = ruleName + \" --> \" + pathNames\r\n            .concat([ruleName])\r\n            .join(\" --> \");\r\n        var errMsg = \"Left Recursion found in grammar.\\n\" +\r\n            (\"rule: <\" + ruleName + \"> can be invoked from itself (directly or indirectly)\\n\") +\r\n            (\"without consuming any Tokens. The grammar path that causes this is: \\n \" + leftRecursivePath + \"\\n\") +\r\n            \" To fix this refactor your grammar to remove the left recursion.\\n\" +\r\n            \"see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.\";\r\n        return errMsg;\r\n    },\r\n    buildInvalidRuleNameError: function (options) {\r\n        var ruleName = options.topLevelRule.name;\r\n        var expectedPatternString = options.expectedPattern.toString();\r\n        var errMsg = \"Invalid grammar rule name: ->\" + ruleName + \"<- it must match the pattern: ->\" + expectedPatternString + \"<-\";\r\n        return errMsg;\r\n    },\r\n    buildDuplicateRuleNameError: function (options) {\r\n        var ruleName;\r\n        if (options.topLevelRule instanceof Rule) {\r\n            ruleName = options.topLevelRule.name;\r\n        }\r\n        else {\r\n            ruleName = options.topLevelRule;\r\n        }\r\n        var errMsg = \"Duplicate definition, rule: ->\" + ruleName + \"<- is already defined in the grammar: ->\" + options.grammarName + \"<-\";\r\n        return errMsg;\r\n    }\r\n};\r\n//# sourceMappingURL=errors_public.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}