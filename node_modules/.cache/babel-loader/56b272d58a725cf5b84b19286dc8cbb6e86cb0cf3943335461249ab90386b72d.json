{"ast":null,"code":"\"use strict\";\n\nconst {\n  Parser,\n  isRecognitionException\n} = require(\"chevrotain\");\nconst {\n  allTokens,\n  tokens: t\n} = require(\"./tokens\");\nconst lexicalStructure = require(\"./productions/lexical-structure\");\nconst typesValuesVariables = require(\"./productions/types-values-and-variables\");\nconst names = require(\"./productions/names\");\nconst packagesModules = require(\"./productions/packages-and-modules\");\nconst classes = require(\"./productions/classes\");\nconst interfaces = require(\"./productions/interfaces\");\nconst arrays = require(\"./productions/arrays\");\nconst blocksStatements = require(\"./productions/blocks-and-statements\");\nconst expressions = require(\"./productions/expressions\");\nconst {\n  getSkipValidations\n} = require(\"./utils\");\nconst {\n  shouldNotFormat\n} = require(\"./comments\");\n\n/**\n * This parser attempts to strongly align with the specs style at:\n * -  https://docs.oracle.com/javase/specs/jls/se11/html/jls-19.html\n *\n * Deviations from the spec will be marked.\n *\n * Note that deviations from the spec do not mean deviations from Java Grammar.\n * Rather it means an **equivalent** grammar which was written differently, e.g:\n * - LL(k) vs LR(K)\n * - Left Recursions vs Repetitions\n * - NonTerminals combined together or divided to sub-NonTerminals\n * - ...\n *\n * A special type of spec deviations are the \"super grammar\" kind.\n * This means that the parser has been defined in such a way that it accept a\n * **strict superset** of the inputs the official grammar accepts.\n *\n * This technique is used to simplify the parser when narrowing the set\n * of accepted inputs can more easily be done in a post parsing phase.\n *\n * TODO: document guide lines for using back tracking\n *\n */\nclass JavaParser extends Parser {\n  constructor() {\n    super(allTokens, {\n      maxLookahead: 1,\n      nodeLocationTracking: \"full\",\n      // traceInitPerf: 2,\n      skipValidations: getSkipValidations()\n    });\n    const $ = this;\n    this.mostEnclosiveCstNodeByStartOffset = {};\n    this.mostEnclosiveCstNodeByEndOffset = {};\n\n    // ---------------------\n    // Productions from ยง3 (Lexical Structure)\n    // ---------------------\n    // TODO: move this rule to the correct file\n    $.RULE(\"typeIdentifier\", () => {\n      // TODO: implement: Identifier but not var in the lexer\n      $.CONSUME(t.Identifier);\n    });\n\n    // Include the productions from all \"chapters\".\n    lexicalStructure.defineRules.call(this, $, t);\n    typesValuesVariables.defineRules.call(this, $, t);\n    names.defineRules.call(this, $, t);\n    classes.defineRules.call(this, $, t);\n    packagesModules.defineRules.call(this, $, t);\n    interfaces.defineRules.call(this, $, t);\n    arrays.defineRules.call(this, $, t);\n    blocksStatements.defineRules.call(this, $, t);\n    expressions.defineRules.call(this, $, t);\n    this.firstForUnaryExpressionNotPlusMinus = [];\n    this.performSelfAnalysis();\n    this.firstForUnaryExpressionNotPlusMinus = expressions.computeFirstForUnaryExpressionNotPlusMinus.call(this);\n  }\n  cstPostNonTerminal(ruleCstResult, ruleName) {\n    super.cstPostNonTerminal(ruleCstResult, ruleName);\n    if (this.isBackTracking() === false) {\n      this.mostEnclosiveCstNodeByStartOffset[ruleCstResult.location.startOffset] = ruleCstResult;\n      this.mostEnclosiveCstNodeByEndOffset[ruleCstResult.location.endOffset] = ruleCstResult;\n      shouldNotFormat(ruleCstResult, this.onOffCommentPairs);\n    }\n  }\n  BACKTRACK_LOOKAHEAD(production, errValue = false) {\n    return this.ACTION(() => {\n      this.isBackTrackingStack.push(1);\n      // TODO: \"saveRecogState\" does not handle the occurrence stack\n      const orgState = this.saveRecogState();\n      try {\n        // hack to enable outputting none CST values from grammar rules.\n        this.outputCst = false;\n        return production.call(this);\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return errValue;\n        }\n        throw e;\n      } finally {\n        this.outputCst = true;\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    });\n  }\n  setOnOffCommentPairs(onOffCommentPairs) {\n    this.onOffCommentPairs = onOffCommentPairs;\n  }\n}\nmodule.exports = JavaParser;","map":{"version":3,"names":["Parser","isRecognitionException","require","allTokens","tokens","t","lexicalStructure","typesValuesVariables","names","packagesModules","classes","interfaces","arrays","blocksStatements","expressions","getSkipValidations","shouldNotFormat","JavaParser","constructor","maxLookahead","nodeLocationTracking","skipValidations","$","mostEnclosiveCstNodeByStartOffset","mostEnclosiveCstNodeByEndOffset","RULE","CONSUME","Identifier","defineRules","call","firstForUnaryExpressionNotPlusMinus","performSelfAnalysis","computeFirstForUnaryExpressionNotPlusMinus","cstPostNonTerminal","ruleCstResult","ruleName","isBackTracking","location","startOffset","endOffset","onOffCommentPairs","BACKTRACK_LOOKAHEAD","production","errValue","ACTION","isBackTrackingStack","push","orgState","saveRecogState","outputCst","e","reloadRecogState","pop","setOnOffCommentPairs","module","exports"],"sources":["/Users/duyenpnc/Desktop/tool-tu-lam/your-app-name/node_modules/java-parser/src/parser.js"],"sourcesContent":["\"use strict\";\nconst { Parser, isRecognitionException } = require(\"chevrotain\");\nconst { allTokens, tokens: t } = require(\"./tokens\");\nconst lexicalStructure = require(\"./productions/lexical-structure\");\nconst typesValuesVariables = require(\"./productions/types-values-and-variables\");\nconst names = require(\"./productions/names\");\nconst packagesModules = require(\"./productions/packages-and-modules\");\nconst classes = require(\"./productions/classes\");\nconst interfaces = require(\"./productions/interfaces\");\nconst arrays = require(\"./productions/arrays\");\nconst blocksStatements = require(\"./productions/blocks-and-statements\");\nconst expressions = require(\"./productions/expressions\");\nconst { getSkipValidations } = require(\"./utils\");\nconst { shouldNotFormat } = require(\"./comments\");\n\n/**\n * This parser attempts to strongly align with the specs style at:\n * -  https://docs.oracle.com/javase/specs/jls/se11/html/jls-19.html\n *\n * Deviations from the spec will be marked.\n *\n * Note that deviations from the spec do not mean deviations from Java Grammar.\n * Rather it means an **equivalent** grammar which was written differently, e.g:\n * - LL(k) vs LR(K)\n * - Left Recursions vs Repetitions\n * - NonTerminals combined together or divided to sub-NonTerminals\n * - ...\n *\n * A special type of spec deviations are the \"super grammar\" kind.\n * This means that the parser has been defined in such a way that it accept a\n * **strict superset** of the inputs the official grammar accepts.\n *\n * This technique is used to simplify the parser when narrowing the set\n * of accepted inputs can more easily be done in a post parsing phase.\n *\n * TODO: document guide lines for using back tracking\n *\n */\nclass JavaParser extends Parser {\n  constructor() {\n    super(allTokens, {\n      maxLookahead: 1,\n      nodeLocationTracking: \"full\",\n      // traceInitPerf: 2,\n      skipValidations: getSkipValidations()\n    });\n\n    const $ = this;\n\n    this.mostEnclosiveCstNodeByStartOffset = {};\n    this.mostEnclosiveCstNodeByEndOffset = {};\n\n    // ---------------------\n    // Productions from ยง3 (Lexical Structure)\n    // ---------------------\n    // TODO: move this rule to the correct file\n    $.RULE(\"typeIdentifier\", () => {\n      // TODO: implement: Identifier but not var in the lexer\n      $.CONSUME(t.Identifier);\n    });\n\n    // Include the productions from all \"chapters\".\n    lexicalStructure.defineRules.call(this, $, t);\n    typesValuesVariables.defineRules.call(this, $, t);\n    names.defineRules.call(this, $, t);\n    classes.defineRules.call(this, $, t);\n    packagesModules.defineRules.call(this, $, t);\n    interfaces.defineRules.call(this, $, t);\n    arrays.defineRules.call(this, $, t);\n    blocksStatements.defineRules.call(this, $, t);\n    expressions.defineRules.call(this, $, t);\n\n    this.firstForUnaryExpressionNotPlusMinus = [];\n    this.performSelfAnalysis();\n    this.firstForUnaryExpressionNotPlusMinus =\n      expressions.computeFirstForUnaryExpressionNotPlusMinus.call(this);\n  }\n\n  cstPostNonTerminal(ruleCstResult, ruleName) {\n    super.cstPostNonTerminal(ruleCstResult, ruleName);\n    if (this.isBackTracking() === false) {\n      this.mostEnclosiveCstNodeByStartOffset[\n        ruleCstResult.location.startOffset\n      ] = ruleCstResult;\n      this.mostEnclosiveCstNodeByEndOffset[ruleCstResult.location.endOffset] =\n        ruleCstResult;\n\n      shouldNotFormat(ruleCstResult, this.onOffCommentPairs);\n    }\n  }\n\n  BACKTRACK_LOOKAHEAD(production, errValue = false) {\n    return this.ACTION(() => {\n      this.isBackTrackingStack.push(1);\n      // TODO: \"saveRecogState\" does not handle the occurrence stack\n      const orgState = this.saveRecogState();\n      try {\n        // hack to enable outputting none CST values from grammar rules.\n        this.outputCst = false;\n        return production.call(this);\n      } catch (e) {\n        if (isRecognitionException(e)) {\n          return errValue;\n        }\n        throw e;\n      } finally {\n        this.outputCst = true;\n        this.reloadRecogState(orgState);\n        this.isBackTrackingStack.pop();\n      }\n    });\n  }\n\n  setOnOffCommentPairs(onOffCommentPairs) {\n    this.onOffCommentPairs = onOffCommentPairs;\n  }\n}\n\nmodule.exports = JavaParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}