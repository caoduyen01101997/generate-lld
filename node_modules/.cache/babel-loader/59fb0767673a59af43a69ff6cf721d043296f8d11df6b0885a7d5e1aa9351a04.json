{"ast":null,"code":"import { END_OF_FILE } from \"../parser\";\n/**\r\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\r\n *\r\n * This could be generalized to support other kinds of lexers, e.g.\r\n * - Just in Time Lexing / Lexer-Less parsing.\r\n * - Streaming Lexer.\r\n */\nvar LexerAdapter = /** @class */function () {\n  function LexerAdapter() {}\n  LexerAdapter.prototype.initLexerAdapter = function () {\n    this.tokVector = [];\n    this.tokVectorLength = 0;\n    this.currIdx = -1;\n  };\n  Object.defineProperty(LexerAdapter.prototype, \"input\", {\n    get: function () {\n      return this.tokVector;\n    },\n    set: function (newInput) {\n      if (this.selfAnalysisDone !== true) {\n        throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n      }\n      this.reset();\n      this.tokVector = newInput;\n      this.tokVectorLength = newInput.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  // skips a token and returns the next token\n  LexerAdapter.prototype.SKIP_TOKEN = function () {\n    if (this.currIdx <= this.tokVector.length - 2) {\n      this.consumeToken();\n      return this.LA(1);\n    } else {\n      return END_OF_FILE;\n    }\n  };\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n  // or lexers dependent on parser context.\n  LexerAdapter.prototype.LA = function (howMuch) {\n    var soughtIdx = this.currIdx + howMuch;\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n      return END_OF_FILE;\n    } else {\n      return this.tokVector[soughtIdx];\n    }\n  };\n  LexerAdapter.prototype.consumeToken = function () {\n    this.currIdx++;\n  };\n  LexerAdapter.prototype.exportLexerState = function () {\n    return this.currIdx;\n  };\n  LexerAdapter.prototype.importLexerState = function (newState) {\n    this.currIdx = newState;\n  };\n  LexerAdapter.prototype.resetLexerState = function () {\n    this.currIdx = -1;\n  };\n  LexerAdapter.prototype.moveToTerminatedState = function () {\n    this.currIdx = this.tokVector.length - 1;\n  };\n  LexerAdapter.prototype.getLexerPosition = function () {\n    return this.exportLexerState();\n  };\n  return LexerAdapter;\n}();\nexport { LexerAdapter };","map":{"version":3,"names":["END_OF_FILE","LexerAdapter","prototype","initLexerAdapter","tokVector","tokVectorLength","currIdx","Object","defineProperty","get","set","newInput","selfAnalysisDone","Error","reset","length","enumerable","configurable","SKIP_TOKEN","consumeToken","LA","howMuch","soughtIdx","exportLexerState","importLexerState","newState","resetLexerState","moveToTerminatedState","getLexerPosition"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/chevrotain/lib_esm/src/parse/parser/traits/lexer_adapter.js"],"sourcesContent":["import { END_OF_FILE } from \"../parser\";\r\n/**\r\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\r\n *\r\n * This could be generalized to support other kinds of lexers, e.g.\r\n * - Just in Time Lexing / Lexer-Less parsing.\r\n * - Streaming Lexer.\r\n */\r\nvar LexerAdapter = /** @class */ (function () {\r\n    function LexerAdapter() {\r\n    }\r\n    LexerAdapter.prototype.initLexerAdapter = function () {\r\n        this.tokVector = [];\r\n        this.tokVectorLength = 0;\r\n        this.currIdx = -1;\r\n    };\r\n    Object.defineProperty(LexerAdapter.prototype, \"input\", {\r\n        get: function () {\r\n            return this.tokVector;\r\n        },\r\n        set: function (newInput) {\r\n            if (this.selfAnalysisDone !== true) {\r\n                throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\r\n            }\r\n            this.reset();\r\n            this.tokVector = newInput;\r\n            this.tokVectorLength = newInput.length;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // skips a token and returns the next token\r\n    LexerAdapter.prototype.SKIP_TOKEN = function () {\r\n        if (this.currIdx <= this.tokVector.length - 2) {\r\n            this.consumeToken();\r\n            return this.LA(1);\r\n        }\r\n        else {\r\n            return END_OF_FILE;\r\n        }\r\n    };\r\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\r\n    // or lexers dependent on parser context.\r\n    LexerAdapter.prototype.LA = function (howMuch) {\r\n        var soughtIdx = this.currIdx + howMuch;\r\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\r\n            return END_OF_FILE;\r\n        }\r\n        else {\r\n            return this.tokVector[soughtIdx];\r\n        }\r\n    };\r\n    LexerAdapter.prototype.consumeToken = function () {\r\n        this.currIdx++;\r\n    };\r\n    LexerAdapter.prototype.exportLexerState = function () {\r\n        return this.currIdx;\r\n    };\r\n    LexerAdapter.prototype.importLexerState = function (newState) {\r\n        this.currIdx = newState;\r\n    };\r\n    LexerAdapter.prototype.resetLexerState = function () {\r\n        this.currIdx = -1;\r\n    };\r\n    LexerAdapter.prototype.moveToTerminatedState = function () {\r\n        this.currIdx = this.tokVector.length - 1;\r\n    };\r\n    LexerAdapter.prototype.getLexerPosition = function () {\r\n        return this.exportLexerState();\r\n    };\r\n    return LexerAdapter;\r\n}());\r\nexport { LexerAdapter };\r\n//# sourceMappingURL=lexer_adapter.js.map"],"mappings":"AAAA,SAASA,WAAW,QAAQ,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,YAAY,GAAG,aAAe,YAAY;EAC1C,SAASA,YAAYA,CAAA,EAAG,CACxB;EACAA,YAAY,CAACC,SAAS,CAACC,gBAAgB,GAAG,YAAY;IAClD,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;EACrB,CAAC;EACDC,MAAM,CAACC,cAAc,CAACP,YAAY,CAACC,SAAS,EAAE,OAAO,EAAE;IACnDO,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACL,SAAS;IACzB,CAAC;IACDM,GAAG,EAAE,SAAAA,CAAUC,QAAQ,EAAE;MACrB,IAAI,IAAI,CAACC,gBAAgB,KAAK,IAAI,EAAE;QAChC,MAAMC,KAAK,CAAC,kFAAkF,CAAC;MACnG;MACA,IAAI,CAACC,KAAK,CAAC,CAAC;MACZ,IAAI,CAACV,SAAS,GAAGO,QAAQ;MACzB,IAAI,CAACN,eAAe,GAAGM,QAAQ,CAACI,MAAM;IAC1C,CAAC;IACDC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;EACAhB,YAAY,CAACC,SAAS,CAACgB,UAAU,GAAG,YAAY;IAC5C,IAAI,IAAI,CAACZ,OAAO,IAAI,IAAI,CAACF,SAAS,CAACW,MAAM,GAAG,CAAC,EAAE;MAC3C,IAAI,CAACI,YAAY,CAAC,CAAC;MACnB,OAAO,IAAI,CAACC,EAAE,CAAC,CAAC,CAAC;IACrB,CAAC,MACI;MACD,OAAOpB,WAAW;IACtB;EACJ,CAAC;EACD;EACA;EACAC,YAAY,CAACC,SAAS,CAACkB,EAAE,GAAG,UAAUC,OAAO,EAAE;IAC3C,IAAIC,SAAS,GAAG,IAAI,CAAChB,OAAO,GAAGe,OAAO;IACtC,IAAIC,SAAS,GAAG,CAAC,IAAI,IAAI,CAACjB,eAAe,IAAIiB,SAAS,EAAE;MACpD,OAAOtB,WAAW;IACtB,CAAC,MACI;MACD,OAAO,IAAI,CAACI,SAAS,CAACkB,SAAS,CAAC;IACpC;EACJ,CAAC;EACDrB,YAAY,CAACC,SAAS,CAACiB,YAAY,GAAG,YAAY;IAC9C,IAAI,CAACb,OAAO,EAAE;EAClB,CAAC;EACDL,YAAY,CAACC,SAAS,CAACqB,gBAAgB,GAAG,YAAY;IAClD,OAAO,IAAI,CAACjB,OAAO;EACvB,CAAC;EACDL,YAAY,CAACC,SAAS,CAACsB,gBAAgB,GAAG,UAAUC,QAAQ,EAAE;IAC1D,IAAI,CAACnB,OAAO,GAAGmB,QAAQ;EAC3B,CAAC;EACDxB,YAAY,CAACC,SAAS,CAACwB,eAAe,GAAG,YAAY;IACjD,IAAI,CAACpB,OAAO,GAAG,CAAC,CAAC;EACrB,CAAC;EACDL,YAAY,CAACC,SAAS,CAACyB,qBAAqB,GAAG,YAAY;IACvD,IAAI,CAACrB,OAAO,GAAG,IAAI,CAACF,SAAS,CAACW,MAAM,GAAG,CAAC;EAC5C,CAAC;EACDd,YAAY,CAACC,SAAS,CAAC0B,gBAAgB,GAAG,YAAY;IAClD,OAAO,IAAI,CAACL,gBAAgB,CAAC,CAAC;EAClC,CAAC;EACD,OAAOtB,YAAY;AACvB,CAAC,CAAC,CAAE;AACJ,SAASA,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}