{"ast":null,"code":"\"use strict\";\n\nconst JavaLexer = require(\"./lexer\");\nconst JavaParser = require(\"./parser\");\nconst {\n  attachComments,\n  matchFormatterOffOnPairs\n} = require(\"./comments\");\nconst parser = new JavaParser();\nconst BaseJavaCstVisitor = parser.getBaseCstVisitorConstructor();\nconst BaseJavaCstVisitorWithDefaults = parser.getBaseCstVisitorConstructorWithDefaults();\nfunction parse(inputText) {\n  let entryPoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"compilationUnit\";\n  // Lex\n  const lexResult = JavaLexer.tokenize(inputText);\n  if (lexResult.errors.length > 0) {\n    const firstError = lexResult.errors[0];\n    throw Error(\"Sad sad panda, lexing errors detected in line: \" + firstError.line + \", column: \" + firstError.column + \"!\\n\" + firstError.message);\n  }\n  parser.input = lexResult.tokens;\n  parser.mostEnclosiveCstNodeByStartOffset = {};\n  parser.mostEnclosiveCstNodeByEndOffset = {};\n  parser.setOnOffCommentPairs(matchFormatterOffOnPairs(lexResult.groups.comments));\n\n  // Automatic CST created when parsing\n  const cst = parser[entryPoint]();\n  if (parser.errors.length > 0) {\n    const error = parser.errors[0];\n    throw Error(\"Sad sad panda, parsing errors detected in line: \" + error.token.startLine + \", column: \" + error.token.startColumn + \"!\\n\" + error.message + \"!\\n\\t->\" + error.context.ruleStack.join(\"\\n\\t->\"));\n  }\n  attachComments(lexResult.tokens, lexResult.groups.comments, parser.mostEnclosiveCstNodeByStartOffset, parser.mostEnclosiveCstNodeByEndOffset);\n  return cst;\n}\nmodule.exports = {\n  parse,\n  BaseJavaCstVisitor,\n  BaseJavaCstVisitorWithDefaults\n};","map":{"version":3,"names":["JavaLexer","require","JavaParser","attachComments","matchFormatterOffOnPairs","parser","BaseJavaCstVisitor","getBaseCstVisitorConstructor","BaseJavaCstVisitorWithDefaults","getBaseCstVisitorConstructorWithDefaults","parse","inputText","entryPoint","arguments","length","undefined","lexResult","tokenize","errors","firstError","Error","line","column","message","input","tokens","mostEnclosiveCstNodeByStartOffset","mostEnclosiveCstNodeByEndOffset","setOnOffCommentPairs","groups","comments","cst","error","token","startLine","startColumn","context","ruleStack","join","module","exports"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/java-parser/src/index.js"],"sourcesContent":["\"use strict\";\r\nconst JavaLexer = require(\"./lexer\");\r\nconst JavaParser = require(\"./parser\");\r\nconst { attachComments, matchFormatterOffOnPairs } = require(\"./comments\");\r\n\r\nconst parser = new JavaParser();\r\n\r\nconst BaseJavaCstVisitor = parser.getBaseCstVisitorConstructor();\r\nconst BaseJavaCstVisitorWithDefaults =\r\n  parser.getBaseCstVisitorConstructorWithDefaults();\r\n\r\nfunction parse(inputText, entryPoint = \"compilationUnit\") {\r\n  // Lex\r\n  const lexResult = JavaLexer.tokenize(inputText);\r\n\r\n  if (lexResult.errors.length > 0) {\r\n    const firstError = lexResult.errors[0];\r\n    throw Error(\r\n      \"Sad sad panda, lexing errors detected in line: \" +\r\n        firstError.line +\r\n        \", column: \" +\r\n        firstError.column +\r\n        \"!\\n\" +\r\n        firstError.message\r\n    );\r\n  }\r\n\r\n  parser.input = lexResult.tokens;\r\n  parser.mostEnclosiveCstNodeByStartOffset = {};\r\n  parser.mostEnclosiveCstNodeByEndOffset = {};\r\n\r\n  parser.setOnOffCommentPairs(\r\n    matchFormatterOffOnPairs(lexResult.groups.comments)\r\n  );\r\n\r\n  // Automatic CST created when parsing\r\n  const cst = parser[entryPoint]();\r\n\r\n  if (parser.errors.length > 0) {\r\n    const error = parser.errors[0];\r\n    throw Error(\r\n      \"Sad sad panda, parsing errors detected in line: \" +\r\n        error.token.startLine +\r\n        \", column: \" +\r\n        error.token.startColumn +\r\n        \"!\\n\" +\r\n        error.message +\r\n        \"!\\n\\t->\" +\r\n        error.context.ruleStack.join(\"\\n\\t->\")\r\n    );\r\n  }\r\n\r\n  attachComments(\r\n    lexResult.tokens,\r\n    lexResult.groups.comments,\r\n    parser.mostEnclosiveCstNodeByStartOffset,\r\n    parser.mostEnclosiveCstNodeByEndOffset\r\n  );\r\n\r\n  return cst;\r\n}\r\n\r\nmodule.exports = {\r\n  parse,\r\n  BaseJavaCstVisitor,\r\n  BaseJavaCstVisitorWithDefaults\r\n};\r\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC;AACpC,MAAMC,UAAU,GAAGD,OAAO,CAAC,UAAU,CAAC;AACtC,MAAM;EAAEE,cAAc;EAAEC;AAAyB,CAAC,GAAGH,OAAO,CAAC,YAAY,CAAC;AAE1E,MAAMI,MAAM,GAAG,IAAIH,UAAU,CAAC,CAAC;AAE/B,MAAMI,kBAAkB,GAAGD,MAAM,CAACE,4BAA4B,CAAC,CAAC;AAChE,MAAMC,8BAA8B,GAClCH,MAAM,CAACI,wCAAwC,CAAC,CAAC;AAEnD,SAASC,KAAKA,CAACC,SAAS,EAAkC;EAAA,IAAhCC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,iBAAiB;EACtD;EACA,MAAMG,SAAS,GAAGhB,SAAS,CAACiB,QAAQ,CAACN,SAAS,CAAC;EAE/C,IAAIK,SAAS,CAACE,MAAM,CAACJ,MAAM,GAAG,CAAC,EAAE;IAC/B,MAAMK,UAAU,GAAGH,SAAS,CAACE,MAAM,CAAC,CAAC,CAAC;IACtC,MAAME,KAAK,CACT,iDAAiD,GAC/CD,UAAU,CAACE,IAAI,GACf,YAAY,GACZF,UAAU,CAACG,MAAM,GACjB,KAAK,GACLH,UAAU,CAACI,OACf,CAAC;EACH;EAEAlB,MAAM,CAACmB,KAAK,GAAGR,SAAS,CAACS,MAAM;EAC/BpB,MAAM,CAACqB,iCAAiC,GAAG,CAAC,CAAC;EAC7CrB,MAAM,CAACsB,+BAA+B,GAAG,CAAC,CAAC;EAE3CtB,MAAM,CAACuB,oBAAoB,CACzBxB,wBAAwB,CAACY,SAAS,CAACa,MAAM,CAACC,QAAQ,CACpD,CAAC;;EAED;EACA,MAAMC,GAAG,GAAG1B,MAAM,CAACO,UAAU,CAAC,CAAC,CAAC;EAEhC,IAAIP,MAAM,CAACa,MAAM,CAACJ,MAAM,GAAG,CAAC,EAAE;IAC5B,MAAMkB,KAAK,GAAG3B,MAAM,CAACa,MAAM,CAAC,CAAC,CAAC;IAC9B,MAAME,KAAK,CACT,kDAAkD,GAChDY,KAAK,CAACC,KAAK,CAACC,SAAS,GACrB,YAAY,GACZF,KAAK,CAACC,KAAK,CAACE,WAAW,GACvB,KAAK,GACLH,KAAK,CAACT,OAAO,GACb,SAAS,GACTS,KAAK,CAACI,OAAO,CAACC,SAAS,CAACC,IAAI,CAAC,QAAQ,CACzC,CAAC;EACH;EAEAnC,cAAc,CACZa,SAAS,CAACS,MAAM,EAChBT,SAAS,CAACa,MAAM,CAACC,QAAQ,EACzBzB,MAAM,CAACqB,iCAAiC,EACxCrB,MAAM,CAACsB,+BACT,CAAC;EAED,OAAOI,GAAG;AACZ;AAEAQ,MAAM,CAACC,OAAO,GAAG;EACf9B,KAAK;EACLJ,kBAAkB;EAClBE;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}