{"ast":null,"code":"\"use strict\";\n\nconst {\n  createToken: createTokenOrg,\n  Lexer\n} = require(\"chevrotain\");\nconst camelCase = require(\"lodash/camelCase\");\nlet chars;\n// A little mini DSL for easier lexer definition.\nconst fragments = {};\ntry {\n  chars = require(\"./unicodesets\");\n} catch (e) {\n  throw Error(\"unicodesets.js file could not be found. Did you try to run the command: yarn run build ?\");\n}\nfunction inlineFragments(def) {\n  let inlinedDef = def;\n  Object.keys(fragments).forEach(prevFragmentName => {\n    const prevFragmentDef = fragments[prevFragmentName];\n    const templateRegExp = new RegExp(`{{${prevFragmentName}}}`, \"g\");\n    inlinedDef = inlinedDef.replace(templateRegExp, prevFragmentDef);\n  });\n  return inlinedDef;\n}\nfunction FRAGMENT(name, def) {\n  fragments[name] = inlineFragments(def);\n}\nfunction MAKE_PATTERN(def, flags) {\n  const inlinedDef = inlineFragments(def);\n  return new RegExp(inlinedDef, flags);\n}\n\n// The order of fragments definitions is important\nFRAGMENT(\"Digits\", \"[0-9]([0-9_]*[0-9])?\");\nFRAGMENT(\"ExponentPart\", \"[eE][+-]?{{Digits}}\");\nFRAGMENT(\"HexDigit\", \"[0-9a-fA-F]\");\nFRAGMENT(\"HexDigits\", \"{{HexDigit}}(({{HexDigit}}|'_')*{{HexDigit}})?\");\nFRAGMENT(\"FloatTypeSuffix\", \"[fFdD]\");\nFRAGMENT(\"LineTerminator\", \"(\\\\x0A|(\\\\x0D(\\\\x0A)?))\");\nFRAGMENT(\"UnicodeMarker\", \"uu*\");\nFRAGMENT(\"UnicodeEscape\", \"\\\\\\\\{{UnicodeMarker}}{{HexDigit}}{4}\");\nFRAGMENT(\"RawInputCharacter\", \"\\\\\\\\{{UnicodeMarker}}[0-9a-fA-F]{4}\");\nFRAGMENT(\"UnicodeInputCharacter\", \"({{UnicodeEscape}}|{{RawInputCharacter}})\");\nFRAGMENT(\"OctalDigit\", \"[0-7]\");\nFRAGMENT(\"ZeroToThree\", \"[0-3]\");\nFRAGMENT(\"OctalEscape\", \"\\\\\\\\({{OctalDigit}}|{{ZeroToThree}}?{{OctalDigit}}{2})\");\nFRAGMENT(\"EscapeSequence\", \"\\\\\\\\[bstnfr\\\"'\\\\\\\\]|{{OctalEscape}}\");\n// Not using InputCharacter terminology there because CR and LF are already captured in EscapeSequence\nFRAGMENT(\"StringCharacter\", \"(?:(?:{{EscapeSequence}})|{{UnicodeInputCharacter}})\");\nfunction matchJavaIdentifier(text, startOffset) {\n  let endOffset = startOffset;\n  let charCode = text.codePointAt(endOffset);\n\n  // We verifiy if the first character is from one of these categories\n  // Corresponds to the isJavaIdentifierStart function from Java\n  if (chars.firstIdentChar.has(charCode)) {\n    endOffset++;\n    // If we encounter a surrogate pair (something that is beyond 65535/FFFF)\n    // We skip another offset because a surrogate pair is of length 2.\n    if (charCode > 65535) {\n      endOffset++;\n    }\n    charCode = text.codePointAt(endOffset);\n  }\n\n  // We verify if the remaining characters is from one of these categories\n  // Corresponds to the isJavaIdentifierPart function from Java\n  while (chars.restIdentChar.has(charCode)) {\n    endOffset++;\n    // See above.\n    if (charCode > 65535) {\n      endOffset++;\n    }\n    charCode = text.codePointAt(endOffset);\n  }\n\n  // No match, must return null to conform with the RegExp.prototype.exec signature\n  if (endOffset === startOffset) {\n    return null;\n  }\n  const matchedString = text.substring(startOffset, endOffset);\n  // according to the RegExp.prototype.exec API the first item in the returned array must be the whole matched string.\n  return [matchedString];\n}\nconst Identifier = createTokenOrg({\n  name: \"Identifier\",\n  pattern: {\n    exec: matchJavaIdentifier\n  },\n  line_breaks: false,\n  start_chars_hint: Array.from(chars.firstIdentChar, x => String.fromCharCode(x))\n});\nconst allTokens = [];\nconst tokenDictionary = {};\nfunction createToken(options) {\n  // TODO create a test to check all the tokenbs have a label defined\n  if (!options.label) {\n    // simple token (e.g operator)\n    if (typeof options.pattern === \"string\") {\n      options.label = `'${options.pattern}'`;\n    }\n    // Complex token (e.g literal)\n    else if (options.pattern instanceof RegExp) {\n      options.label = `'${options.name}'`;\n    }\n  }\n  const newTokenType = createTokenOrg(options);\n  allTokens.push(newTokenType);\n  tokenDictionary[options.name] = newTokenType;\n  return newTokenType;\n}\nfunction createKeywordLikeToken(options) {\n  // A keyword 'like' token uses the \"longer_alt\" config option\n  // to resolve ambiguities, see: http://sap.github.io/chevrotain/docs/features/token_alternative_matches.html\n  options.longer_alt = Identifier;\n  return createToken(options);\n}\n\n// Token Categories\n// Used a Token Category to mark all restricted keywords.\n// This could be used in syntax highlights implementation.\nconst RestrictedKeyword = createToken({\n  name: \"RestrictedKeyword\",\n  pattern: Lexer.NA\n});\n\n// Used a Token Category to mark all keywords.\n// This could be used in syntax highlights implementation.\nconst Keyword = createToken({\n  name: \"Keyword\",\n  pattern: Lexer.NA\n});\nconst AssignmentOperator = createToken({\n  name: \"AssignmentOperator\",\n  pattern: Lexer.NA\n});\nconst BinaryOperator = createToken({\n  name: \"BinaryOperator\",\n  pattern: Lexer.NA\n});\nconst UnaryPrefixOperator = createToken({\n  name: \"UnaryPrefixOperator\",\n  pattern: Lexer.NA\n});\nconst UnaryPrefixOperatorNotPlusMinus = createToken({\n  name: \"UnaryPrefixOperatorNotPlusMinus\",\n  pattern: Lexer.NA\n});\nconst UnarySuffixOperator = createToken({\n  name: \"UnarySuffixOperator\",\n  pattern: Lexer.NA\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.11\nconst Separators = createToken({\n  name: \"Separators\",\n  pattern: Lexer.NA\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.6\n// Note [\\\\x09\\\\x20\\\\x0C] is equivalent to [\\\\t\\\\x20\\\\f] and that \\\\x20 represents\n// space character\ncreateToken({\n  name: \"WhiteSpace\",\n  pattern: MAKE_PATTERN(\"[\\\\x09\\\\x20\\\\x0C]|{{LineTerminator}}\"),\n  group: Lexer.SKIPPED\n});\ncreateToken({\n  name: \"LineComment\",\n  pattern: /\\/\\/[^\\n\\r]*/,\n  group: \"comments\"\n});\ncreateToken({\n  name: \"TraditionalComment\",\n  pattern: /\\/\\*([^*]|\\*(?!\\/))*\\*\\//,\n  group: \"comments\"\n});\ncreateToken({\n  name: \"BinaryLiteral\",\n  pattern: /0[bB][01]([01_]*[01])?[lL]?/\n});\ncreateToken({\n  name: \"FloatLiteral\",\n  pattern: MAKE_PATTERN(\"{{Digits}}\\\\.({{Digits}})?({{ExponentPart}})?({{FloatTypeSuffix}})?|\" + \"\\\\.{{Digits}}({{ExponentPart}})?({{FloatTypeSuffix}})?|\" + \"{{Digits}}{{ExponentPart}}({{FloatTypeSuffix}})?|\" + \"{{Digits}}({{ExponentPart}})?{{FloatTypeSuffix}}\")\n});\ncreateToken({\n  name: \"OctalLiteral\",\n  pattern: /0_*[0-7]([0-7_]*[0-7])?[lL]?/\n});\ncreateToken({\n  name: \"HexFloatLiteral\",\n  pattern: MAKE_PATTERN(\"0[xX]({{HexDigits}}\\\\.?|({{HexDigits}})?\\\\.{{HexDigits}})[pP][+-]?{{Digits}}[fFdD]?\")\n});\ncreateToken({\n  name: \"HexLiteral\",\n  pattern: /0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?[lL]?/\n});\ncreateToken({\n  name: \"DecimalLiteral\",\n  pattern: MAKE_PATTERN(\"(0|[1-9](_+{{Digits}}|({{Digits}})?))[lL]?\")\n});\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.4\ncreateToken({\n  name: \"CharLiteral\",\n  // Not using SingleCharacter Terminology because ' and \\ are captured in EscapeSequence\n  pattern: MAKE_PATTERN(\"'(?:[^\\\\\\\\']|(?:(?:{{EscapeSequence}})|{{UnicodeInputCharacter}}))'\")\n});\ncreateToken({\n  name: \"TextBlock\",\n  pattern: /\"\"\"\\s*\\n(\\\\\"|\\s|.)*?\"\"\"/\n});\ncreateToken({\n  name: \"StringLiteral\",\n  pattern: MAKE_PATTERN('\"(?:[^\\\\\\\\\"]|{{StringCharacter}})*\"')\n});\n\n// https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.9\n// TODO: how to handle the special rule (see spec above) for \"requires\" and \"transitive\"\nconst restrictedKeywords = [\"open\", \"module\", \"requires\", \"transitive\", \"exports\", \"opens\", \"to\", \"uses\", \"provides\", \"when\", \"with\", \"sealed\", \"non-sealed\", \"permits\"];\n\n// By sorting the keywords in descending order we avoid ambiguities\n// of common prefixes.\nsortDescLength(restrictedKeywords).forEach(word => {\n  createKeywordLikeToken({\n    name: word[0].toUpperCase() + camelCase(word.substr(1)),\n    pattern: word,\n    // restricted keywords can also be used as an Identifiers according to the spec.\n    // TODO: inspect this causes no ambiguities\n    categories: [Identifier, RestrictedKeyword]\n  });\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.9\nconst keywords = [\"abstract\", \"continue\", \"for\", \"new\", \"switch\", \"assert\", \"default\", \"if\", \"package\", \"synchronized\", \"boolean\", \"do\", \"goto\", \"private\", \"this\", \"break\", \"double\", \"implements\", \"protected\", \"throw\", \"byte\", \"else\", \"import\", \"public\", \"throws\", \"case\", \"enum\",\n// \"instanceof\", // special handling for \"instanceof\" operator below\n\"return\", \"transient\", \"catch\", \"extends\", \"int\", \"short\", \"try\", \"char\", \"final\", \"interface\", \"static\", \"void\", \"class\", \"finally\", \"long\", \"strictfp\", \"volatile\", \"const\", \"float\", \"native\", \"super\", \"while\", [\"_\", \"underscore\"]];\nsortDescLength(keywords).forEach(word => {\n  // For handling symbols keywords (underscore)\n  const isPair = Array.isArray(word);\n  const actualName = isPair ? word[1] : word;\n  const actualPattern = isPair ? word[0] : word;\n  const options = {\n    name: actualName[0].toUpperCase() + actualName.substr(1),\n    pattern: actualPattern,\n    categories: Keyword\n  };\n  if (isPair) {\n    options.label = `'${actualName}'`;\n  }\n  createKeywordLikeToken(options);\n});\ncreateKeywordLikeToken({\n  name: \"Instanceof\",\n  pattern: \"instanceof\",\n  categories: [Keyword, BinaryOperator]\n});\ncreateKeywordLikeToken({\n  name: \"Var\",\n  pattern: \"var\",\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.9\n  // \"var is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration\"\n  categories: Identifier\n});\ncreateKeywordLikeToken({\n  name: \"Yield\",\n  pattern: \"yield\",\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.9\n  // \"yield is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration\"\n  categories: Identifier\n});\ncreateKeywordLikeToken({\n  name: \"Record\",\n  pattern: \"record\",\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.9\n  // \"record is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration\"\n  categories: Identifier\n});\ncreateKeywordLikeToken({\n  name: \"True\",\n  pattern: \"true\"\n});\ncreateKeywordLikeToken({\n  name: \"False\",\n  pattern: \"false\"\n});\ncreateKeywordLikeToken({\n  name: \"Null\",\n  pattern: \"null\"\n});\n\n// punctuation and symbols\ncreateToken({\n  name: \"At\",\n  pattern: \"@\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"Arrow\",\n  pattern: \"->\"\n});\ncreateToken({\n  name: \"DotDotDot\",\n  pattern: \"...\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"Dot\",\n  pattern: \".\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"Comma\",\n  pattern: \",\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"Semicolon\",\n  pattern: \";\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"ColonColon\",\n  pattern: \"::\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"Colon\",\n  pattern: \":\"\n});\ncreateToken({\n  name: \"QuestionMark\",\n  pattern: \"?\"\n});\ncreateToken({\n  name: \"LBrace\",\n  pattern: \"(\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"RBrace\",\n  pattern: \")\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"LCurly\",\n  pattern: \"{\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"RCurly\",\n  pattern: \"}\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"LSquare\",\n  pattern: \"[\",\n  categories: [Separators]\n});\ncreateToken({\n  name: \"RSquare\",\n  pattern: \"]\",\n  categories: [Separators]\n});\n\n// prefix and suffix operators\n// must be defined before \"-\"\ncreateToken({\n  name: \"MinusMinus\",\n  pattern: \"--\",\n  categories: [UnaryPrefixOperator, UnarySuffixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\n// must be defined before \"+\"\ncreateToken({\n  name: \"PlusPlus\",\n  pattern: \"++\",\n  categories: [UnaryPrefixOperator, UnarySuffixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\ncreateToken({\n  name: \"Complement\",\n  pattern: \"~\",\n  categories: [UnaryPrefixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\ncreateToken({\n  name: \"LessEquals\",\n  pattern: \"<=\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"LessLessEquals\",\n  pattern: \"<<=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Less\",\n  pattern: \"<\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"GreaterEquals\",\n  pattern: \">=\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"GreaterGreaterEquals\",\n  pattern: \">>=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"GreaterGreaterGreaterEquals\",\n  pattern: \">>>=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Greater\",\n  pattern: \">\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"EqualsEquals\",\n  pattern: \"==\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"Equals\",\n  pattern: \"=\",\n  categories: [BinaryOperator, AssignmentOperator]\n});\ncreateToken({\n  name: \"MinusEquals\",\n  pattern: \"-=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Minus\",\n  pattern: \"-\",\n  categories: [BinaryOperator, UnaryPrefixOperator]\n});\ncreateToken({\n  name: \"PlusEquals\",\n  pattern: \"+=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Plus\",\n  pattern: \"+\",\n  categories: [BinaryOperator, UnaryPrefixOperator]\n});\ncreateToken({\n  name: \"AndAnd\",\n  pattern: \"&&\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"AndEquals\",\n  pattern: \"&=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"And\",\n  pattern: \"&\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"XorEquals\",\n  pattern: \"^=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Xor\",\n  pattern: \"^\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"NotEquals\",\n  pattern: \"!=\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"OrOr\",\n  pattern: \"||\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"OrEquals\",\n  pattern: \"|=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Or\",\n  pattern: \"|\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"MultiplyEquals\",\n  pattern: \"*=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Star\",\n  pattern: \"*\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"DivideEquals\",\n  pattern: \"/=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Divide\",\n  pattern: \"/\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"ModuloEquals\",\n  pattern: \"%=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Modulo\",\n  pattern: \"%\",\n  categories: [BinaryOperator]\n});\n\n// must be defined after \"!=\"\ncreateToken({\n  name: \"Not\",\n  pattern: \"!\",\n  categories: [UnaryPrefixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\n\n// Identifier must appear AFTER all the keywords to avoid ambiguities.\n// See: https://github.com/SAP/chevrotain/blob/master/examples/lexer/keywords_vs_identifiers/keywords_vs_identifiers.js\nallTokens.push(Identifier);\ntokenDictionary[\"Identifier\"] = Identifier;\nfunction sortDescLength(arr) {\n  // sort is not stable, but that will not affect the lexing results.\n  return arr.sort((a, b) => {\n    return b.length - a.length;\n  });\n}\nmodule.exports = {\n  allTokens,\n  tokens: tokenDictionary\n};","map":{"version":3,"names":["createToken","createTokenOrg","Lexer","require","camelCase","chars","fragments","e","Error","inlineFragments","def","inlinedDef","Object","keys","forEach","prevFragmentName","prevFragmentDef","templateRegExp","RegExp","replace","FRAGMENT","name","MAKE_PATTERN","flags","matchJavaIdentifier","text","startOffset","endOffset","charCode","codePointAt","firstIdentChar","has","restIdentChar","matchedString","substring","Identifier","pattern","exec","line_breaks","start_chars_hint","Array","from","x","String","fromCharCode","allTokens","tokenDictionary","options","label","newTokenType","push","createKeywordLikeToken","longer_alt","RestrictedKeyword","NA","Keyword","AssignmentOperator","BinaryOperator","UnaryPrefixOperator","UnaryPrefixOperatorNotPlusMinus","UnarySuffixOperator","Separators","group","SKIPPED","restrictedKeywords","sortDescLength","word","toUpperCase","substr","categories","keywords","isPair","isArray","actualName","actualPattern","arr","sort","a","b","length","module","exports","tokens"],"sources":["/Users/duyenpnc/Desktop/tool-tu-lam/your-app-name/node_modules/java-parser/src/tokens.js"],"sourcesContent":["\"use strict\";\nconst { createToken: createTokenOrg, Lexer } = require(\"chevrotain\");\nconst camelCase = require(\"lodash/camelCase\");\n\nlet chars;\n// A little mini DSL for easier lexer definition.\nconst fragments = {};\ntry {\n  chars = require(\"./unicodesets\");\n} catch (e) {\n  throw Error(\n    \"unicodesets.js file could not be found. Did you try to run the command: yarn run build ?\"\n  );\n}\n\nfunction inlineFragments(def) {\n  let inlinedDef = def;\n  Object.keys(fragments).forEach(prevFragmentName => {\n    const prevFragmentDef = fragments[prevFragmentName];\n    const templateRegExp = new RegExp(`{{${prevFragmentName}}}`, \"g\");\n    inlinedDef = inlinedDef.replace(templateRegExp, prevFragmentDef);\n  });\n  return inlinedDef;\n}\n\nfunction FRAGMENT(name, def) {\n  fragments[name] = inlineFragments(def);\n}\n\nfunction MAKE_PATTERN(def, flags) {\n  const inlinedDef = inlineFragments(def);\n  return new RegExp(inlinedDef, flags);\n}\n\n// The order of fragments definitions is important\nFRAGMENT(\"Digits\", \"[0-9]([0-9_]*[0-9])?\");\nFRAGMENT(\"ExponentPart\", \"[eE][+-]?{{Digits}}\");\nFRAGMENT(\"HexDigit\", \"[0-9a-fA-F]\");\nFRAGMENT(\"HexDigits\", \"{{HexDigit}}(({{HexDigit}}|'_')*{{HexDigit}})?\");\nFRAGMENT(\"FloatTypeSuffix\", \"[fFdD]\");\nFRAGMENT(\"LineTerminator\", \"(\\\\x0A|(\\\\x0D(\\\\x0A)?))\");\nFRAGMENT(\"UnicodeMarker\", \"uu*\");\nFRAGMENT(\"UnicodeEscape\", \"\\\\\\\\{{UnicodeMarker}}{{HexDigit}}{4}\");\nFRAGMENT(\"RawInputCharacter\", \"\\\\\\\\{{UnicodeMarker}}[0-9a-fA-F]{4}\");\nFRAGMENT(\"UnicodeInputCharacter\", \"({{UnicodeEscape}}|{{RawInputCharacter}})\");\nFRAGMENT(\"OctalDigit\", \"[0-7]\");\nFRAGMENT(\"ZeroToThree\", \"[0-3]\");\nFRAGMENT(\n  \"OctalEscape\",\n  \"\\\\\\\\({{OctalDigit}}|{{ZeroToThree}}?{{OctalDigit}}{2})\"\n);\nFRAGMENT(\"EscapeSequence\", \"\\\\\\\\[bstnfr\\\"'\\\\\\\\]|{{OctalEscape}}\");\n// Not using InputCharacter terminology there because CR and LF are already captured in EscapeSequence\nFRAGMENT(\n  \"StringCharacter\",\n  \"(?:(?:{{EscapeSequence}})|{{UnicodeInputCharacter}})\"\n);\n\nfunction matchJavaIdentifier(text, startOffset) {\n  let endOffset = startOffset;\n  let charCode = text.codePointAt(endOffset);\n\n  // We verifiy if the first character is from one of these categories\n  // Corresponds to the isJavaIdentifierStart function from Java\n  if (chars.firstIdentChar.has(charCode)) {\n    endOffset++;\n    // If we encounter a surrogate pair (something that is beyond 65535/FFFF)\n    // We skip another offset because a surrogate pair is of length 2.\n    if (charCode > 65535) {\n      endOffset++;\n    }\n    charCode = text.codePointAt(endOffset);\n  }\n\n  // We verify if the remaining characters is from one of these categories\n  // Corresponds to the isJavaIdentifierPart function from Java\n  while (chars.restIdentChar.has(charCode)) {\n    endOffset++;\n    // See above.\n    if (charCode > 65535) {\n      endOffset++;\n    }\n    charCode = text.codePointAt(endOffset);\n  }\n\n  // No match, must return null to conform with the RegExp.prototype.exec signature\n  if (endOffset === startOffset) {\n    return null;\n  }\n  const matchedString = text.substring(startOffset, endOffset);\n  // according to the RegExp.prototype.exec API the first item in the returned array must be the whole matched string.\n  return [matchedString];\n}\n\nconst Identifier = createTokenOrg({\n  name: \"Identifier\",\n  pattern: { exec: matchJavaIdentifier },\n  line_breaks: false,\n  start_chars_hint: Array.from(chars.firstIdentChar, x =>\n    String.fromCharCode(x)\n  )\n});\n\nconst allTokens = [];\nconst tokenDictionary = {};\n\nfunction createToken(options) {\n  // TODO create a test to check all the tokenbs have a label defined\n  if (!options.label) {\n    // simple token (e.g operator)\n    if (typeof options.pattern === \"string\") {\n      options.label = `'${options.pattern}'`;\n    }\n    // Complex token (e.g literal)\n    else if (options.pattern instanceof RegExp) {\n      options.label = `'${options.name}'`;\n    }\n  }\n\n  const newTokenType = createTokenOrg(options);\n  allTokens.push(newTokenType);\n  tokenDictionary[options.name] = newTokenType;\n  return newTokenType;\n}\n\nfunction createKeywordLikeToken(options) {\n  // A keyword 'like' token uses the \"longer_alt\" config option\n  // to resolve ambiguities, see: http://sap.github.io/chevrotain/docs/features/token_alternative_matches.html\n  options.longer_alt = Identifier;\n  return createToken(options);\n}\n\n// Token Categories\n// Used a Token Category to mark all restricted keywords.\n// This could be used in syntax highlights implementation.\nconst RestrictedKeyword = createToken({\n  name: \"RestrictedKeyword\",\n  pattern: Lexer.NA\n});\n\n// Used a Token Category to mark all keywords.\n// This could be used in syntax highlights implementation.\nconst Keyword = createToken({\n  name: \"Keyword\",\n  pattern: Lexer.NA\n});\n\nconst AssignmentOperator = createToken({\n  name: \"AssignmentOperator\",\n  pattern: Lexer.NA\n});\n\nconst BinaryOperator = createToken({\n  name: \"BinaryOperator\",\n  pattern: Lexer.NA\n});\n\nconst UnaryPrefixOperator = createToken({\n  name: \"UnaryPrefixOperator\",\n  pattern: Lexer.NA\n});\nconst UnaryPrefixOperatorNotPlusMinus = createToken({\n  name: \"UnaryPrefixOperatorNotPlusMinus\",\n  pattern: Lexer.NA\n});\n\nconst UnarySuffixOperator = createToken({\n  name: \"UnarySuffixOperator\",\n  pattern: Lexer.NA\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.11\nconst Separators = createToken({\n  name: \"Separators\",\n  pattern: Lexer.NA\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.6\n// Note [\\\\x09\\\\x20\\\\x0C] is equivalent to [\\\\t\\\\x20\\\\f] and that \\\\x20 represents\n// space character\ncreateToken({\n  name: \"WhiteSpace\",\n  pattern: MAKE_PATTERN(\"[\\\\x09\\\\x20\\\\x0C]|{{LineTerminator}}\"),\n  group: Lexer.SKIPPED\n});\ncreateToken({\n  name: \"LineComment\",\n  pattern: /\\/\\/[^\\n\\r]*/,\n  group: \"comments\"\n});\ncreateToken({\n  name: \"TraditionalComment\",\n  pattern: /\\/\\*([^*]|\\*(?!\\/))*\\*\\//,\n  group: \"comments\"\n});\ncreateToken({ name: \"BinaryLiteral\", pattern: /0[bB][01]([01_]*[01])?[lL]?/ });\ncreateToken({\n  name: \"FloatLiteral\",\n  pattern: MAKE_PATTERN(\n    \"{{Digits}}\\\\.({{Digits}})?({{ExponentPart}})?({{FloatTypeSuffix}})?|\" +\n      \"\\\\.{{Digits}}({{ExponentPart}})?({{FloatTypeSuffix}})?|\" +\n      \"{{Digits}}{{ExponentPart}}({{FloatTypeSuffix}})?|\" +\n      \"{{Digits}}({{ExponentPart}})?{{FloatTypeSuffix}}\"\n  )\n});\ncreateToken({ name: \"OctalLiteral\", pattern: /0_*[0-7]([0-7_]*[0-7])?[lL]?/ });\ncreateToken({\n  name: \"HexFloatLiteral\",\n  pattern: MAKE_PATTERN(\n    \"0[xX]({{HexDigits}}\\\\.?|({{HexDigits}})?\\\\.{{HexDigits}})[pP][+-]?{{Digits}}[fFdD]?\"\n  )\n});\ncreateToken({\n  name: \"HexLiteral\",\n  pattern: /0[xX][0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?[lL]?/\n});\ncreateToken({\n  name: \"DecimalLiteral\",\n  pattern: MAKE_PATTERN(\"(0|[1-9](_+{{Digits}}|({{Digits}})?))[lL]?\")\n});\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.10.4\ncreateToken({\n  name: \"CharLiteral\",\n  // Not using SingleCharacter Terminology because ' and \\ are captured in EscapeSequence\n  pattern: MAKE_PATTERN(\n    \"'(?:[^\\\\\\\\']|(?:(?:{{EscapeSequence}})|{{UnicodeInputCharacter}}))'\"\n  )\n});\n\ncreateToken({\n  name: \"TextBlock\",\n  pattern: /\"\"\"\\s*\\n(\\\\\"|\\s|.)*?\"\"\"/\n});\n\ncreateToken({\n  name: \"StringLiteral\",\n  pattern: MAKE_PATTERN('\"(?:[^\\\\\\\\\"]|{{StringCharacter}})*\"')\n});\n\n// https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.9\n// TODO: how to handle the special rule (see spec above) for \"requires\" and \"transitive\"\nconst restrictedKeywords = [\n  \"open\",\n  \"module\",\n  \"requires\",\n  \"transitive\",\n  \"exports\",\n  \"opens\",\n  \"to\",\n  \"uses\",\n  \"provides\",\n  \"when\",\n  \"with\",\n  \"sealed\",\n  \"non-sealed\",\n  \"permits\"\n];\n\n// By sorting the keywords in descending order we avoid ambiguities\n// of common prefixes.\nsortDescLength(restrictedKeywords).forEach(word => {\n  createKeywordLikeToken({\n    name: word[0].toUpperCase() + camelCase(word.substr(1)),\n    pattern: word,\n    // restricted keywords can also be used as an Identifiers according to the spec.\n    // TODO: inspect this causes no ambiguities\n    categories: [Identifier, RestrictedKeyword]\n  });\n});\n\n// https://docs.oracle.com/javase/specs/jls/se11/html/jls-3.html#jls-3.9\nconst keywords = [\n  \"abstract\",\n  \"continue\",\n  \"for\",\n  \"new\",\n  \"switch\",\n  \"assert\",\n  \"default\",\n  \"if\",\n  \"package\",\n  \"synchronized\",\n  \"boolean\",\n  \"do\",\n  \"goto\",\n  \"private\",\n  \"this\",\n  \"break\",\n  \"double\",\n  \"implements\",\n  \"protected\",\n  \"throw\",\n  \"byte\",\n  \"else\",\n  \"import\",\n  \"public\",\n  \"throws\",\n  \"case\",\n  \"enum\",\n  // \"instanceof\", // special handling for \"instanceof\" operator below\n  \"return\",\n  \"transient\",\n  \"catch\",\n  \"extends\",\n  \"int\",\n  \"short\",\n  \"try\",\n  \"char\",\n  \"final\",\n  \"interface\",\n  \"static\",\n  \"void\",\n  \"class\",\n  \"finally\",\n  \"long\",\n  \"strictfp\",\n  \"volatile\",\n  \"const\",\n  \"float\",\n  \"native\",\n  \"super\",\n  \"while\",\n  [\"_\", \"underscore\"]\n];\n\nsortDescLength(keywords).forEach(word => {\n  // For handling symbols keywords (underscore)\n  const isPair = Array.isArray(word);\n  const actualName = isPair ? word[1] : word;\n  const actualPattern = isPair ? word[0] : word;\n\n  const options = {\n    name: actualName[0].toUpperCase() + actualName.substr(1),\n    pattern: actualPattern,\n    categories: Keyword\n  };\n\n  if (isPair) {\n    options.label = `'${actualName}'`;\n  }\n  createKeywordLikeToken(options);\n});\n\ncreateKeywordLikeToken({\n  name: \"Instanceof\",\n  pattern: \"instanceof\",\n  categories: [Keyword, BinaryOperator]\n});\n\ncreateKeywordLikeToken({\n  name: \"Var\",\n  pattern: \"var\",\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.9\n  // \"var is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration\"\n  categories: Identifier\n});\ncreateKeywordLikeToken({\n  name: \"Yield\",\n  pattern: \"yield\",\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.9\n  // \"yield is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration\"\n  categories: Identifier\n});\ncreateKeywordLikeToken({\n  name: \"Record\",\n  pattern: \"record\",\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.html#jls-3.9\n  // \"record is not a keyword, but rather an identifier with special meaning as the type of a local variable declaration\"\n  categories: Identifier\n});\ncreateKeywordLikeToken({ name: \"True\", pattern: \"true\" });\ncreateKeywordLikeToken({ name: \"False\", pattern: \"false\" });\ncreateKeywordLikeToken({ name: \"Null\", pattern: \"null\" });\n\n// punctuation and symbols\ncreateToken({ name: \"At\", pattern: \"@\", categories: [Separators] });\ncreateToken({ name: \"Arrow\", pattern: \"->\" });\ncreateToken({ name: \"DotDotDot\", pattern: \"...\", categories: [Separators] });\ncreateToken({ name: \"Dot\", pattern: \".\", categories: [Separators] });\ncreateToken({ name: \"Comma\", pattern: \",\", categories: [Separators] });\ncreateToken({ name: \"Semicolon\", pattern: \";\", categories: [Separators] });\ncreateToken({ name: \"ColonColon\", pattern: \"::\", categories: [Separators] });\ncreateToken({ name: \"Colon\", pattern: \":\" });\ncreateToken({ name: \"QuestionMark\", pattern: \"?\" });\ncreateToken({ name: \"LBrace\", pattern: \"(\", categories: [Separators] });\ncreateToken({ name: \"RBrace\", pattern: \")\", categories: [Separators] });\ncreateToken({ name: \"LCurly\", pattern: \"{\", categories: [Separators] });\ncreateToken({ name: \"RCurly\", pattern: \"}\", categories: [Separators] });\ncreateToken({ name: \"LSquare\", pattern: \"[\", categories: [Separators] });\ncreateToken({ name: \"RSquare\", pattern: \"]\", categories: [Separators] });\n\n// prefix and suffix operators\n// must be defined before \"-\"\ncreateToken({\n  name: \"MinusMinus\",\n  pattern: \"--\",\n  categories: [\n    UnaryPrefixOperator,\n    UnarySuffixOperator,\n    UnaryPrefixOperatorNotPlusMinus\n  ]\n});\n// must be defined before \"+\"\ncreateToken({\n  name: \"PlusPlus\",\n  pattern: \"++\",\n  categories: [\n    UnaryPrefixOperator,\n    UnarySuffixOperator,\n    UnaryPrefixOperatorNotPlusMinus\n  ]\n});\ncreateToken({\n  name: \"Complement\",\n  pattern: \"~\",\n  categories: [UnaryPrefixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\n\ncreateToken({\n  name: \"LessEquals\",\n  pattern: \"<=\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"LessLessEquals\",\n  pattern: \"<<=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Less\", pattern: \"<\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"GreaterEquals\",\n  pattern: \">=\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"GreaterGreaterEquals\",\n  pattern: \">>=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"GreaterGreaterGreaterEquals\",\n  pattern: \">>>=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Greater\", pattern: \">\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"EqualsEquals\",\n  pattern: \"==\",\n  categories: [BinaryOperator]\n});\ncreateToken({\n  name: \"Equals\",\n  pattern: \"=\",\n  categories: [BinaryOperator, AssignmentOperator]\n});\ncreateToken({\n  name: \"MinusEquals\",\n  pattern: \"-=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Minus\",\n  pattern: \"-\",\n  categories: [BinaryOperator, UnaryPrefixOperator]\n});\ncreateToken({\n  name: \"PlusEquals\",\n  pattern: \"+=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({\n  name: \"Plus\",\n  pattern: \"+\",\n  categories: [BinaryOperator, UnaryPrefixOperator]\n});\ncreateToken({ name: \"AndAnd\", pattern: \"&&\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"AndEquals\",\n  pattern: \"&=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"And\", pattern: \"&\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"XorEquals\",\n  pattern: \"^=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Xor\", pattern: \"^\", categories: [BinaryOperator] });\ncreateToken({ name: \"NotEquals\", pattern: \"!=\", categories: [BinaryOperator] });\ncreateToken({ name: \"OrOr\", pattern: \"||\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"OrEquals\",\n  pattern: \"|=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Or\", pattern: \"|\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"MultiplyEquals\",\n  pattern: \"*=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Star\", pattern: \"*\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"DivideEquals\",\n  pattern: \"/=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Divide\", pattern: \"/\", categories: [BinaryOperator] });\ncreateToken({\n  name: \"ModuloEquals\",\n  pattern: \"%=\",\n  categories: [AssignmentOperator]\n});\ncreateToken({ name: \"Modulo\", pattern: \"%\", categories: [BinaryOperator] });\n\n// must be defined after \"!=\"\ncreateToken({\n  name: \"Not\",\n  pattern: \"!\",\n  categories: [UnaryPrefixOperator, UnaryPrefixOperatorNotPlusMinus]\n});\n\n// Identifier must appear AFTER all the keywords to avoid ambiguities.\n// See: https://github.com/SAP/chevrotain/blob/master/examples/lexer/keywords_vs_identifiers/keywords_vs_identifiers.js\nallTokens.push(Identifier);\ntokenDictionary[\"Identifier\"] = Identifier;\n\nfunction sortDescLength(arr) {\n  // sort is not stable, but that will not affect the lexing results.\n  return arr.sort((a, b) => {\n    return b.length - a.length;\n  });\n}\nmodule.exports = {\n  allTokens,\n  tokens: tokenDictionary\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}