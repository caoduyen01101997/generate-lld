{"ast":null,"code":"\"use strict\";\n\nconst {\n  tokenMatcher\n} = require(\"chevrotain\");\nfunction defineRules($, t) {\n  $.RULE(\"expression\", () => {\n    $.OR([{\n      GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n      ALT: () => $.SUBRULE($.lambdaExpression)\n    }, {\n      ALT: () => $.SUBRULE($.ternaryExpression)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-LambdaExpression\n  $.RULE(\"lambdaExpression\", () => {\n    $.SUBRULE($.lambdaParameters);\n    $.CONSUME(t.Arrow);\n    $.SUBRULE($.lambdaBody);\n  });\n  $.RULE(\"lambdaParameters\", () => {\n    $.OR([{\n      ALT: () => $.SUBRULE($.lambdaParametersWithBraces)\n    }, {\n      ALT: () => $.CONSUME(t.Identifier)\n    }]);\n  });\n  $.RULE(\"lambdaParametersWithBraces\", () => {\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.lambdaParameterList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n  $.RULE(\"lambdaParameterList\", () => {\n    $.OR([{\n      GATE: () => {\n        const nextTokType = this.LA(1).tokenType;\n        const nextNextTokType = this.LA(2).tokenType;\n        return tokenMatcher(nextTokType, t.Identifier) && (tokenMatcher(nextNextTokType, t.RBrace) || tokenMatcher(nextNextTokType, t.Comma));\n      },\n      ALT: () => $.SUBRULE($.inferredLambdaParameterList)\n    }, {\n      ALT: () => $.SUBRULE($.explicitLambdaParameterList)\n    }]);\n  });\n  $.RULE(\"inferredLambdaParameterList\", () => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.CONSUME2(t.Identifier);\n    });\n  });\n  $.RULE(\"explicitLambdaParameterList\", () => {\n    $.SUBRULE($.lambdaParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.lambdaParameter);\n    });\n  });\n  $.RULE(\"lambdaParameter\", () => {\n    // TODO: performance, investigate the performance boost that could\n    //       be gained by refactoring out the backtracking.\n    $.OR([{\n      GATE: $.BACKTRACK($.regularLambdaParameter),\n      ALT: () => $.SUBRULE($.regularLambdaParameter)\n    }, {\n      ALT: () => $.SUBRULE($.variableArityParameter)\n    }]);\n  });\n  $.RULE(\"regularLambdaParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.lambdaParameterType);\n    $.SUBRULE($.variableDeclaratorId);\n  });\n  $.RULE(\"lambdaParameterType\", () => {\n    $.OR({\n      DEF: [{\n        ALT: () => $.SUBRULE($.unannType)\n      }, {\n        ALT: () => $.CONSUME(t.Var)\n      }],\n      IGNORE_AMBIGUITIES: true\n    });\n  });\n  $.RULE(\"lambdaBody\", () => {\n    $.OR([{\n      ALT: () => $.SUBRULE($.expression)\n    }, {\n      ALT: () => $.SUBRULE($.block)\n    }]);\n  });\n  $.RULE(\"ternaryExpression\", () => {\n    $.SUBRULE($.binaryExpression);\n    $.OPTION(() => {\n      $.CONSUME(t.QuestionMark);\n      $.SUBRULE($.expression);\n      $.CONSUME(t.Colon);\n      // TODO: in the grammar this is limited to \"lambdaExpression: or \"conditionalExpression\"\n      $.SUBRULE2($.expression);\n    });\n  });\n  $.RULE(\"binaryExpression\", () => {\n    $.SUBRULE($.unaryExpression);\n    $.MANY(() => {\n      $.OR({\n        DEF: [{\n          ALT: () => {\n            $.CONSUME(t.Instanceof);\n            $.OR1([{\n              GATE: () => this.BACKTRACK_LOOKAHEAD($.pattern),\n              ALT: () => $.SUBRULE($.pattern)\n            }, {\n              ALT: () => $.SUBRULE($.referenceType)\n            }]);\n          }\n        }, {\n          ALT: () => {\n            $.CONSUME(t.AssignmentOperator);\n            $.SUBRULE2($.expression);\n          }\n        },\n        // This is an example of why Java does not have a well designed grammar\n        // See: https://manas.tech/blog/2008/10/12/why-java-generics-dont-have-problems-with-right-shift-operator.html\n        // TODO: ensure the LT/GT sequences have no whitespace between each other.\n        {\n          // TODO: this is a bug in Chevrotain lookahead calculation. the \"BinaryOperator\" token can match \"Less\" or \"Greater\"\n          //   as well, but because it is a **token Category** Chevrotain does not understand it need to looks two tokens ahead.\n          GATE: () => tokenMatcher($.LA(2).tokenType, t.Less) || tokenMatcher($.LA(2).tokenType, t.Greater),\n          ALT: () => {\n            $.OR2([{\n              GATE: () => $.LA(1).startOffset + 1 === $.LA(2).startOffset,\n              ALT: () => {\n                $.CONSUME(t.Less);\n                $.CONSUME2(t.Less);\n              }\n            }, {\n              GATE: () => $.LA(1).startOffset + 1 === $.LA(2).startOffset,\n              ALT: () => {\n                $.CONSUME(t.Greater);\n                $.CONSUME2(t.Greater);\n                $.OPTION({\n                  GATE: () => $.LA(0).startOffset + 1 === $.LA(1).startOffset,\n                  DEF: () => $.CONSUME3(t.Greater)\n                });\n              }\n            }]);\n            $.SUBRULE2($.unaryExpression);\n          }\n        }, {\n          ALT: () => {\n            $.CONSUME(t.BinaryOperator);\n            $.SUBRULE3($.unaryExpression);\n          }\n        }],\n        IGNORE_AMBIGUITIES: true // the ambiguity between 1 and 4 options is resolved by the order (instanceOf is first)\n      });\n    });\n  });\n\n  $.RULE(\"unaryExpression\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperator);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  });\n  $.RULE(\"unaryExpressionNotPlusMinus\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperatorNotPlusMinus);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  });\n  $.RULE(\"primary\", () => {\n    $.SUBRULE($.primaryPrefix);\n    $.MANY(() => {\n      $.SUBRULE($.primarySuffix);\n    });\n  });\n  $.RULE(\"primaryPrefix\", () => {\n    let isCastExpression = false;\n    if (tokenMatcher($.LA(1).tokenType, t.LBrace)) {\n      isCastExpression = this.BACKTRACK_LOOKAHEAD($.isCastExpression);\n    }\n    $.OR([{\n      ALT: () => $.SUBRULE($.literal)\n    }, {\n      ALT: () => $.CONSUME(t.This)\n    }, {\n      ALT: () => $.CONSUME(t.Void)\n    }, {\n      ALT: () => $.SUBRULE($.unannPrimitiveTypeWithOptionalDimsSuffix)\n    }, {\n      ALT: () => $.SUBRULE($.fqnOrRefType)\n    }, {\n      GATE: () => isCastExpression,\n      ALT: () => $.SUBRULE($.castExpression)\n    }, {\n      ALT: () => $.SUBRULE($.parenthesisExpression)\n    }, {\n      ALT: () => $.SUBRULE($.newExpression)\n    }, {\n      ALT: () => $.SUBRULE($.switchStatement)\n    }]);\n  });\n  $.RULE(\"primarySuffix\", () => {\n    $.OR({\n      DEF: [{\n        ALT: () => {\n          $.CONSUME(t.Dot);\n          $.OR2([{\n            ALT: () => $.CONSUME(t.This)\n          }, {\n            ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n          }, {\n            ALT: () => {\n              $.OPTION(() => {\n                $.SUBRULE($.typeArguments);\n              });\n              $.CONSUME(t.Identifier);\n            }\n          }]);\n        }\n      }, {\n        ALT: () => $.SUBRULE($.methodInvocationSuffix)\n      }, {\n        ALT: () => $.SUBRULE($.classLiteralSuffix)\n      }, {\n        ALT: () => $.SUBRULE($.arrayAccessSuffix)\n      }, {\n        ALT: () => $.SUBRULE($.methodReferenceSuffix)\n      }],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n\n  // See https://github.com/jhipster/prettier-java/pull/154 to understand\n  // why fqnOrRefTypePart is split in two rules (First and Rest)\n  $.RULE(\"fqnOrRefType\", () => {\n    $.SUBRULE($.fqnOrRefTypePartFirst);\n    $.MANY2({\n      // \".class\" is a classLiteralSuffix\n      GATE: () =>\n      // avoids ambiguity with \".this\" and \".new\" which are parsed as a primary suffix.\n      tokenMatcher(this.LA(2).tokenType, t.Class) === false && tokenMatcher(this.LA(2).tokenType, t.This) === false && tokenMatcher(this.LA(2).tokenType, t.New) === false,\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.SUBRULE2($.fqnOrRefTypePartRest);\n      }\n    });\n\n    // in case of an arrayType\n    $.OPTION({\n      // it is not enough to check only the opening \"[\", we must avoid conflict with\n      // arrayAccessSuffix\n      GATE: () => tokenMatcher($.LA(1).tokenType, t.At) || tokenMatcher($.LA(2).tokenType, t.RSquare),\n      DEF: () => {\n        $.SUBRULE($.dims);\n      }\n    });\n  });\n\n  // TODO: validation:\n  //       1. \"annotation\" cannot be mixed with \"methodTypeArguments\" or \"Super\".\n  //       2. \"methodTypeArguments\" cannot be mixed with \"classTypeArguments\" or \"annotation\".\n  //       3. \"Super\" cannot be mixed with \"classTypeArguments\" or \"annotation\".\n  //       4. At most one \"Super\" may be used.\n  //       5. \"Super\" may be last or one before last (last may also be first if there is only a single part).\n  $.RULE(\"fqnOrRefTypePartRest\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.OPTION(() => $.SUBRULE2($.typeArguments));\n    $.SUBRULE($.fqnOrRefTypePartCommon);\n  });\n  $.RULE(\"fqnOrRefTypePartCommon\", () => {\n    $.OR([{\n      ALT: () => $.CONSUME(t.Identifier)\n    }, {\n      ALT: () => $.CONSUME(t.Super)\n    }]);\n    let isRefTypeInMethodRef = false;\n    // Performance optimization, only perform this backtracking when a '<' is found\n    // TODO: performance optimization evaluation: avoid doing this backtracking for every \"<\" encountered.\n    //       we could do it once (using global state) per \"fqnOrRefType\"\n    // We could do it only once for\n    if (tokenMatcher($.LA(1).tokenType, t.Less)) {\n      isRefTypeInMethodRef = this.BACKTRACK_LOOKAHEAD($.isRefTypeInMethodRef);\n    }\n    $.OPTION2({\n      // unrestricted typeArguments here would create an ambiguity with \"LessThan\" operator\n      // e.g: \"var x = a < b;\"\n      // The \"<\" would be parsed as the beginning of a \"typeArguments\"\n      // and we will get an error: \"expecting '>' but found: ';'\"\n      GATE: () => isRefTypeInMethodRef,\n      DEF: () => {\n        $.SUBRULE3($.typeArguments);\n      }\n    });\n  });\n  $.RULE(\"fqnOrRefTypePartFirst\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.SUBRULE($.fqnOrRefTypePartCommon);\n  });\n  $.RULE(\"parenthesisExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n  });\n  $.RULE(\"castExpression\", () => {\n    $.OR([{\n      // TODO: performance: can avoid backtracking again here, parent rule could have this information\n      //       when it checks isCastExpression (refactor needed)\n      GATE: () => this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression),\n      ALT: () => $.SUBRULE($.primitiveCastExpression)\n    }, {\n      ALT: () => $.SUBRULE($.referenceTypeCastExpression)\n    }]);\n  });\n  $.RULE(\"primitiveCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.unaryExpression);\n  });\n  $.RULE(\"referenceTypeCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    $.OR([{\n      GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n      ALT: () => $.SUBRULE($.lambdaExpression)\n    }, {\n      ALT: () => $.SUBRULE($.unaryExpressionNotPlusMinus)\n    }]);\n  });\n  const newExpressionTypes = {\n    arrayCreationExpression: 1,\n    unqualifiedClassInstanceCreationExpression: 2\n  };\n  $.RULE(\"newExpression\", () => {\n    const type = this.BACKTRACK_LOOKAHEAD($.identifyNewExpressionType);\n    $.OR([{\n      GATE: () => type === newExpressionTypes.arrayCreationExpression,\n      ALT: () => $.SUBRULE($.arrayCreationExpression)\n    }, {\n      GATE: () => type === newExpressionTypes.unqualifiedClassInstanceCreationExpression,\n      ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-UnqualifiedClassInstanceCreationExpression\n  $.RULE(\"unqualifiedClassInstanceCreationExpression\", () => {\n    $.CONSUME(t.New);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.OPTION3(() => {\n      $.SUBRULE($.classBody);\n    });\n  });\n  $.RULE(\"classOrInterfaceTypeToInstantiate\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      $.CONSUME2(t.Identifier);\n    });\n    $.OPTION(() => {\n      $.SUBRULE($.typeArgumentsOrDiamond);\n    });\n  });\n  $.RULE(\"typeArgumentsOrDiamond\", () => {\n    $.OR({\n      DEF: [{\n        ALT: () => $.SUBRULE($.diamond)\n      }, {\n        ALT: () => $.SUBRULE($.typeArguments)\n      }],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n  $.RULE(\"diamond\", () => {\n    $.CONSUME(t.Less);\n    $.CONSUME(t.Greater);\n  });\n  $.RULE(\"methodInvocationSuffix\", () => {\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n  $.RULE(\"argumentList\", () => {\n    $.SUBRULE($.expression);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.expression);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-15.10.1\n  $.RULE(\"arrayCreationExpression\", () => {\n    $.CONSUME(t.New);\n    $.OR([{\n      GATE: $.BACKTRACK($.primitiveType),\n      ALT: () => $.SUBRULE($.primitiveType)\n    }, {\n      ALT: () => $.SUBRULE($.classOrInterfaceType)\n    }]);\n    $.OR2([{\n      GATE: $.BACKTRACK($.arrayCreationDefaultInitSuffix),\n      ALT: () => $.SUBRULE($.arrayCreationDefaultInitSuffix)\n    }, {\n      ALT: () => $.SUBRULE($.arrayCreationExplicitInitSuffix)\n    }]);\n  });\n  $.RULE(\"arrayCreationDefaultInitSuffix\", () => {\n    $.SUBRULE($.dimExprs);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n  });\n  $.RULE(\"arrayCreationExplicitInitSuffix\", () => {\n    $.SUBRULE($.dims);\n    $.SUBRULE($.arrayInitializer);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-DimExprs\n  $.RULE(\"dimExprs\", () => {\n    $.SUBRULE($.dimExpr);\n    $.MANY({\n      // The GATE is to distinguish DimExpr from Dims :\n      // the only difference between these two is the presence of an expression in the DimExpr\n      // Example: If the GATE is not present double[3][] won't be parsed as the parser will try to parse \"[]\"\n      // as a dimExpr instead of a dims\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RSquare) === false,\n      DEF: () => $.SUBRULE2($.dimExpr)\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-DimExpr\n  $.RULE(\"dimExpr\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  });\n  $.RULE(\"classLiteralSuffix\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.LSquare);\n      $.CONSUME(t.RSquare);\n    });\n    $.CONSUME(t.Dot);\n    $.CONSUME(t.Class);\n  });\n  $.RULE(\"arrayAccessSuffix\", () => {\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  });\n  $.RULE(\"methodReferenceSuffix\", () => {\n    $.CONSUME(t.ColonColon);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.OR([{\n      ALT: () => $.CONSUME(t.Identifier)\n    },\n    // TODO: a constructor method reference (\"new\") can only be used\n    //   in specific contexts, but perhaps this verification is best left\n    //   for a semantic analysis phase\n    {\n      ALT: () => $.CONSUME(t.New)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-Pattern\n  $.RULE(\"pattern\", () => {\n    $.OR([{\n      GATE: () => this.BACKTRACK_LOOKAHEAD($.typePattern),\n      ALT: () => $.SUBRULE($.typePattern)\n    }, {\n      ALT: () => $.SUBRULE($.recordPattern)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-TypePattern\n  $.RULE(\"typePattern\", () => {\n    $.SUBRULE($.localVariableDeclaration);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-RecordPattern\n  $.RULE(\"recordPattern\", () => {\n    $.SUBRULE($.referenceType);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.patternList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-PatternList\n  $.RULE(\"patternList\", () => {\n    $.SUBRULE($.pattern);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.pattern);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-Guard\n  $.RULE(\"guard\", () => {\n    $.CONSUME(t.When);\n    $.SUBRULE($.expression);\n  });\n\n  // backtracking lookahead logic\n  $.RULE(\"identifyNewExpressionType\", () => {\n    $.CONSUME(t.New);\n    const firstTokenAfterNew = this.LA(1).tokenType;\n\n    // not an array initialization due to the prefix \"TypeArguments\"\n    if (tokenMatcher(firstTokenAfterNew, t.Less)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n    try {\n      $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    } catch (e) {\n      // if it is not a \"classOrInterfaceTypeToInstantiate\" then\n      // (assuming a valid input) we are looking at an \"arrayCreationExpression\"\n      return newExpressionTypes.arrayCreationExpression;\n    }\n    const firstTokenAfterClassType = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokenAfterClassType, t.LBrace)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n\n    // The LBrace above is mandatory in \"classInstanceCreation...\" so\n    // it must be an \"arrayCreationExp\" (if the input is valid)\n    // TODO: upgrade the logic to return \"unknown\" type if at this\n    //       point it does not match \"arrayCreation\" either.\n    //   - This will provide a better error message to the user\n    //     in case of invalid inputs\n    return newExpressionTypes.arrayCreationExpression;\n  });\n\n  // Optimized backtracking, only scan ahead until the arrow(\"->\").\n  $.RULE(\"isLambdaExpression\", () => {\n    // TODO: this check of next two tokens is probably redundant as the normal lookahead should take care of this.\n    const firstTokenType = this.LA(1).tokenType;\n    const secondTokenType = this.LA(2).tokenType;\n    // no parent lambda \"x -> x * 2\"\n    if (tokenMatcher(firstTokenType, t.Identifier) && tokenMatcher(secondTokenType, t.Arrow)) {\n      return true;\n    }\n    // Performance optimizations, fail fast if it is not a LBrace.\n    else if (tokenMatcher(firstTokenType, t.LBrace)) {\n      $.SUBRULE($.lambdaParametersWithBraces);\n      const followedByArrow = tokenMatcher(this.LA(1).tokenType, t.Arrow);\n      return followedByArrow;\n    }\n    return false;\n  });\n  $.RULE(\"isCastExpression\", () => {\n    if (this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression)) {\n      return true;\n    }\n    return this.BACKTRACK_LOOKAHEAD($.isReferenceTypeCastExpression);\n  });\n  $.RULE(\"isPrimitiveCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    // No dims so this is not a reference Type\n    $.CONSUME(t.RBrace);\n    return true;\n  });\n  $.RULE(\"isReferenceTypeCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    const firstTokTypeAfterRBrace = this.LA(1).tokenType;\n    return this.firstForUnaryExpressionNotPlusMinus.find(tokType => tokenMatcher(firstTokTypeAfterRBrace, tokType)) !== undefined;\n  });\n  $.RULE(\"isRefTypeInMethodRef\", () => {\n    let result = undefined;\n    $.SUBRULE($.typeArguments);\n\n    // arrayType\n    const hasDims = $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n    const firstTokTypeAfterTypeArgs = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokTypeAfterTypeArgs, t.ColonColon)) {\n      result = true;\n    }\n    // we must be at the end of a \"referenceType\" if \"dims\" were encountered\n    // So there is not point to check farther\n    else if (hasDims) {\n      result = false;\n    }\n\n    // in the middle of a \"classReferenceType\"\n    $.OPTION2(() => {\n      $.CONSUME(t.Dot);\n      $.SUBRULE($.classOrInterfaceType);\n    });\n    if (result !== undefined) {\n      return result;\n    }\n    const firstTokTypeAfterRefType = this.LA(1).tokenType;\n    return tokenMatcher(firstTokTypeAfterRefType, t.ColonColon);\n  });\n}\nfunction computeFirstForUnaryExpressionNotPlusMinus() {\n  const firstUnaryExpressionNotPlusMinus = this.computeContentAssist(\"unaryExpressionNotPlusMinus\", []);\n  const nextTokTypes = firstUnaryExpressionNotPlusMinus.map(x => x.nextTokenType);\n  // uniq\n  return nextTokTypes.filter((v, i, a) => a.indexOf(v) === i);\n}\nmodule.exports = {\n  defineRules,\n  computeFirstForUnaryExpressionNotPlusMinus\n};","map":{"version":3,"names":["tokenMatcher","require","defineRules","$","t","RULE","OR","GATE","BACKTRACK_LOOKAHEAD","isLambdaExpression","ALT","SUBRULE","lambdaExpression","ternaryExpression","lambdaParameters","CONSUME","Arrow","lambdaBody","lambdaParametersWithBraces","Identifier","LBrace","OPTION","lambdaParameterList","RBrace","nextTokType","LA","tokenType","nextNextTokType","Comma","inferredLambdaParameterList","explicitLambdaParameterList","MANY","CONSUME2","lambdaParameter","SUBRULE2","BACKTRACK","regularLambdaParameter","variableArityParameter","variableModifier","lambdaParameterType","variableDeclaratorId","DEF","unannType","Var","IGNORE_AMBIGUITIES","expression","block","binaryExpression","QuestionMark","Colon","unaryExpression","Instanceof","OR1","pattern","referenceType","AssignmentOperator","Less","Greater","OR2","startOffset","CONSUME3","BinaryOperator","SUBRULE3","UnaryPrefixOperator","primary","MANY2","UnarySuffixOperator","UnaryPrefixOperatorNotPlusMinus","primaryPrefix","primarySuffix","isCastExpression","literal","This","Void","unannPrimitiveTypeWithOptionalDimsSuffix","fqnOrRefType","castExpression","parenthesisExpression","newExpression","switchStatement","Dot","unqualifiedClassInstanceCreationExpression","typeArguments","methodInvocationSuffix","classLiteralSuffix","arrayAccessSuffix","methodReferenceSuffix","MAX_LOOKAHEAD","fqnOrRefTypePartFirst","Class","New","fqnOrRefTypePartRest","At","RSquare","dims","annotation","fqnOrRefTypePartCommon","Super","isRefTypeInMethodRef","OPTION2","isPrimitiveCastExpression","primitiveCastExpression","referenceTypeCastExpression","primitiveType","additionalBound","unaryExpressionNotPlusMinus","newExpressionTypes","arrayCreationExpression","type","identifyNewExpressionType","classOrInterfaceTypeToInstantiate","argumentList","OPTION3","classBody","MANY3","typeArgumentsOrDiamond","diamond","classOrInterfaceType","arrayCreationDefaultInitSuffix","arrayCreationExplicitInitSuffix","dimExprs","arrayInitializer","dimExpr","LSquare","ColonColon","typePattern","recordPattern","localVariableDeclaration","patternList","When","firstTokenAfterNew","e","firstTokenAfterClassType","firstTokenType","secondTokenType","followedByArrow","isReferenceTypeCastExpression","firstTokTypeAfterRBrace","firstForUnaryExpressionNotPlusMinus","find","tokType","undefined","result","hasDims","firstTokTypeAfterTypeArgs","firstTokTypeAfterRefType","computeFirstForUnaryExpressionNotPlusMinus","firstUnaryExpressionNotPlusMinus","computeContentAssist","nextTokTypes","map","x","nextTokenType","filter","v","i","a","indexOf","module","exports"],"sources":["/Users/duyenpnc/Desktop/tool-tu-lam/your-app-name/node_modules/java-parser/src/productions/expressions.js"],"sourcesContent":["\"use strict\";\nconst { tokenMatcher } = require(\"chevrotain\");\nfunction defineRules($, t) {\n  $.RULE(\"expression\", () => {\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n        ALT: () => $.SUBRULE($.lambdaExpression)\n      },\n      { ALT: () => $.SUBRULE($.ternaryExpression) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-LambdaExpression\n  $.RULE(\"lambdaExpression\", () => {\n    $.SUBRULE($.lambdaParameters);\n    $.CONSUME(t.Arrow);\n    $.SUBRULE($.lambdaBody);\n  });\n\n  $.RULE(\"lambdaParameters\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.lambdaParametersWithBraces) },\n      { ALT: () => $.CONSUME(t.Identifier) }\n    ]);\n  });\n\n  $.RULE(\"lambdaParametersWithBraces\", () => {\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.lambdaParameterList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  $.RULE(\"lambdaParameterList\", () => {\n    $.OR([\n      {\n        GATE: () => {\n          const nextTokType = this.LA(1).tokenType;\n          const nextNextTokType = this.LA(2).tokenType;\n          return (\n            tokenMatcher(nextTokType, t.Identifier) &&\n            (tokenMatcher(nextNextTokType, t.RBrace) ||\n              tokenMatcher(nextNextTokType, t.Comma))\n          );\n        },\n        ALT: () => $.SUBRULE($.inferredLambdaParameterList)\n      },\n      { ALT: () => $.SUBRULE($.explicitLambdaParameterList) }\n    ]);\n  });\n\n  $.RULE(\"inferredLambdaParameterList\", () => {\n    $.CONSUME(t.Identifier);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.CONSUME2(t.Identifier);\n    });\n  });\n\n  $.RULE(\"explicitLambdaParameterList\", () => {\n    $.SUBRULE($.lambdaParameter);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.lambdaParameter);\n    });\n  });\n\n  $.RULE(\"lambdaParameter\", () => {\n    // TODO: performance, investigate the performance boost that could\n    //       be gained by refactoring out the backtracking.\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.regularLambdaParameter),\n        ALT: () => $.SUBRULE($.regularLambdaParameter)\n      },\n      { ALT: () => $.SUBRULE($.variableArityParameter) }\n    ]);\n  });\n\n  $.RULE(\"regularLambdaParameter\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.variableModifier);\n    });\n    $.SUBRULE($.lambdaParameterType);\n    $.SUBRULE($.variableDeclaratorId);\n  });\n\n  $.RULE(\"lambdaParameterType\", () => {\n    $.OR({\n      DEF: [\n        { ALT: () => $.SUBRULE($.unannType) },\n        { ALT: () => $.CONSUME(t.Var) }\n      ],\n      IGNORE_AMBIGUITIES: true\n    });\n  });\n\n  $.RULE(\"lambdaBody\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.expression) },\n      { ALT: () => $.SUBRULE($.block) }\n    ]);\n  });\n\n  $.RULE(\"ternaryExpression\", () => {\n    $.SUBRULE($.binaryExpression);\n    $.OPTION(() => {\n      $.CONSUME(t.QuestionMark);\n      $.SUBRULE($.expression);\n      $.CONSUME(t.Colon);\n      // TODO: in the grammar this is limited to \"lambdaExpression: or \"conditionalExpression\"\n      $.SUBRULE2($.expression);\n    });\n  });\n\n  $.RULE(\"binaryExpression\", () => {\n    $.SUBRULE($.unaryExpression);\n    $.MANY(() => {\n      $.OR({\n        DEF: [\n          {\n            ALT: () => {\n              $.CONSUME(t.Instanceof);\n              $.OR1([\n                {\n                  GATE: () => this.BACKTRACK_LOOKAHEAD($.pattern),\n                  ALT: () => $.SUBRULE($.pattern)\n                },\n                {\n                  ALT: () => $.SUBRULE($.referenceType)\n                }\n              ]);\n            }\n          },\n          {\n            ALT: () => {\n              $.CONSUME(t.AssignmentOperator);\n              $.SUBRULE2($.expression);\n            }\n          },\n          // This is an example of why Java does not have a well designed grammar\n          // See: https://manas.tech/blog/2008/10/12/why-java-generics-dont-have-problems-with-right-shift-operator.html\n          // TODO: ensure the LT/GT sequences have no whitespace between each other.\n          {\n            // TODO: this is a bug in Chevrotain lookahead calculation. the \"BinaryOperator\" token can match \"Less\" or \"Greater\"\n            //   as well, but because it is a **token Category** Chevrotain does not understand it need to looks two tokens ahead.\n            GATE: () =>\n              tokenMatcher($.LA(2).tokenType, t.Less) ||\n              tokenMatcher($.LA(2).tokenType, t.Greater),\n            ALT: () => {\n              $.OR2([\n                {\n                  GATE: () => $.LA(1).startOffset + 1 === $.LA(2).startOffset,\n                  ALT: () => {\n                    $.CONSUME(t.Less);\n                    $.CONSUME2(t.Less);\n                  }\n                },\n                {\n                  GATE: () => $.LA(1).startOffset + 1 === $.LA(2).startOffset,\n                  ALT: () => {\n                    $.CONSUME(t.Greater);\n                    $.CONSUME2(t.Greater);\n                    $.OPTION({\n                      GATE: () =>\n                        $.LA(0).startOffset + 1 === $.LA(1).startOffset,\n                      DEF: () => $.CONSUME3(t.Greater)\n                    });\n                  }\n                }\n              ]);\n              $.SUBRULE2($.unaryExpression);\n            }\n          },\n          {\n            ALT: () => {\n              $.CONSUME(t.BinaryOperator);\n              $.SUBRULE3($.unaryExpression);\n            }\n          }\n        ],\n        IGNORE_AMBIGUITIES: true // the ambiguity between 1 and 4 options is resolved by the order (instanceOf is first)\n      });\n    });\n  });\n\n  $.RULE(\"unaryExpression\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperator);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  });\n\n  $.RULE(\"unaryExpressionNotPlusMinus\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.UnaryPrefixOperatorNotPlusMinus);\n    });\n    $.SUBRULE($.primary);\n    $.MANY2(() => {\n      $.CONSUME(t.UnarySuffixOperator);\n    });\n  });\n\n  $.RULE(\"primary\", () => {\n    $.SUBRULE($.primaryPrefix);\n    $.MANY(() => {\n      $.SUBRULE($.primarySuffix);\n    });\n  });\n\n  $.RULE(\"primaryPrefix\", () => {\n    let isCastExpression = false;\n    if (tokenMatcher($.LA(1).tokenType, t.LBrace)) {\n      isCastExpression = this.BACKTRACK_LOOKAHEAD($.isCastExpression);\n    }\n\n    $.OR([\n      { ALT: () => $.SUBRULE($.literal) },\n      { ALT: () => $.CONSUME(t.This) },\n      { ALT: () => $.CONSUME(t.Void) },\n      { ALT: () => $.SUBRULE($.unannPrimitiveTypeWithOptionalDimsSuffix) },\n      { ALT: () => $.SUBRULE($.fqnOrRefType) },\n      {\n        GATE: () => isCastExpression,\n        ALT: () => $.SUBRULE($.castExpression)\n      },\n      { ALT: () => $.SUBRULE($.parenthesisExpression) },\n      { ALT: () => $.SUBRULE($.newExpression) },\n      { ALT: () => $.SUBRULE($.switchStatement) }\n    ]);\n  });\n\n  $.RULE(\"primarySuffix\", () => {\n    $.OR({\n      DEF: [\n        {\n          ALT: () => {\n            $.CONSUME(t.Dot);\n            $.OR2([\n              { ALT: () => $.CONSUME(t.This) },\n              {\n                ALT: () =>\n                  $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n              },\n              {\n                ALT: () => {\n                  $.OPTION(() => {\n                    $.SUBRULE($.typeArguments);\n                  });\n                  $.CONSUME(t.Identifier);\n                }\n              }\n            ]);\n          }\n        },\n        { ALT: () => $.SUBRULE($.methodInvocationSuffix) },\n        { ALT: () => $.SUBRULE($.classLiteralSuffix) },\n        { ALT: () => $.SUBRULE($.arrayAccessSuffix) },\n        { ALT: () => $.SUBRULE($.methodReferenceSuffix) }\n      ],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n\n  // See https://github.com/jhipster/prettier-java/pull/154 to understand\n  // why fqnOrRefTypePart is split in two rules (First and Rest)\n  $.RULE(\"fqnOrRefType\", () => {\n    $.SUBRULE($.fqnOrRefTypePartFirst);\n\n    $.MANY2({\n      // \".class\" is a classLiteralSuffix\n      GATE: () =>\n        // avoids ambiguity with \".this\" and \".new\" which are parsed as a primary suffix.\n        tokenMatcher(this.LA(2).tokenType, t.Class) === false &&\n        tokenMatcher(this.LA(2).tokenType, t.This) === false &&\n        tokenMatcher(this.LA(2).tokenType, t.New) === false,\n      DEF: () => {\n        $.CONSUME(t.Dot);\n        $.SUBRULE2($.fqnOrRefTypePartRest);\n      }\n    });\n\n    // in case of an arrayType\n    $.OPTION({\n      // it is not enough to check only the opening \"[\", we must avoid conflict with\n      // arrayAccessSuffix\n      GATE: () =>\n        tokenMatcher($.LA(1).tokenType, t.At) ||\n        tokenMatcher($.LA(2).tokenType, t.RSquare),\n      DEF: () => {\n        $.SUBRULE($.dims);\n      }\n    });\n  });\n\n  // TODO: validation:\n  //       1. \"annotation\" cannot be mixed with \"methodTypeArguments\" or \"Super\".\n  //       2. \"methodTypeArguments\" cannot be mixed with \"classTypeArguments\" or \"annotation\".\n  //       3. \"Super\" cannot be mixed with \"classTypeArguments\" or \"annotation\".\n  //       4. At most one \"Super\" may be used.\n  //       5. \"Super\" may be last or one before last (last may also be first if there is only a single part).\n  $.RULE(\"fqnOrRefTypePartRest\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n\n    $.OPTION(() => $.SUBRULE2($.typeArguments));\n\n    $.SUBRULE($.fqnOrRefTypePartCommon);\n  });\n\n  $.RULE(\"fqnOrRefTypePartCommon\", () => {\n    $.OR([\n      { ALT: () => $.CONSUME(t.Identifier) },\n      { ALT: () => $.CONSUME(t.Super) }\n    ]);\n\n    let isRefTypeInMethodRef = false;\n    // Performance optimization, only perform this backtracking when a '<' is found\n    // TODO: performance optimization evaluation: avoid doing this backtracking for every \"<\" encountered.\n    //       we could do it once (using global state) per \"fqnOrRefType\"\n    // We could do it only once for\n    if (tokenMatcher($.LA(1).tokenType, t.Less)) {\n      isRefTypeInMethodRef = this.BACKTRACK_LOOKAHEAD($.isRefTypeInMethodRef);\n    }\n\n    $.OPTION2({\n      // unrestricted typeArguments here would create an ambiguity with \"LessThan\" operator\n      // e.g: \"var x = a < b;\"\n      // The \"<\" would be parsed as the beginning of a \"typeArguments\"\n      // and we will get an error: \"expecting '>' but found: ';'\"\n      GATE: () => isRefTypeInMethodRef,\n      DEF: () => {\n        $.SUBRULE3($.typeArguments);\n      }\n    });\n  });\n\n  $.RULE(\"fqnOrRefTypePartFirst\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n\n    $.SUBRULE($.fqnOrRefTypePartCommon);\n  });\n\n  $.RULE(\"parenthesisExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RBrace);\n  });\n\n  $.RULE(\"castExpression\", () => {\n    $.OR([\n      {\n        // TODO: performance: can avoid backtracking again here, parent rule could have this information\n        //       when it checks isCastExpression (refactor needed)\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression),\n        ALT: () => $.SUBRULE($.primitiveCastExpression)\n      },\n      { ALT: () => $.SUBRULE($.referenceTypeCastExpression) }\n    ]);\n  });\n\n  $.RULE(\"primitiveCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    $.CONSUME(t.RBrace);\n    $.SUBRULE($.unaryExpression);\n  });\n\n  $.RULE(\"referenceTypeCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.isLambdaExpression),\n        ALT: () => $.SUBRULE($.lambdaExpression)\n      },\n      { ALT: () => $.SUBRULE($.unaryExpressionNotPlusMinus) }\n    ]);\n  });\n\n  const newExpressionTypes = {\n    arrayCreationExpression: 1,\n    unqualifiedClassInstanceCreationExpression: 2\n  };\n  $.RULE(\"newExpression\", () => {\n    const type = this.BACKTRACK_LOOKAHEAD($.identifyNewExpressionType);\n\n    $.OR([\n      {\n        GATE: () => type === newExpressionTypes.arrayCreationExpression,\n        ALT: () => $.SUBRULE($.arrayCreationExpression)\n      },\n      {\n        GATE: () =>\n          type ===\n          newExpressionTypes.unqualifiedClassInstanceCreationExpression,\n        ALT: () => $.SUBRULE($.unqualifiedClassInstanceCreationExpression)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-UnqualifiedClassInstanceCreationExpression\n  $.RULE(\"unqualifiedClassInstanceCreationExpression\", () => {\n    $.CONSUME(t.New);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n    $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n    $.OPTION3(() => {\n      $.SUBRULE($.classBody);\n    });\n  });\n\n  $.RULE(\"classOrInterfaceTypeToInstantiate\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.Identifier);\n    $.MANY2(() => {\n      $.CONSUME(t.Dot);\n      $.MANY3(() => {\n        $.SUBRULE2($.annotation);\n      });\n      $.CONSUME2(t.Identifier);\n    });\n    $.OPTION(() => {\n      $.SUBRULE($.typeArgumentsOrDiamond);\n    });\n  });\n\n  $.RULE(\"typeArgumentsOrDiamond\", () => {\n    $.OR({\n      DEF: [\n        { ALT: () => $.SUBRULE($.diamond) },\n        { ALT: () => $.SUBRULE($.typeArguments) }\n      ],\n      MAX_LOOKAHEAD: 2\n    });\n  });\n\n  $.RULE(\"diamond\", () => {\n    $.CONSUME(t.Less);\n    $.CONSUME(t.Greater);\n  });\n\n  $.RULE(\"methodInvocationSuffix\", () => {\n    $.CONSUME(t.LBrace);\n    $.OPTION2(() => {\n      $.SUBRULE($.argumentList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  $.RULE(\"argumentList\", () => {\n    $.SUBRULE($.expression);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.expression);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-15.10.1\n  $.RULE(\"arrayCreationExpression\", () => {\n    $.CONSUME(t.New);\n    $.OR([\n      {\n        GATE: $.BACKTRACK($.primitiveType),\n        ALT: () => $.SUBRULE($.primitiveType)\n      },\n      { ALT: () => $.SUBRULE($.classOrInterfaceType) }\n    ]);\n\n    $.OR2([\n      {\n        GATE: $.BACKTRACK($.arrayCreationDefaultInitSuffix),\n        ALT: () => $.SUBRULE($.arrayCreationDefaultInitSuffix)\n      },\n      { ALT: () => $.SUBRULE($.arrayCreationExplicitInitSuffix) }\n    ]);\n  });\n\n  $.RULE(\"arrayCreationDefaultInitSuffix\", () => {\n    $.SUBRULE($.dimExprs);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n  });\n\n  $.RULE(\"arrayCreationExplicitInitSuffix\", () => {\n    $.SUBRULE($.dims);\n    $.SUBRULE($.arrayInitializer);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-DimExprs\n  $.RULE(\"dimExprs\", () => {\n    $.SUBRULE($.dimExpr);\n    $.MANY({\n      // The GATE is to distinguish DimExpr from Dims :\n      // the only difference between these two is the presence of an expression in the DimExpr\n      // Example: If the GATE is not present double[3][] won't be parsed as the parser will try to parse \"[]\"\n      // as a dimExpr instead of a dims\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RSquare) === false,\n      DEF: () => $.SUBRULE2($.dimExpr)\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-15.html#jls-DimExpr\n  $.RULE(\"dimExpr\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotation);\n    });\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  });\n\n  $.RULE(\"classLiteralSuffix\", () => {\n    $.MANY(() => {\n      $.CONSUME(t.LSquare);\n      $.CONSUME(t.RSquare);\n    });\n    $.CONSUME(t.Dot);\n    $.CONSUME(t.Class);\n  });\n\n  $.RULE(\"arrayAccessSuffix\", () => {\n    $.CONSUME(t.LSquare);\n    $.SUBRULE($.expression);\n    $.CONSUME(t.RSquare);\n  });\n\n  $.RULE(\"methodReferenceSuffix\", () => {\n    $.CONSUME(t.ColonColon);\n    $.OPTION(() => {\n      $.SUBRULE($.typeArguments);\n    });\n\n    $.OR([\n      { ALT: () => $.CONSUME(t.Identifier) },\n      // TODO: a constructor method reference (\"new\") can only be used\n      //   in specific contexts, but perhaps this verification is best left\n      //   for a semantic analysis phase\n      { ALT: () => $.CONSUME(t.New) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-Pattern\n  $.RULE(\"pattern\", () => {\n    $.OR([\n      {\n        GATE: () => this.BACKTRACK_LOOKAHEAD($.typePattern),\n        ALT: () => $.SUBRULE($.typePattern)\n      },\n      {\n        ALT: () => $.SUBRULE($.recordPattern)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-TypePattern\n  $.RULE(\"typePattern\", () => {\n    $.SUBRULE($.localVariableDeclaration);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-RecordPattern\n  $.RULE(\"recordPattern\", () => {\n    $.SUBRULE($.referenceType);\n    $.CONSUME(t.LBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.patternList);\n    });\n    $.CONSUME(t.RBrace);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-PatternList\n  $.RULE(\"patternList\", () => {\n    $.SUBRULE($.pattern);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.pattern);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-Guard\n  $.RULE(\"guard\", () => {\n    $.CONSUME(t.When);\n    $.SUBRULE($.expression);\n  });\n\n  // backtracking lookahead logic\n  $.RULE(\"identifyNewExpressionType\", () => {\n    $.CONSUME(t.New);\n    const firstTokenAfterNew = this.LA(1).tokenType;\n\n    // not an array initialization due to the prefix \"TypeArguments\"\n    if (tokenMatcher(firstTokenAfterNew, t.Less)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n\n    try {\n      $.SUBRULE($.classOrInterfaceTypeToInstantiate);\n    } catch (e) {\n      // if it is not a \"classOrInterfaceTypeToInstantiate\" then\n      // (assuming a valid input) we are looking at an \"arrayCreationExpression\"\n      return newExpressionTypes.arrayCreationExpression;\n    }\n\n    const firstTokenAfterClassType = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokenAfterClassType, t.LBrace)) {\n      return newExpressionTypes.unqualifiedClassInstanceCreationExpression;\n    }\n\n    // The LBrace above is mandatory in \"classInstanceCreation...\" so\n    // it must be an \"arrayCreationExp\" (if the input is valid)\n    // TODO: upgrade the logic to return \"unknown\" type if at this\n    //       point it does not match \"arrayCreation\" either.\n    //   - This will provide a better error message to the user\n    //     in case of invalid inputs\n    return newExpressionTypes.arrayCreationExpression;\n  });\n\n  // Optimized backtracking, only scan ahead until the arrow(\"->\").\n  $.RULE(\"isLambdaExpression\", () => {\n    // TODO: this check of next two tokens is probably redundant as the normal lookahead should take care of this.\n    const firstTokenType = this.LA(1).tokenType;\n    const secondTokenType = this.LA(2).tokenType;\n    // no parent lambda \"x -> x * 2\"\n    if (\n      tokenMatcher(firstTokenType, t.Identifier) &&\n      tokenMatcher(secondTokenType, t.Arrow)\n    ) {\n      return true;\n    }\n    // Performance optimizations, fail fast if it is not a LBrace.\n    else if (tokenMatcher(firstTokenType, t.LBrace)) {\n      $.SUBRULE($.lambdaParametersWithBraces);\n      const followedByArrow = tokenMatcher(this.LA(1).tokenType, t.Arrow);\n      return followedByArrow;\n    }\n    return false;\n  });\n\n  $.RULE(\"isCastExpression\", () => {\n    if (this.BACKTRACK_LOOKAHEAD($.isPrimitiveCastExpression)) {\n      return true;\n    }\n    return this.BACKTRACK_LOOKAHEAD($.isReferenceTypeCastExpression);\n  });\n\n  $.RULE(\"isPrimitiveCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.primitiveType);\n    // No dims so this is not a reference Type\n    $.CONSUME(t.RBrace);\n    return true;\n  });\n\n  $.RULE(\"isReferenceTypeCastExpression\", () => {\n    $.CONSUME(t.LBrace);\n    $.SUBRULE($.referenceType);\n    $.MANY(() => {\n      $.SUBRULE($.additionalBound);\n    });\n    $.CONSUME(t.RBrace);\n    const firstTokTypeAfterRBrace = this.LA(1).tokenType;\n\n    return (\n      this.firstForUnaryExpressionNotPlusMinus.find(tokType =>\n        tokenMatcher(firstTokTypeAfterRBrace, tokType)\n      ) !== undefined\n    );\n  });\n\n  $.RULE(\"isRefTypeInMethodRef\", () => {\n    let result = undefined;\n    $.SUBRULE($.typeArguments);\n\n    // arrayType\n    const hasDims = $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n\n    const firstTokTypeAfterTypeArgs = this.LA(1).tokenType;\n    if (tokenMatcher(firstTokTypeAfterTypeArgs, t.ColonColon)) {\n      result = true;\n    }\n    // we must be at the end of a \"referenceType\" if \"dims\" were encountered\n    // So there is not point to check farther\n    else if (hasDims) {\n      result = false;\n    }\n\n    // in the middle of a \"classReferenceType\"\n    $.OPTION2(() => {\n      $.CONSUME(t.Dot);\n      $.SUBRULE($.classOrInterfaceType);\n    });\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    const firstTokTypeAfterRefType = this.LA(1).tokenType;\n    return tokenMatcher(firstTokTypeAfterRefType, t.ColonColon);\n  });\n}\n\nfunction computeFirstForUnaryExpressionNotPlusMinus() {\n  const firstUnaryExpressionNotPlusMinus = this.computeContentAssist(\n    \"unaryExpressionNotPlusMinus\",\n    []\n  );\n  const nextTokTypes = firstUnaryExpressionNotPlusMinus.map(\n    x => x.nextTokenType\n  );\n  // uniq\n  return nextTokTypes.filter((v, i, a) => a.indexOf(v) === i);\n}\n\nmodule.exports = {\n  defineRules,\n  computeFirstForUnaryExpressionNotPlusMinus\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}