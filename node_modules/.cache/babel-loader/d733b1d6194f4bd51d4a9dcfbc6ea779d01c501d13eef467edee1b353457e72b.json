{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { forEach, contains, PRINT_ERROR, PRINT_WARNING, find, isArray, every, values } from \"../utils/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\";\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n  try {\n    var ast = getRegExpAst(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(failedOptimizationPrefixMsg + \"\\n\" + (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") + (\"\\tUsing the regexp-to-ast library version: \" + VERSION + \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n  return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      var terms = ast.value;\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i];\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        var atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    var minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n        // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false ||\n        // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  // console.log(Object.keys(result).length)\n  return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return contains(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return find(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return isArray(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */function (_super) {\n  __extends(CharCodeFinder, _super);\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    _super.prototype.visitChildren.call(this, node);\n  };\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if (contains(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n  return CharCodeFinder;\n}(BaseRegExpVisitor);\nexport function canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = getRegExpAst(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find(pattern, function (char) {\n      return contains(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","VERSION","BaseRegExpVisitor","forEach","contains","PRINT_ERROR","PRINT_WARNING","find","isArray","every","values","getRegExpAst","charCodeToOptimizedIndex","minOptimizationVal","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","toString","msgSuffix","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","code","range","rangeCode","from","to","minUnOptVal","maxUnOptVal","minOptIdx","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","range_1","targetCode","CharCodeFinder","_super","_this","call","found","visitChildren","node","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/chevrotain/lib_esm/src/scan/reg_exp.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\";\r\nimport { forEach, contains, PRINT_ERROR, PRINT_WARNING, find, isArray, every, values } from \"../utils/utils\";\r\nimport { getRegExpAst } from \"./reg_exp_parser\";\r\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\";\r\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\r\nexport var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\r\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\r\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\r\n    try {\r\n        var ast = getRegExpAst(regExp);\r\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\r\n        return firstChars;\r\n    }\r\n    catch (e) {\r\n        /* istanbul ignore next */\r\n        // Testing this relies on the regexp-to-ast library having a bug... */\r\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\r\n        if (e.message === complementErrorMessage) {\r\n            if (ensureOptimizations) {\r\n                PRINT_WARNING(\"\" + failedOptimizationPrefixMsg +\r\n                    (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") +\r\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\r\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n                    \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\r\n            }\r\n        }\r\n        else {\r\n            var msgSuffix = \"\";\r\n            if (ensureOptimizations) {\r\n                msgSuffix =\r\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n                        \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\r\n            }\r\n            PRINT_ERROR(failedOptimizationPrefixMsg + \"\\n\" +\r\n                (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") +\r\n                (\"\\tUsing the regexp-to-ast library version: \" + VERSION + \"\\n\") +\r\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\r\n                msgSuffix);\r\n        }\r\n    }\r\n    return [];\r\n}\r\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\r\n    switch (ast.type) {\r\n        case \"Disjunction\":\r\n            for (var i = 0; i < ast.value.length; i++) {\r\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\r\n            }\r\n            break;\r\n        case \"Alternative\":\r\n            var terms = ast.value;\r\n            for (var i = 0; i < terms.length; i++) {\r\n                var term = terms[i];\r\n                // skip terms that cannot effect the first char results\r\n                switch (term.type) {\r\n                    case \"EndAnchor\":\r\n                    // A group back reference cannot affect potential starting char.\r\n                    // because if a back reference is the first production than automatically\r\n                    // the group being referenced has had to come BEFORE so its codes have already been added\r\n                    case \"GroupBackReference\":\r\n                    // assertions do not affect potential starting codes\r\n                    case \"Lookahead\":\r\n                    case \"NegativeLookahead\":\r\n                    case \"StartAnchor\":\r\n                    case \"WordBoundary\":\r\n                    case \"NonWordBoundary\":\r\n                        continue;\r\n                }\r\n                var atom = term;\r\n                switch (atom.type) {\r\n                    case \"Character\":\r\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\r\n                        break;\r\n                    case \"Set\":\r\n                        if (atom.complement === true) {\r\n                            throw Error(complementErrorMessage);\r\n                        }\r\n                        forEach(atom.value, function (code) {\r\n                            if (typeof code === \"number\") {\r\n                                addOptimizedIdxToResult(code, result, ignoreCase);\r\n                            }\r\n                            else {\r\n                                // range\r\n                                var range = code;\r\n                                // cannot optimize when ignoreCase is\r\n                                if (ignoreCase === true) {\r\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\r\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\r\n                                    }\r\n                                }\r\n                                // Optimization (2 orders of magnitude less work for very large ranges)\r\n                                else {\r\n                                    // handle unoptimized values\r\n                                    for (var rangeCode = range.from; rangeCode <= range.to &&\r\n                                        rangeCode < minOptimizationVal; rangeCode++) {\r\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\r\n                                    }\r\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\r\n                                    if (range.to >= minOptimizationVal) {\r\n                                        var minUnOptVal = range.from >= minOptimizationVal\r\n                                            ? range.from\r\n                                            : minOptimizationVal;\r\n                                        var maxUnOptVal = range.to;\r\n                                        var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\r\n                                        var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\r\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\r\n                                            result[currOptIdx] = currOptIdx;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                        break;\r\n                    case \"Group\":\r\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\r\n                        break;\r\n                    /* istanbul ignore next */\r\n                    default:\r\n                        throw Error(\"Non Exhaustive Match\");\r\n                }\r\n                // reached a mandatory production, no more **start** codes can be found on this alternative\r\n                var isOptionalQuantifier = atom.quantifier !== undefined &&\r\n                    atom.quantifier.atLeast === 0;\r\n                if (\r\n                // A group may be optional due to empty contents /(?:)/\r\n                // or if everything inside it is optional /((a)?)/\r\n                (atom.type === \"Group\" &&\r\n                    isWholeOptional(atom) === false) ||\r\n                    // If this term is not a group it may only be optional if it has an optional quantifier\r\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw Error(\"non exhaustive match!\");\r\n    }\r\n    // console.log(Object.keys(result).length)\r\n    return values(result);\r\n}\r\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\r\n    var optimizedCharIdx = charCodeToOptimizedIndex(code);\r\n    result[optimizedCharIdx] = optimizedCharIdx;\r\n    if (ignoreCase === true) {\r\n        handleIgnoreCase(code, result);\r\n    }\r\n}\r\nfunction handleIgnoreCase(code, result) {\r\n    var char = String.fromCharCode(code);\r\n    var upperChar = char.toUpperCase();\r\n    /* istanbul ignore else */\r\n    if (upperChar !== char) {\r\n        var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\r\n        result[optimizedCharIdx] = optimizedCharIdx;\r\n    }\r\n    else {\r\n        var lowerChar = char.toLowerCase();\r\n        if (lowerChar !== char) {\r\n            var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\r\n            result[optimizedCharIdx] = optimizedCharIdx;\r\n        }\r\n    }\r\n}\r\nfunction findCode(setNode, targetCharCodes) {\r\n    return find(setNode.value, function (codeOrRange) {\r\n        if (typeof codeOrRange === \"number\") {\r\n            return contains(targetCharCodes, codeOrRange);\r\n        }\r\n        else {\r\n            // range\r\n            var range_1 = codeOrRange;\r\n            return (find(targetCharCodes, function (targetCode) {\r\n                return range_1.from <= targetCode && targetCode <= range_1.to;\r\n            }) !== undefined);\r\n        }\r\n    });\r\n}\r\nfunction isWholeOptional(ast) {\r\n    if (ast.quantifier && ast.quantifier.atLeast === 0) {\r\n        return true;\r\n    }\r\n    if (!ast.value) {\r\n        return false;\r\n    }\r\n    return isArray(ast.value)\r\n        ? every(ast.value, isWholeOptional)\r\n        : isWholeOptional(ast.value);\r\n}\r\nvar CharCodeFinder = /** @class */ (function (_super) {\r\n    __extends(CharCodeFinder, _super);\r\n    function CharCodeFinder(targetCharCodes) {\r\n        var _this = _super.call(this) || this;\r\n        _this.targetCharCodes = targetCharCodes;\r\n        _this.found = false;\r\n        return _this;\r\n    }\r\n    CharCodeFinder.prototype.visitChildren = function (node) {\r\n        // No need to keep looking...\r\n        if (this.found === true) {\r\n            return;\r\n        }\r\n        // switch lookaheads as they do not actually consume any characters thus\r\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\r\n        switch (node.type) {\r\n            case \"Lookahead\":\r\n                this.visitLookahead(node);\r\n                return;\r\n            case \"NegativeLookahead\":\r\n                this.visitNegativeLookahead(node);\r\n                return;\r\n        }\r\n        _super.prototype.visitChildren.call(this, node);\r\n    };\r\n    CharCodeFinder.prototype.visitCharacter = function (node) {\r\n        if (contains(this.targetCharCodes, node.value)) {\r\n            this.found = true;\r\n        }\r\n    };\r\n    CharCodeFinder.prototype.visitSet = function (node) {\r\n        if (node.complement) {\r\n            if (findCode(node, this.targetCharCodes) === undefined) {\r\n                this.found = true;\r\n            }\r\n        }\r\n        else {\r\n            if (findCode(node, this.targetCharCodes) !== undefined) {\r\n                this.found = true;\r\n            }\r\n        }\r\n    };\r\n    return CharCodeFinder;\r\n}(BaseRegExpVisitor));\r\nexport function canMatchCharCode(charCodes, pattern) {\r\n    if (pattern instanceof RegExp) {\r\n        var ast = getRegExpAst(pattern);\r\n        var charCodeFinder = new CharCodeFinder(charCodes);\r\n        charCodeFinder.visit(ast);\r\n        return charCodeFinder.found;\r\n    }\r\n    else {\r\n        return (find(pattern, function (char) {\r\n            return contains(charCodes, char.charCodeAt(0));\r\n        }) !== undefined);\r\n    }\r\n}\r\n//# sourceMappingURL=reg_exp.js.map"],"mappings":"AAAA,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAM,YAAY;EACrD,IAAIC,aAAa,GAAG,SAAAA,CAAUC,CAAC,EAAEC,CAAC,EAAE;IAChCF,aAAa,GAAGG,MAAM,CAACC,cAAc,IAChC;MAAEC,SAAS,EAAE;IAAG,CAAC,YAAYC,KAAK,IAAI,UAAUL,CAAC,EAAEC,CAAC,EAAE;MAAED,CAAC,CAACI,SAAS,GAAGH,CAAC;IAAE,CAAE,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;MAAE,KAAK,IAAIK,CAAC,IAAIL,CAAC,EAAE,IAAIA,CAAC,CAACM,cAAc,CAACD,CAAC,CAAC,EAAEN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;IAAE,CAAC;IAC9E,OAAOP,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;EAC9B,CAAC;EACD,OAAO,UAAUD,CAAC,EAAEC,CAAC,EAAE;IACnBF,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;IACnB,SAASO,EAAEA,CAAA,EAAG;MAAE,IAAI,CAACC,WAAW,GAAGT,CAAC;IAAE;IACtCA,CAAC,CAACU,SAAS,GAAGT,CAAC,KAAK,IAAI,GAAGC,MAAM,CAACS,MAAM,CAACV,CAAC,CAAC,IAAIO,EAAE,CAACE,SAAS,GAAGT,CAAC,CAACS,SAAS,EAAE,IAAIF,EAAE,CAAC,CAAC,CAAC;EACxF,CAAC;AACL,CAAC,CAAE,CAAC;AACJ,SAASI,OAAO,EAAEC,iBAAiB,QAAQ,eAAe;AAC1D,SAASC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,aAAa,EAAEC,IAAI,EAAEC,OAAO,EAAEC,KAAK,EAAEC,MAAM,QAAQ,gBAAgB;AAC5G,SAASC,YAAY,QAAQ,kBAAkB;AAC/C,SAASC,wBAAwB,EAAEC,kBAAkB,QAAQ,SAAS;AACtE,IAAIC,sBAAsB,GAAG,+DAA+D;AAC5F,OAAO,IAAIC,2BAA2B,GAAG,mDAAmD;AAC5F,OAAO,SAASC,6BAA6BA,CAACC,MAAM,EAAEC,mBAAmB,EAAE;EACvE,IAAIA,mBAAmB,KAAK,KAAK,CAAC,EAAE;IAAEA,mBAAmB,GAAG,KAAK;EAAE;EACnE,IAAI;IACA,IAAIC,GAAG,GAAGR,YAAY,CAACM,MAAM,CAAC;IAC9B,IAAIG,UAAU,GAAGC,yBAAyB,CAACF,GAAG,CAACG,KAAK,EAAE,CAAC,CAAC,EAAEH,GAAG,CAACI,KAAK,CAACC,UAAU,CAAC;IAC/E,OAAOJ,UAAU;EACrB,CAAC,CACD,OAAOK,CAAC,EAAE;IACN;IACA;IACA;IACA,IAAIA,CAAC,CAACC,OAAO,KAAKZ,sBAAsB,EAAE;MACtC,IAAII,mBAAmB,EAAE;QACrBZ,aAAa,CAAC,EAAE,GAAGS,2BAA2B,IACzC,0BAA0B,GAAGE,MAAM,CAACU,QAAQ,CAAC,CAAC,GAAG,MAAM,CAAC,GACzD,wDAAwD,GACxD,6DAA6D,GAC7D,wGAAwG,CAAC;MACjH;IACJ,CAAC,MACI;MACD,IAAIC,SAAS,GAAG,EAAE;MAClB,IAAIV,mBAAmB,EAAE;QACrBU,SAAS,GACL,+DAA+D,GAC3D,4GAA4G;MACxH;MACAvB,WAAW,CAACU,2BAA2B,GAAG,IAAI,IACzC,sBAAsB,GAAGE,MAAM,CAACU,QAAQ,CAAC,CAAC,GAAG,MAAM,CAAC,IACpD,6CAA6C,GAAG1B,OAAO,GAAG,IAAI,CAAC,GAChE,yEAAyE,GACzE2B,SAAS,CAAC;IAClB;EACJ;EACA,OAAO,EAAE;AACb;AACA,OAAO,SAASP,yBAAyBA,CAACF,GAAG,EAAEU,MAAM,EAAEL,UAAU,EAAE;EAC/D,QAAQL,GAAG,CAACW,IAAI;IACZ,KAAK,aAAa;MACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,GAAG,CAACG,KAAK,CAACU,MAAM,EAAED,CAAC,EAAE,EAAE;QACvCV,yBAAyB,CAACF,GAAG,CAACG,KAAK,CAACS,CAAC,CAAC,EAAEF,MAAM,EAAEL,UAAU,CAAC;MAC/D;MACA;IACJ,KAAK,aAAa;MACd,IAAIS,KAAK,GAAGd,GAAG,CAACG,KAAK;MACrB,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,KAAK,CAACD,MAAM,EAAED,CAAC,EAAE,EAAE;QACnC,IAAIG,IAAI,GAAGD,KAAK,CAACF,CAAC,CAAC;QACnB;QACA,QAAQG,IAAI,CAACJ,IAAI;UACb,KAAK,WAAW;UAChB;UACA;UACA;UACA,KAAK,oBAAoB;UACzB;UACA,KAAK,WAAW;UAChB,KAAK,mBAAmB;UACxB,KAAK,aAAa;UAClB,KAAK,cAAc;UACnB,KAAK,iBAAiB;YAClB;QACR;QACA,IAAIK,IAAI,GAAGD,IAAI;QACf,QAAQC,IAAI,CAACL,IAAI;UACb,KAAK,WAAW;YACZM,uBAAuB,CAACD,IAAI,CAACb,KAAK,EAAEO,MAAM,EAAEL,UAAU,CAAC;YACvD;UACJ,KAAK,KAAK;YACN,IAAIW,IAAI,CAACE,UAAU,KAAK,IAAI,EAAE;cAC1B,MAAMC,KAAK,CAACxB,sBAAsB,CAAC;YACvC;YACAX,OAAO,CAACgC,IAAI,CAACb,KAAK,EAAE,UAAUiB,IAAI,EAAE;cAChC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;gBAC1BH,uBAAuB,CAACG,IAAI,EAAEV,MAAM,EAAEL,UAAU,CAAC;cACrD,CAAC,MACI;gBACD;gBACA,IAAIgB,KAAK,GAAGD,IAAI;gBAChB;gBACA,IAAIf,UAAU,KAAK,IAAI,EAAE;kBACrB,KAAK,IAAIiB,SAAS,GAAGD,KAAK,CAACE,IAAI,EAAED,SAAS,IAAID,KAAK,CAACG,EAAE,EAAEF,SAAS,EAAE,EAAE;oBACjEL,uBAAuB,CAACK,SAAS,EAAEZ,MAAM,EAAEL,UAAU,CAAC;kBAC1D;gBACJ;gBACA;gBAAA,KACK;kBACD;kBACA,KAAK,IAAIiB,SAAS,GAAGD,KAAK,CAACE,IAAI,EAAED,SAAS,IAAID,KAAK,CAACG,EAAE,IAClDF,SAAS,GAAG5B,kBAAkB,EAAE4B,SAAS,EAAE,EAAE;oBAC7CL,uBAAuB,CAACK,SAAS,EAAEZ,MAAM,EAAEL,UAAU,CAAC;kBAC1D;kBACA;kBACA,IAAIgB,KAAK,CAACG,EAAE,IAAI9B,kBAAkB,EAAE;oBAChC,IAAI+B,WAAW,GAAGJ,KAAK,CAACE,IAAI,IAAI7B,kBAAkB,GAC5C2B,KAAK,CAACE,IAAI,GACV7B,kBAAkB;oBACxB,IAAIgC,WAAW,GAAGL,KAAK,CAACG,EAAE;oBAC1B,IAAIG,SAAS,GAAGlC,wBAAwB,CAACgC,WAAW,CAAC;oBACrD,IAAIG,SAAS,GAAGnC,wBAAwB,CAACiC,WAAW,CAAC;oBACrD,KAAK,IAAIG,UAAU,GAAGF,SAAS,EAAEE,UAAU,IAAID,SAAS,EAAEC,UAAU,EAAE,EAAE;sBACpEnB,MAAM,CAACmB,UAAU,CAAC,GAAGA,UAAU;oBACnC;kBACJ;gBACJ;cACJ;YACJ,CAAC,CAAC;YACF;UACJ,KAAK,OAAO;YACR3B,yBAAyB,CAACc,IAAI,CAACb,KAAK,EAAEO,MAAM,EAAEL,UAAU,CAAC;YACzD;UACJ;UACA;YACI,MAAMc,KAAK,CAAC,sBAAsB,CAAC;QAC3C;QACA;QACA,IAAIW,oBAAoB,GAAGd,IAAI,CAACe,UAAU,KAAKC,SAAS,IACpDhB,IAAI,CAACe,UAAU,CAACE,OAAO,KAAK,CAAC;QACjC;QACA;QACA;QACCjB,IAAI,CAACL,IAAI,KAAK,OAAO,IAClBuB,eAAe,CAAClB,IAAI,CAAC,KAAK,KAAK;QAC/B;QACCA,IAAI,CAACL,IAAI,KAAK,OAAO,IAAImB,oBAAoB,KAAK,KAAM,EAAE;UAC3D;QACJ;MACJ;MACA;IACJ;IACA;MACI,MAAMX,KAAK,CAAC,uBAAuB,CAAC;EAC5C;EACA;EACA,OAAO5B,MAAM,CAACmB,MAAM,CAAC;AACzB;AACA,SAASO,uBAAuBA,CAACG,IAAI,EAAEV,MAAM,EAAEL,UAAU,EAAE;EACvD,IAAI8B,gBAAgB,GAAG1C,wBAAwB,CAAC2B,IAAI,CAAC;EACrDV,MAAM,CAACyB,gBAAgB,CAAC,GAAGA,gBAAgB;EAC3C,IAAI9B,UAAU,KAAK,IAAI,EAAE;IACrB+B,gBAAgB,CAAChB,IAAI,EAAEV,MAAM,CAAC;EAClC;AACJ;AACA,SAAS0B,gBAAgBA,CAAChB,IAAI,EAAEV,MAAM,EAAE;EACpC,IAAI2B,IAAI,GAAGC,MAAM,CAACC,YAAY,CAACnB,IAAI,CAAC;EACpC,IAAIoB,SAAS,GAAGH,IAAI,CAACI,WAAW,CAAC,CAAC;EAClC;EACA,IAAID,SAAS,KAAKH,IAAI,EAAE;IACpB,IAAIF,gBAAgB,GAAG1C,wBAAwB,CAAC+C,SAAS,CAACE,UAAU,CAAC,CAAC,CAAC,CAAC;IACxEhC,MAAM,CAACyB,gBAAgB,CAAC,GAAGA,gBAAgB;EAC/C,CAAC,MACI;IACD,IAAIQ,SAAS,GAAGN,IAAI,CAACO,WAAW,CAAC,CAAC;IAClC,IAAID,SAAS,KAAKN,IAAI,EAAE;MACpB,IAAIF,gBAAgB,GAAG1C,wBAAwB,CAACkD,SAAS,CAACD,UAAU,CAAC,CAAC,CAAC,CAAC;MACxEhC,MAAM,CAACyB,gBAAgB,CAAC,GAAGA,gBAAgB;IAC/C;EACJ;AACJ;AACA,SAASU,QAAQA,CAACC,OAAO,EAAEC,eAAe,EAAE;EACxC,OAAO3D,IAAI,CAAC0D,OAAO,CAAC3C,KAAK,EAAE,UAAU6C,WAAW,EAAE;IAC9C,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;MACjC,OAAO/D,QAAQ,CAAC8D,eAAe,EAAEC,WAAW,CAAC;IACjD,CAAC,MACI;MACD;MACA,IAAIC,OAAO,GAAGD,WAAW;MACzB,OAAQ5D,IAAI,CAAC2D,eAAe,EAAE,UAAUG,UAAU,EAAE;QAChD,OAAOD,OAAO,CAAC1B,IAAI,IAAI2B,UAAU,IAAIA,UAAU,IAAID,OAAO,CAACzB,EAAE;MACjE,CAAC,CAAC,KAAKQ,SAAS;IACpB;EACJ,CAAC,CAAC;AACN;AACA,SAASE,eAAeA,CAAClC,GAAG,EAAE;EAC1B,IAAIA,GAAG,CAAC+B,UAAU,IAAI/B,GAAG,CAAC+B,UAAU,CAACE,OAAO,KAAK,CAAC,EAAE;IAChD,OAAO,IAAI;EACf;EACA,IAAI,CAACjC,GAAG,CAACG,KAAK,EAAE;IACZ,OAAO,KAAK;EAChB;EACA,OAAOd,OAAO,CAACW,GAAG,CAACG,KAAK,CAAC,GACnBb,KAAK,CAACU,GAAG,CAACG,KAAK,EAAE+B,eAAe,CAAC,GACjCA,eAAe,CAAClC,GAAG,CAACG,KAAK,CAAC;AACpC;AACA,IAAIgD,cAAc,GAAG,aAAe,UAAUC,MAAM,EAAE;EAClDpF,SAAS,CAACmF,cAAc,EAAEC,MAAM,CAAC;EACjC,SAASD,cAAcA,CAACJ,eAAe,EAAE;IACrC,IAAIM,KAAK,GAAGD,MAAM,CAACE,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;IACrCD,KAAK,CAACN,eAAe,GAAGA,eAAe;IACvCM,KAAK,CAACE,KAAK,GAAG,KAAK;IACnB,OAAOF,KAAK;EAChB;EACAF,cAAc,CAACvE,SAAS,CAAC4E,aAAa,GAAG,UAAUC,IAAI,EAAE;IACrD;IACA,IAAI,IAAI,CAACF,KAAK,KAAK,IAAI,EAAE;MACrB;IACJ;IACA;IACA;IACA,QAAQE,IAAI,CAAC9C,IAAI;MACb,KAAK,WAAW;QACZ,IAAI,CAAC+C,cAAc,CAACD,IAAI,CAAC;QACzB;MACJ,KAAK,mBAAmB;QACpB,IAAI,CAACE,sBAAsB,CAACF,IAAI,CAAC;QACjC;IACR;IACAL,MAAM,CAACxE,SAAS,CAAC4E,aAAa,CAACF,IAAI,CAAC,IAAI,EAAEG,IAAI,CAAC;EACnD,CAAC;EACDN,cAAc,CAACvE,SAAS,CAACgF,cAAc,GAAG,UAAUH,IAAI,EAAE;IACtD,IAAIxE,QAAQ,CAAC,IAAI,CAAC8D,eAAe,EAAEU,IAAI,CAACtD,KAAK,CAAC,EAAE;MAC5C,IAAI,CAACoD,KAAK,GAAG,IAAI;IACrB;EACJ,CAAC;EACDJ,cAAc,CAACvE,SAAS,CAACiF,QAAQ,GAAG,UAAUJ,IAAI,EAAE;IAChD,IAAIA,IAAI,CAACvC,UAAU,EAAE;MACjB,IAAI2B,QAAQ,CAACY,IAAI,EAAE,IAAI,CAACV,eAAe,CAAC,KAAKf,SAAS,EAAE;QACpD,IAAI,CAACuB,KAAK,GAAG,IAAI;MACrB;IACJ,CAAC,MACI;MACD,IAAIV,QAAQ,CAACY,IAAI,EAAE,IAAI,CAACV,eAAe,CAAC,KAAKf,SAAS,EAAE;QACpD,IAAI,CAACuB,KAAK,GAAG,IAAI;MACrB;IACJ;EACJ,CAAC;EACD,OAAOJ,cAAc;AACzB,CAAC,CAACpE,iBAAiB,CAAE;AACrB,OAAO,SAAS+E,gBAAgBA,CAACC,SAAS,EAAEC,OAAO,EAAE;EACjD,IAAIA,OAAO,YAAYC,MAAM,EAAE;IAC3B,IAAIjE,GAAG,GAAGR,YAAY,CAACwE,OAAO,CAAC;IAC/B,IAAIE,cAAc,GAAG,IAAIf,cAAc,CAACY,SAAS,CAAC;IAClDG,cAAc,CAACC,KAAK,CAACnE,GAAG,CAAC;IACzB,OAAOkE,cAAc,CAACX,KAAK;EAC/B,CAAC,MACI;IACD,OAAQnE,IAAI,CAAC4E,OAAO,EAAE,UAAU3B,IAAI,EAAE;MAClC,OAAOpD,QAAQ,CAAC8E,SAAS,EAAE1B,IAAI,CAACK,UAAU,CAAC,CAAC,CAAC,CAAC;IAClD,CAAC,CAAC,KAAKV,SAAS;EACpB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}