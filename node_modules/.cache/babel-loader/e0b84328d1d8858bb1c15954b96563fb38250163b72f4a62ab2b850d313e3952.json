{"ast":null,"code":"import { uniq, map, flatten } from \"../../utils/utils\";\nimport { NonTerminal, Terminal } from \"./gast/gast_public\";\nimport { isBranchingProd, isOptionalProd, isSequenceProd } from \"./gast/gast\";\nexport function first(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    // this could in theory cause infinite loops if\n    // (1) prod A refs prod B.\n    // (2) prod B refs prod A\n    // (3) AB can match the empty set\n    // in other words a cycle where everything is optional so the first will keep\n    // looking ahead for the next optional part and will never exit\n    // currently there is no safeguard for this unique edge case because\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\n    return first(prod.referencedRule);\n  } else if (prod instanceof Terminal) {\n    return firstForTerminal(prod);\n  } else if (isSequenceProd(prod)) {\n    return firstForSequence(prod);\n  } else if (isBranchingProd(prod)) {\n    return firstForBranching(prod);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function firstForSequence(prod) {\n  var firstSet = [];\n  var seq = prod.definition;\n  var nextSubProdIdx = 0;\n  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  var currSubProd;\n  // so we enter the loop at least once (if the definition is not empty\n  var isLastInnerProdOptional = true;\n  // scan a sequence until it's end or until we have found a NONE optional production in it\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n    currSubProd = seq[nextSubProdIdx];\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\n    firstSet = firstSet.concat(first(currSubProd));\n    nextSubProdIdx = nextSubProdIdx + 1;\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n  }\n  return uniq(firstSet);\n}\nexport function firstForBranching(prod) {\n  var allAlternativesFirsts = map(prod.definition, function (innerProd) {\n    return first(innerProd);\n  });\n  return uniq(flatten(allAlternativesFirsts));\n}\nexport function firstForTerminal(terminal) {\n  return [terminal.terminalType];\n}","map":{"version":3,"names":["uniq","map","flatten","NonTerminal","Terminal","isBranchingProd","isOptionalProd","isSequenceProd","first","prod","referencedRule","firstForTerminal","firstForSequence","firstForBranching","Error","firstSet","seq","definition","nextSubProdIdx","hasInnerProdsRemaining","length","currSubProd","isLastInnerProdOptional","concat","allAlternativesFirsts","innerProd","terminal","terminalType"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/chevrotain/lib_esm/src/parse/grammar/first.js"],"sourcesContent":["import { uniq, map, flatten } from \"../../utils/utils\";\r\nimport { NonTerminal, Terminal } from \"./gast/gast_public\";\r\nimport { isBranchingProd, isOptionalProd, isSequenceProd } from \"./gast/gast\";\r\nexport function first(prod) {\r\n    /* istanbul ignore else */\r\n    if (prod instanceof NonTerminal) {\r\n        // this could in theory cause infinite loops if\r\n        // (1) prod A refs prod B.\r\n        // (2) prod B refs prod A\r\n        // (3) AB can match the empty set\r\n        // in other words a cycle where everything is optional so the first will keep\r\n        // looking ahead for the next optional part and will never exit\r\n        // currently there is no safeguard for this unique edge case because\r\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\r\n        return first(prod.referencedRule);\r\n    }\r\n    else if (prod instanceof Terminal) {\r\n        return firstForTerminal(prod);\r\n    }\r\n    else if (isSequenceProd(prod)) {\r\n        return firstForSequence(prod);\r\n    }\r\n    else if (isBranchingProd(prod)) {\r\n        return firstForBranching(prod);\r\n    }\r\n    else {\r\n        throw Error(\"non exhaustive match\");\r\n    }\r\n}\r\nexport function firstForSequence(prod) {\r\n    var firstSet = [];\r\n    var seq = prod.definition;\r\n    var nextSubProdIdx = 0;\r\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\r\n    var currSubProd;\r\n    // so we enter the loop at least once (if the definition is not empty\r\n    var isLastInnerProdOptional = true;\r\n    // scan a sequence until it's end or until we have found a NONE optional production in it\r\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\r\n        currSubProd = seq[nextSubProdIdx];\r\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\r\n        firstSet = firstSet.concat(first(currSubProd));\r\n        nextSubProdIdx = nextSubProdIdx + 1;\r\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\r\n    }\r\n    return uniq(firstSet);\r\n}\r\nexport function firstForBranching(prod) {\r\n    var allAlternativesFirsts = map(prod.definition, function (innerProd) {\r\n        return first(innerProd);\r\n    });\r\n    return uniq(flatten(allAlternativesFirsts));\r\n}\r\nexport function firstForTerminal(terminal) {\r\n    return [terminal.terminalType];\r\n}\r\n//# sourceMappingURL=first.js.map"],"mappings":"AAAA,SAASA,IAAI,EAAEC,GAAG,EAAEC,OAAO,QAAQ,mBAAmB;AACtD,SAASC,WAAW,EAAEC,QAAQ,QAAQ,oBAAoB;AAC1D,SAASC,eAAe,EAAEC,cAAc,EAAEC,cAAc,QAAQ,aAAa;AAC7E,OAAO,SAASC,KAAKA,CAACC,IAAI,EAAE;EACxB;EACA,IAAIA,IAAI,YAAYN,WAAW,EAAE;IAC7B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAOK,KAAK,CAACC,IAAI,CAACC,cAAc,CAAC;EACrC,CAAC,MACI,IAAID,IAAI,YAAYL,QAAQ,EAAE;IAC/B,OAAOO,gBAAgB,CAACF,IAAI,CAAC;EACjC,CAAC,MACI,IAAIF,cAAc,CAACE,IAAI,CAAC,EAAE;IAC3B,OAAOG,gBAAgB,CAACH,IAAI,CAAC;EACjC,CAAC,MACI,IAAIJ,eAAe,CAACI,IAAI,CAAC,EAAE;IAC5B,OAAOI,iBAAiB,CAACJ,IAAI,CAAC;EAClC,CAAC,MACI;IACD,MAAMK,KAAK,CAAC,sBAAsB,CAAC;EACvC;AACJ;AACA,OAAO,SAASF,gBAAgBA,CAACH,IAAI,EAAE;EACnC,IAAIM,QAAQ,GAAG,EAAE;EACjB,IAAIC,GAAG,GAAGP,IAAI,CAACQ,UAAU;EACzB,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,sBAAsB,GAAGH,GAAG,CAACI,MAAM,GAAGF,cAAc;EACxD,IAAIG,WAAW;EACf;EACA,IAAIC,uBAAuB,GAAG,IAAI;EAClC;EACA,OAAOH,sBAAsB,IAAIG,uBAAuB,EAAE;IACtDD,WAAW,GAAGL,GAAG,CAACE,cAAc,CAAC;IACjCI,uBAAuB,GAAGhB,cAAc,CAACe,WAAW,CAAC;IACrDN,QAAQ,GAAGA,QAAQ,CAACQ,MAAM,CAACf,KAAK,CAACa,WAAW,CAAC,CAAC;IAC9CH,cAAc,GAAGA,cAAc,GAAG,CAAC;IACnCC,sBAAsB,GAAGH,GAAG,CAACI,MAAM,GAAGF,cAAc;EACxD;EACA,OAAOlB,IAAI,CAACe,QAAQ,CAAC;AACzB;AACA,OAAO,SAASF,iBAAiBA,CAACJ,IAAI,EAAE;EACpC,IAAIe,qBAAqB,GAAGvB,GAAG,CAACQ,IAAI,CAACQ,UAAU,EAAE,UAAUQ,SAAS,EAAE;IAClE,OAAOjB,KAAK,CAACiB,SAAS,CAAC;EAC3B,CAAC,CAAC;EACF,OAAOzB,IAAI,CAACE,OAAO,CAACsB,qBAAqB,CAAC,CAAC;AAC/C;AACA,OAAO,SAASb,gBAAgBA,CAACe,QAAQ,EAAE;EACvC,OAAO,CAACA,QAAQ,CAACC,YAAY,CAAC;AAClC"},"metadata":{},"sourceType":"module","externalDependencies":[]}