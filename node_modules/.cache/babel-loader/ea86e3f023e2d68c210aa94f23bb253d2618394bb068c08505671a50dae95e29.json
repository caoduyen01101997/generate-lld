{"ast":null,"code":"\"use strict\";\n\nconst {\n  tokenMatcher\n} = require(\"chevrotain\");\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceDeclaration\n  $.RULE(\"interfaceDeclaration\", () => {\n    // Spec Deviation: extracted the common \"interfaceModifier\" prefix to avoid backtracking.\n    $.MANY({\n      DEF: () => {\n        $.SUBRULE($.interfaceModifier);\n      },\n      MAX_LOOKAHEAD: 2\n    });\n    $.OR([{\n      ALT: () => $.SUBRULE($.normalInterfaceDeclaration)\n    }, {\n      ALT: () => $.SUBRULE($.annotationTypeDeclaration)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-NormalInterfaceDeclaration\n  $.RULE(\"normalInterfaceDeclaration\", () => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.extendsInterfaces);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.interfacePermits);\n    });\n    $.SUBRULE($.interfaceBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceModifier\n  $.RULE(\"interfaceModifier\", () => {\n    $.OR([{\n      ALT: () => $.SUBRULE($.annotation)\n    }, {\n      ALT: () => $.CONSUME(t.Public)\n    }, {\n      ALT: () => $.CONSUME(t.Protected)\n    }, {\n      ALT: () => $.CONSUME(t.Private)\n    }, {\n      ALT: () => $.CONSUME(t.Abstract)\n    }, {\n      ALT: () => $.CONSUME(t.Static)\n    }, {\n      ALT: () => $.CONSUME(t.Sealed)\n    }, {\n      ALT: () => $.CONSUME(t.NonSealed)\n    }, {\n      ALT: () => $.CONSUME(t.Strictfp)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceExtends\n  $.RULE(\"extendsInterfaces\", () => {\n    $.CONSUME(t.Extends);\n    $.SUBRULE($.interfaceTypeList);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/preview/specs/sealed-classes-jls.html\n  $.RULE(\"interfacePermits\", () => {\n    $.CONSUME(t.Permits);\n    $.SUBRULE($.typeName);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.typeName);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceBody\n  $.RULE(\"interfaceBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  });\n  const InterfaceBodyTypes = {\n    unknown: 0,\n    constantDeclaration: 1,\n    interfaceMethodDeclaration: 2,\n    classDeclaration: 3,\n    interfaceDeclaration: 4,\n    semiColon: 5\n  };\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMemberDeclaration\n  $.RULE(\"interfaceMemberDeclaration\", () => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD($.identifyInterfaceBodyDeclarationType);\n    $.OR([{\n      GATE: () => detectedType === InterfaceBodyTypes.constantDeclaration,\n      ALT: () => $.SUBRULE($.constantDeclaration)\n    }, {\n      GATE: () => detectedType === InterfaceBodyTypes.interfaceMethodDeclaration,\n      ALT: () => $.SUBRULE($.interfaceMethodDeclaration)\n    }, {\n      GATE: () => detectedType === InterfaceBodyTypes.classDeclaration,\n      ALT: () => $.SUBRULE($.classDeclaration)\n    }, {\n      GATE: () => detectedType === InterfaceBodyTypes.interfaceDeclaration,\n      ALT: () => $.SUBRULE($.interfaceDeclaration)\n    }, {\n      // No GATE is needed as this is LL(1)\n      ALT: () => $.CONSUME(t.Semicolon)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ConstantDeclaration\n  $.RULE(\"constantDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.constantModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorList);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ConstantModifier\n  $.RULE(\"constantModifier\", () => {\n    $.OR([{\n      ALT: () => $.SUBRULE($.annotation)\n    }, {\n      ALT: () => $.CONSUME(t.Public)\n    }, {\n      ALT: () => $.CONSUME(t.Static)\n    }, {\n      ALT: () => $.CONSUME(t.Final)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMethodDeclaration\n  $.RULE(\"interfaceMethodDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMethodModifier);\n    });\n    $.SUBRULE($.methodHeader);\n    $.SUBRULE($.methodBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMethodModifier\n  $.RULE(\"interfaceMethodModifier\", () => {\n    $.OR([{\n      ALT: () => $.SUBRULE($.annotation)\n    }, {\n      ALT: () => $.CONSUME(t.Public)\n    }, {\n      ALT: () => $.CONSUME(t.Private)\n    }, {\n      ALT: () => $.CONSUME(t.Abstract)\n    }, {\n      ALT: () => $.CONSUME(t.Default)\n    }, {\n      ALT: () => $.CONSUME(t.Static)\n    }, {\n      ALT: () => $.CONSUME(t.Strictfp)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeDeclaration\n  $.RULE(\"annotationTypeDeclaration\", () => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.At);\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.SUBRULE($.annotationTypeBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeBody\n  $.RULE(\"annotationTypeBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  });\n  const AnnotationBodyTypes = {\n    unknown: 0,\n    annotationTypeElementDeclaration: 2,\n    constantDeclaration: 1,\n    classDeclaration: 3,\n    interfaceDeclaration: 4,\n    semiColon: 5\n  };\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMemberDeclaration\n  $.RULE(\"annotationTypeMemberDeclaration\", () => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD($.identifyAnnotationBodyDeclarationType);\n    $.OR([{\n      GATE: () => detectedType === AnnotationBodyTypes.annotationTypeElementDeclaration,\n      ALT: () => $.SUBRULE($.annotationTypeElementDeclaration)\n    }, {\n      GATE: () => detectedType === AnnotationBodyTypes.constantDeclaration,\n      ALT: () => $.SUBRULE($.constantDeclaration)\n    }, {\n      GATE: () => detectedType === AnnotationBodyTypes.classDeclaration,\n      ALT: () => $.SUBRULE($.classDeclaration)\n    }, {\n      GATE: () => detectedType === AnnotationBodyTypes.interfaceDeclaration,\n      ALT: () => $.SUBRULE($.interfaceDeclaration)\n    }, {\n      // No GATE is needed as this is LL(1)\n      ALT: () => $.CONSUME(t.Semicolon)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeElementDeclaration\n  $.RULE(\"annotationTypeElementDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeElementModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.LBrace);\n    $.CONSUME(t.RBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.defaultValue);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeElementModifier\n  $.RULE(\"annotationTypeElementModifier\", () => {\n    $.OR([{\n      ALT: () => $.SUBRULE($.annotation)\n    }, {\n      ALT: () => $.CONSUME(t.Public)\n    }, {\n      ALT: () => $.CONSUME(t.Abstract)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-DefaultValue\n  $.RULE(\"defaultValue\", () => {\n    $.CONSUME(t.Default);\n    $.SUBRULE($.elementValue);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-Annotation\n  $.RULE(\"annotation\", () => {\n    // Spec Deviation: The common prefix for all three annotation types was extracted to this rule.\n    // This was done to avoid the use of backtracking for performance reasons.\n    $.CONSUME(t.At);\n    $.SUBRULE($.typeName);\n\n    // If this optional grammar was not invoked we have a markerAnnotation\n    // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-MarkerAnnotation\n    $.OPTION(() => {\n      $.CONSUME(t.LBrace);\n      $.OR({\n        DEF: [\n        // normal annotation - https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-NormalAnnotation\n        {\n          ALT: () => $.SUBRULE($.elementValuePairList)\n        },\n        // Single Element Annotation - https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-SingleElementAnnotation\n        {\n          ALT: () => $.SUBRULE($.elementValue)\n        }, {\n          ALT: () => {\n            /* empty normal annotation contents */\n          }\n        }],\n        IGNORE_AMBIGUITIES: true,\n        MAX_LOOKAHEAD: 2\n      });\n      $.CONSUME(t.RBrace);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValuePairList\n  $.RULE(\"elementValuePairList\", () => {\n    $.SUBRULE($.elementValuePair);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.elementValuePair);\n    });\n  });\n  $.RULE(\"elementValuePair\", () => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Equals);\n    $.SUBRULE($.elementValue);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValue\n  $.RULE(\"elementValue\", () => {\n    const isSimpleElementValueAnnotation = this.BACKTRACK_LOOKAHEAD($.isSimpleElementValueAnnotation);\n    $.OR([\n    // Spec Deviation: \"conditionalExpression\" replaced with \"expression\"\n    // Because we cannot differentiate between the two using fixed lookahead.\n    {\n      GATE: () => isSimpleElementValueAnnotation === false,\n      ALT: () => $.SUBRULE($.expression)\n    }, {\n      ALT: () => $.SUBRULE($.elementValueArrayInitializer)\n    }, {\n      GATE: () => isSimpleElementValueAnnotation === true,\n      ALT: () => $.SUBRULE($.annotation)\n    }]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValueArrayInitializer\n  $.RULE(\"elementValueArrayInitializer\", () => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.elementValueList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValueList\n  $.RULE(\"elementValueList\", () => {\n    $.SUBRULE($.elementValue);\n    $.MANY({\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RCurly) === false,\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.elementValue);\n      }\n    });\n  });\n\n  // ------------------------------------\n  // Special optimized backtracking rules.\n  // ------------------------------------\n  $.RULE(\"identifyInterfaceBodyDeclarationType\", () => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return InterfaceBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () => (tokenMatcher($.LA(1).tokenType, t.At) && tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"interfaceMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([{\n          ALT: () => $.SUBRULE($.annotation)\n        }, {\n          ALT: () => $.CONSUME(t.Public)\n        }, {\n          ALT: () => $.CONSUME(t.Protected)\n        }, {\n          ALT: () => $.CONSUME(t.Private)\n        }, {\n          ALT: () => $.CONSUME(t.Abstract)\n        }, {\n          ALT: () => $.CONSUME(t.Static)\n        }, {\n          ALT: () => $.CONSUME(t.Sealed)\n        }, {\n          ALT: () => $.CONSUME(t.NonSealed)\n        }, {\n          ALT: () => $.CONSUME(t.Strictfp)\n        }, {\n          ALT: () => $.CONSUME(t.Final)\n        }, {\n          ALT: () => $.CONSUME(t.Default)\n        }]);\n      }\n    });\n    nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Class) || tokenMatcher(nextTokenType, t.Enum) || tokenMatcher(nextTokenType, t.Record)) {\n      return InterfaceBodyTypes.classDeclaration;\n    }\n    if (tokenMatcher(nextTokenType, t.Interface) || tokenMatcher(nextTokenType, t.At)) {\n      return InterfaceBodyTypes.interfaceDeclaration;\n    }\n    if (tokenMatcher(nextTokenType, t.Void) || tokenMatcher(nextTokenType, t.Less)) {\n      // method with result type \"void\"\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n\n    // Only constant or interfaceMethod declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n    const nextToken = this.LA(1);\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like method start\n    if (tokenMatcher(nextToken, t.Identifier) && tokenMatcher(nextNextTokenType, t.LBrace)) {\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextToken, t.Identifier)) {\n      return InterfaceBodyTypes.constantDeclaration;\n    }\n    return InterfaceBodyTypes.unknown;\n  });\n  $.RULE(\"identifyAnnotationBodyDeclarationType\", () => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return AnnotationBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () => (tokenMatcher($.LA(1).tokenType, t.At) && tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"annotationTypeMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([{\n          ALT: () => $.SUBRULE($.annotation)\n        }, {\n          ALT: () => $.CONSUME(t.Public)\n        }, {\n          ALT: () => $.CONSUME(t.Protected)\n        }, {\n          ALT: () => $.CONSUME(t.Private)\n        }, {\n          ALT: () => $.CONSUME(t.Abstract)\n        }, {\n          ALT: () => $.CONSUME(t.Static)\n        }, {\n          ALT: () => $.CONSUME(t.Final)\n        }, {\n          ALT: () => $.CONSUME(t.Strictfp)\n        }]);\n      }\n    });\n    nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Class) || tokenMatcher(nextTokenType, t.Enum)) {\n      return AnnotationBodyTypes.classDeclaration;\n    }\n    if (tokenMatcher(nextTokenType, t.Interface) || tokenMatcher(nextTokenType, t.At)) {\n      return AnnotationBodyTypes.interfaceDeclaration;\n    }\n\n    // Only constant or annotationTypeElement declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n    nextTokenType = this.LA(1).tokenType;\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like annotationTypeElement start\n    if (tokenMatcher(nextTokenType, t.Identifier) && tokenMatcher(nextNextTokenType, t.LBrace)) {\n      return AnnotationBodyTypes.annotationTypeElementDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextTokenType, t.Identifier)) {\n      return AnnotationBodyTypes.constantDeclaration;\n    }\n    return AnnotationBodyTypes.unknown;\n  });\n  $.RULE(\"isSimpleElementValueAnnotation\", () => {\n    $.SUBRULE($.annotation);\n    const nextTokenType = this.LA(1).tokenType;\n    switch (nextTokenType) {\n      // annotation in \"ElementValue\" would be followed by one of those\n      // any other TokenType would indicate it is an annotation in a \"referenceType\"\n      // as part of a \"methodReference\" in \"primary\"\n      case t.Comma:\n      case t.Semicolon:\n      case t.RCurly:\n      case t.RBrace:\n        return true;\n      default:\n        return false;\n    }\n  });\n}\nmodule.exports = {\n  defineRules\n};","map":{"version":3,"names":["tokenMatcher","require","defineRules","$","t","RULE","MANY","DEF","SUBRULE","interfaceModifier","MAX_LOOKAHEAD","OR","ALT","normalInterfaceDeclaration","annotationTypeDeclaration","CONSUME","Interface","typeIdentifier","OPTION","typeParameters","OPTION2","extendsInterfaces","OPTION3","interfacePermits","interfaceBody","annotation","Public","Protected","Private","Abstract","Static","Sealed","NonSealed","Strictfp","Extends","interfaceTypeList","Permits","typeName","Comma","SUBRULE2","LCurly","interfaceMemberDeclaration","RCurly","InterfaceBodyTypes","unknown","constantDeclaration","interfaceMethodDeclaration","classDeclaration","interfaceDeclaration","semiColon","detectedType","BACKTRACK_LOOKAHEAD","identifyInterfaceBodyDeclarationType","GATE","Semicolon","constantModifier","unannType","variableDeclaratorList","Final","interfaceMethodModifier","methodHeader","methodBody","Default","At","annotationTypeBody","annotationTypeMemberDeclaration","AnnotationBodyTypes","annotationTypeElementDeclaration","identifyAnnotationBodyDeclarationType","annotationTypeElementModifier","Identifier","LBrace","RBrace","dims","defaultValue","elementValue","elementValuePairList","IGNORE_AMBIGUITIES","elementValuePair","Equals","isSimpleElementValueAnnotation","expression","elementValueArrayInitializer","elementValueList","LA","tokenType","nextTokenType","Class","Enum","Record","Void","Less","nextToken","nextNextTokenType","module","exports"],"sources":["/Users/duyenpnc/Desktop/tool-tu-lam/your-app-name/node_modules/java-parser/src/productions/interfaces.js"],"sourcesContent":["\"use strict\";\nconst { tokenMatcher } = require(\"chevrotain\");\n\nfunction defineRules($, t) {\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceDeclaration\n  $.RULE(\"interfaceDeclaration\", () => {\n    // Spec Deviation: extracted the common \"interfaceModifier\" prefix to avoid backtracking.\n    $.MANY({\n      DEF: () => {\n        $.SUBRULE($.interfaceModifier);\n      },\n      MAX_LOOKAHEAD: 2\n    });\n\n    $.OR([\n      { ALT: () => $.SUBRULE($.normalInterfaceDeclaration) },\n      { ALT: () => $.SUBRULE($.annotationTypeDeclaration) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-NormalInterfaceDeclaration\n  $.RULE(\"normalInterfaceDeclaration\", () => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.OPTION(() => {\n      $.SUBRULE($.typeParameters);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.extendsInterfaces);\n    });\n    $.OPTION3(() => {\n      $.SUBRULE($.interfacePermits);\n    });\n    $.SUBRULE($.interfaceBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceModifier\n  $.RULE(\"interfaceModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Protected) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Sealed) },\n      { ALT: () => $.CONSUME(t.NonSealed) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceExtends\n  $.RULE(\"extendsInterfaces\", () => {\n    $.CONSUME(t.Extends);\n    $.SUBRULE($.interfaceTypeList);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/preview/specs/sealed-classes-jls.html\n  $.RULE(\"interfacePermits\", () => {\n    $.CONSUME(t.Permits);\n    $.SUBRULE($.typeName);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.typeName);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceBody\n  $.RULE(\"interfaceBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  const InterfaceBodyTypes = {\n    unknown: 0,\n    constantDeclaration: 1,\n    interfaceMethodDeclaration: 2,\n    classDeclaration: 3,\n    interfaceDeclaration: 4,\n    semiColon: 5\n  };\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMemberDeclaration\n  $.RULE(\"interfaceMemberDeclaration\", () => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\n      $.identifyInterfaceBodyDeclarationType\n    );\n\n    $.OR([\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.constantDeclaration,\n        ALT: () => $.SUBRULE($.constantDeclaration)\n      },\n      {\n        GATE: () =>\n          detectedType === InterfaceBodyTypes.interfaceMethodDeclaration,\n        ALT: () => $.SUBRULE($.interfaceMethodDeclaration)\n      },\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => detectedType === InterfaceBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ConstantDeclaration\n  $.RULE(\"constantDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.constantModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.SUBRULE($.variableDeclaratorList);\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ConstantModifier\n  $.RULE(\"constantModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Final) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMethodDeclaration\n  $.RULE(\"interfaceMethodDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.interfaceMethodModifier);\n    });\n    $.SUBRULE($.methodHeader);\n    $.SUBRULE($.methodBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMethodModifier\n  $.RULE(\"interfaceMethodModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Private) },\n      { ALT: () => $.CONSUME(t.Abstract) },\n      { ALT: () => $.CONSUME(t.Default) },\n      { ALT: () => $.CONSUME(t.Static) },\n      { ALT: () => $.CONSUME(t.Strictfp) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeDeclaration\n  $.RULE(\"annotationTypeDeclaration\", () => {\n    // Spec Deviation: The \"interfaceModifier\" prefix was extracted to the \"interfaceDeclaration\"\n    $.CONSUME(t.At);\n    $.CONSUME(t.Interface);\n    $.SUBRULE($.typeIdentifier);\n    $.SUBRULE($.annotationTypeBody);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeBody\n  $.RULE(\"annotationTypeBody\", () => {\n    $.CONSUME(t.LCurly);\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeMemberDeclaration);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  const AnnotationBodyTypes = {\n    unknown: 0,\n    annotationTypeElementDeclaration: 2,\n    constantDeclaration: 1,\n    classDeclaration: 3,\n    interfaceDeclaration: 4,\n    semiColon: 5\n  };\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-InterfaceMemberDeclaration\n  $.RULE(\"annotationTypeMemberDeclaration\", () => {\n    const detectedType = this.BACKTRACK_LOOKAHEAD(\n      $.identifyAnnotationBodyDeclarationType\n    );\n\n    $.OR([\n      {\n        GATE: () =>\n          detectedType === AnnotationBodyTypes.annotationTypeElementDeclaration,\n        ALT: () => $.SUBRULE($.annotationTypeElementDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.constantDeclaration,\n        ALT: () => $.SUBRULE($.constantDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.classDeclaration,\n        ALT: () => $.SUBRULE($.classDeclaration)\n      },\n      {\n        GATE: () => detectedType === AnnotationBodyTypes.interfaceDeclaration,\n        ALT: () => $.SUBRULE($.interfaceDeclaration)\n      },\n      {\n        // No GATE is needed as this is LL(1)\n        ALT: () => $.CONSUME(t.Semicolon)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeElementDeclaration\n  $.RULE(\"annotationTypeElementDeclaration\", () => {\n    $.MANY(() => {\n      $.SUBRULE($.annotationTypeElementModifier);\n    });\n    $.SUBRULE($.unannType);\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.LBrace);\n    $.CONSUME(t.RBrace);\n    $.OPTION(() => {\n      $.SUBRULE($.dims);\n    });\n    $.OPTION2(() => {\n      $.SUBRULE($.defaultValue);\n    });\n    $.CONSUME(t.Semicolon);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-AnnotationTypeElementModifier\n  $.RULE(\"annotationTypeElementModifier\", () => {\n    $.OR([\n      { ALT: () => $.SUBRULE($.annotation) },\n      { ALT: () => $.CONSUME(t.Public) },\n      { ALT: () => $.CONSUME(t.Abstract) }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-DefaultValue\n  $.RULE(\"defaultValue\", () => {\n    $.CONSUME(t.Default);\n    $.SUBRULE($.elementValue);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-Annotation\n  $.RULE(\"annotation\", () => {\n    // Spec Deviation: The common prefix for all three annotation types was extracted to this rule.\n    // This was done to avoid the use of backtracking for performance reasons.\n    $.CONSUME(t.At);\n    $.SUBRULE($.typeName);\n\n    // If this optional grammar was not invoked we have a markerAnnotation\n    // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-MarkerAnnotation\n    $.OPTION(() => {\n      $.CONSUME(t.LBrace);\n      $.OR({\n        DEF: [\n          // normal annotation - https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-NormalAnnotation\n          { ALT: () => $.SUBRULE($.elementValuePairList) },\n          // Single Element Annotation - https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-SingleElementAnnotation\n          {\n            ALT: () => $.SUBRULE($.elementValue)\n          },\n          {\n            ALT: () => {\n              /* empty normal annotation contents */\n            }\n          }\n        ],\n        IGNORE_AMBIGUITIES: true,\n        MAX_LOOKAHEAD: 2\n      });\n      $.CONSUME(t.RBrace);\n    });\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValuePairList\n  $.RULE(\"elementValuePairList\", () => {\n    $.SUBRULE($.elementValuePair);\n    $.MANY(() => {\n      $.CONSUME(t.Comma);\n      $.SUBRULE2($.elementValuePair);\n    });\n  });\n\n  $.RULE(\"elementValuePair\", () => {\n    $.CONSUME(t.Identifier);\n    $.CONSUME(t.Equals);\n    $.SUBRULE($.elementValue);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValue\n  $.RULE(\"elementValue\", () => {\n    const isSimpleElementValueAnnotation = this.BACKTRACK_LOOKAHEAD(\n      $.isSimpleElementValueAnnotation\n    );\n\n    $.OR([\n      // Spec Deviation: \"conditionalExpression\" replaced with \"expression\"\n      // Because we cannot differentiate between the two using fixed lookahead.\n      {\n        GATE: () => isSimpleElementValueAnnotation === false,\n        ALT: () => $.SUBRULE($.expression)\n      },\n      { ALT: () => $.SUBRULE($.elementValueArrayInitializer) },\n      {\n        GATE: () => isSimpleElementValueAnnotation === true,\n        ALT: () => $.SUBRULE($.annotation)\n      }\n    ]);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValueArrayInitializer\n  $.RULE(\"elementValueArrayInitializer\", () => {\n    $.CONSUME(t.LCurly);\n    $.OPTION(() => {\n      $.SUBRULE($.elementValueList);\n    });\n    $.OPTION2(() => {\n      $.CONSUME(t.Comma);\n    });\n    $.CONSUME(t.RCurly);\n  });\n\n  // https://docs.oracle.com/javase/specs/jls/se16/html/jls-9.html#jls-ElementValueList\n  $.RULE(\"elementValueList\", () => {\n    $.SUBRULE($.elementValue);\n    $.MANY({\n      GATE: () => tokenMatcher($.LA(2).tokenType, t.RCurly) === false,\n      DEF: () => {\n        $.CONSUME(t.Comma);\n        $.SUBRULE2($.elementValue);\n      }\n    });\n  });\n\n  // ------------------------------------\n  // Special optimized backtracking rules.\n  // ------------------------------------\n  $.RULE(\"identifyInterfaceBodyDeclarationType\", () => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return InterfaceBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () =>\n        (tokenMatcher($.LA(1).tokenType, t.At) &&\n          tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"interfaceMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([\n          { ALT: () => $.SUBRULE($.annotation) },\n          { ALT: () => $.CONSUME(t.Public) },\n          { ALT: () => $.CONSUME(t.Protected) },\n          { ALT: () => $.CONSUME(t.Private) },\n          { ALT: () => $.CONSUME(t.Abstract) },\n          { ALT: () => $.CONSUME(t.Static) },\n          { ALT: () => $.CONSUME(t.Sealed) },\n          { ALT: () => $.CONSUME(t.NonSealed) },\n          { ALT: () => $.CONSUME(t.Strictfp) },\n          { ALT: () => $.CONSUME(t.Final) },\n          { ALT: () => $.CONSUME(t.Default) }\n        ]);\n      }\n    });\n\n    nextTokenType = this.LA(1).tokenType;\n    if (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum) ||\n      tokenMatcher(nextTokenType, t.Record)\n    ) {\n      return InterfaceBodyTypes.classDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Interface) ||\n      tokenMatcher(nextTokenType, t.At)\n    ) {\n      return InterfaceBodyTypes.interfaceDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Void) ||\n      tokenMatcher(nextTokenType, t.Less)\n    ) {\n      // method with result type \"void\"\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n\n    // Only constant or interfaceMethod declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n\n    const nextToken = this.LA(1);\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like method start\n    if (\n      tokenMatcher(nextToken, t.Identifier) &&\n      tokenMatcher(nextNextTokenType, t.LBrace)\n    ) {\n      return InterfaceBodyTypes.interfaceMethodDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextToken, t.Identifier)) {\n      return InterfaceBodyTypes.constantDeclaration;\n    }\n    return InterfaceBodyTypes.unknown;\n  });\n\n  $.RULE(\"identifyAnnotationBodyDeclarationType\", () => {\n    let nextTokenType = this.LA(1).tokenType;\n    if (tokenMatcher(nextTokenType, t.Semicolon)) {\n      return AnnotationBodyTypes.semiColon;\n    }\n\n    // We have to look beyond the modifiers to distinguish between the declaration types.\n    $.MANY({\n      // To avoid ambiguity with @interface (\"AnnotationTypeDeclaration\" vs \"Annotaion\")\n      GATE: () =>\n        (tokenMatcher($.LA(1).tokenType, t.At) &&\n          tokenMatcher($.LA(2).tokenType, t.Interface)) === false,\n      DEF: () => {\n        // This alternation includes all possible modifiers for all types of \"annotationTypeMemberDeclaration\"\n        // Certain combinations are syntactically invalid, this is **not** checked here,\n        // Invalid combinations will cause a descriptive parsing error message to be\n        // Created inside the relevant parsing rules **after** this lookahead\n        // analysis.\n        $.OR([\n          { ALT: () => $.SUBRULE($.annotation) },\n          { ALT: () => $.CONSUME(t.Public) },\n          { ALT: () => $.CONSUME(t.Protected) },\n          { ALT: () => $.CONSUME(t.Private) },\n          { ALT: () => $.CONSUME(t.Abstract) },\n          { ALT: () => $.CONSUME(t.Static) },\n          { ALT: () => $.CONSUME(t.Final) },\n          { ALT: () => $.CONSUME(t.Strictfp) }\n        ]);\n      }\n    });\n\n    nextTokenType = this.LA(1).tokenType;\n    if (\n      tokenMatcher(nextTokenType, t.Class) ||\n      tokenMatcher(nextTokenType, t.Enum)\n    ) {\n      return AnnotationBodyTypes.classDeclaration;\n    }\n    if (\n      tokenMatcher(nextTokenType, t.Interface) ||\n      tokenMatcher(nextTokenType, t.At)\n    ) {\n      return AnnotationBodyTypes.interfaceDeclaration;\n    }\n\n    // Only constant or annotationTypeElement declarations may be valid at this point.\n    // All other alternatives should have been attempted.\n    // **both** start with \"unannType\"\n    this.SUBRULE($.unannType);\n\n    nextTokenType = this.LA(1).tokenType;\n    const nextNextTokenType = this.LA(2).tokenType;\n    // \"foo(...\" --> look like annotationTypeElement start\n    if (\n      tokenMatcher(nextTokenType, t.Identifier) &&\n      tokenMatcher(nextNextTokenType, t.LBrace)\n    ) {\n      return AnnotationBodyTypes.annotationTypeElementDeclaration;\n    }\n    // a valid constant\n    if (tokenMatcher(nextTokenType, t.Identifier)) {\n      return AnnotationBodyTypes.constantDeclaration;\n    }\n    return AnnotationBodyTypes.unknown;\n  });\n\n  $.RULE(\"isSimpleElementValueAnnotation\", () => {\n    $.SUBRULE($.annotation);\n    const nextTokenType = this.LA(1).tokenType;\n    switch (nextTokenType) {\n      // annotation in \"ElementValue\" would be followed by one of those\n      // any other TokenType would indicate it is an annotation in a \"referenceType\"\n      // as part of a \"methodReference\" in \"primary\"\n      case t.Comma:\n      case t.Semicolon:\n      case t.RCurly:\n      case t.RBrace:\n        return true;\n      default:\n        return false;\n    }\n  });\n}\n\nmodule.exports = {\n  defineRules\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}