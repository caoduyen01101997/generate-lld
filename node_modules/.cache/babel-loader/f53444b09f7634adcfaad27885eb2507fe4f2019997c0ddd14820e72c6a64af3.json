{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n    g.plantumlEncoder = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n        return n[i].exports;\n      }\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n      return o;\n    }\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      var pako = require('pako/lib/deflate.js');\n      module.exports = function (data) {\n        return pako.deflateRaw(data, {\n          level: 9,\n          to: 'string'\n        });\n      };\n    }, {\n      \"pako/lib/deflate.js\": 4\n    }],\n    2: [function (require, module, exports) {\n      'use strict';\n\n      // Encode code taken from the PlantUML website:\n      // http://plantuml.sourceforge.net/codejavascript2.html\n\n      // It is described as being \"a transformation close to base64\"\n      // The code has been slightly modified to pass linters\n      function encode6bit(b) {\n        if (b < 10) {\n          return String.fromCharCode(48 + b);\n        }\n        b -= 10;\n        if (b < 26) {\n          return String.fromCharCode(65 + b);\n        }\n        b -= 26;\n        if (b < 26) {\n          return String.fromCharCode(97 + b);\n        }\n        b -= 26;\n        if (b === 0) {\n          return '-';\n        }\n        if (b === 1) {\n          return '_';\n        }\n        return '?';\n      }\n      function append3bytes(b1, b2, b3) {\n        var c1 = b1 >> 2;\n        var c2 = (b1 & 0x3) << 4 | b2 >> 4;\n        var c3 = (b2 & 0xF) << 2 | b3 >> 6;\n        var c4 = b3 & 0x3F;\n        var r = '';\n        r += encode6bit(c1 & 0x3F);\n        r += encode6bit(c2 & 0x3F);\n        r += encode6bit(c3 & 0x3F);\n        r += encode6bit(c4 & 0x3F);\n        return r;\n      }\n      module.exports = function (data) {\n        var r = '';\n        for (var i = 0; i < data.length; i += 3) {\n          if (i + 2 === data.length) {\n            r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0);\n          } else if (i + 1 === data.length) {\n            r += append3bytes(data.charCodeAt(i), 0, 0);\n          } else {\n            r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), data.charCodeAt(i + 2));\n          }\n        }\n        return r;\n      };\n    }, {}],\n    3: [function (require, module, exports) {\n      'use strict';\n\n      var deflate = require('./deflate');\n      var encode64 = require('./encode64');\n      module.exports.encode = function (puml) {\n        var deflated = deflate(puml);\n        return encode64(deflated);\n      };\n    }, {\n      \"./deflate\": 1,\n      \"./encode64\": 2\n    }],\n    4: [function (require, module, exports) {\n      'use strict';\n\n      var zlib_deflate = require('./zlib/deflate');\n      var utils = require('./utils/common');\n      var strings = require('./utils/strings');\n      var msg = require('./zlib/messages');\n      var ZStream = require('./zlib/zstream');\n      var toString = Object.prototype.toString;\n\n      /* Public constants ==========================================================*/\n      /* ===========================================================================*/\n\n      var Z_NO_FLUSH = 0;\n      var Z_FINISH = 4;\n      var Z_OK = 0;\n      var Z_STREAM_END = 1;\n      var Z_SYNC_FLUSH = 2;\n      var Z_DEFAULT_COMPRESSION = -1;\n      var Z_DEFAULT_STRATEGY = 0;\n      var Z_DEFLATED = 8;\n\n      /* ===========================================================================*/\n\n      /**\r\n       * class Deflate\r\n       *\r\n       * Generic JS-style wrapper for zlib calls. If you don't need\r\n       * streaming behaviour - use more simple functions: [[deflate]],\r\n       * [[deflateRaw]] and [[gzip]].\r\n       **/\n\n      /* internal\r\n       * Deflate.chunks -> Array\r\n       *\r\n       * Chunks of output data, if [[Deflate#onData]] not overridden.\r\n       **/\n\n      /**\r\n       * Deflate.result -> Uint8Array|Array\r\n       *\r\n       * Compressed result, generated by default [[Deflate#onData]]\r\n       * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\r\n       * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\r\n       * push a chunk with explicit flush (call [[Deflate#push]] with\r\n       * `Z_SYNC_FLUSH` param).\r\n       **/\n\n      /**\r\n       * Deflate.err -> Number\r\n       *\r\n       * Error code after deflate finished. 0 (Z_OK) on success.\r\n       * You will not need it in real life, because deflate errors\r\n       * are possible only on wrong options or bad `onData` / `onEnd`\r\n       * custom handlers.\r\n       **/\n\n      /**\r\n       * Deflate.msg -> String\r\n       *\r\n       * Error message, if [[Deflate.err]] != 0\r\n       **/\n\n      /**\r\n       * new Deflate(options)\r\n       * - options (Object): zlib deflate options.\r\n       *\r\n       * Creates new deflator instance with specified params. Throws exception\r\n       * on bad params. Supported options:\r\n       *\r\n       * - `level`\r\n       * - `windowBits`\r\n       * - `memLevel`\r\n       * - `strategy`\r\n       * - `dictionary`\r\n       *\r\n       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\r\n       * for more information on these.\r\n       *\r\n       * Additional options, for internal needs:\r\n       *\r\n       * - `chunkSize` - size of generated data chunks (16K by default)\r\n       * - `raw` (Boolean) - do raw deflate\r\n       * - `gzip` (Boolean) - create gzip wrapper\r\n       * - `to` (String) - if equal to 'string', then result will be \"binary string\"\r\n       *    (each char code [0..255])\r\n       * - `header` (Object) - custom header for gzip\r\n       *   - `text` (Boolean) - true if compressed data believed to be text\r\n       *   - `time` (Number) - modification time, unix timestamp\r\n       *   - `os` (Number) - operation system code\r\n       *   - `extra` (Array) - array of bytes with extra data (max 65536)\r\n       *   - `name` (String) - file name (binary string)\r\n       *   - `comment` (String) - comment (binary string)\r\n       *   - `hcrc` (Boolean) - true if header crc should be added\r\n       *\r\n       * ##### Example:\r\n       *\r\n       * ```javascript\r\n       * var pako = require('pako')\r\n       *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\r\n       *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\r\n       *\r\n       * var deflate = new pako.Deflate({ level: 3});\r\n       *\r\n       * deflate.push(chunk1, false);\r\n       * deflate.push(chunk2, true);  // true -> last chunk\r\n       *\r\n       * if (deflate.err) { throw new Error(deflate.err); }\r\n       *\r\n       * console.log(deflate.result);\r\n       * ```\r\n       **/\n      function Deflate(options) {\n        if (!(this instanceof Deflate)) return new Deflate(options);\n        this.options = utils.assign({\n          level: Z_DEFAULT_COMPRESSION,\n          method: Z_DEFLATED,\n          chunkSize: 16384,\n          windowBits: 15,\n          memLevel: 8,\n          strategy: Z_DEFAULT_STRATEGY,\n          to: ''\n        }, options || {});\n        var opt = this.options;\n        if (opt.raw && opt.windowBits > 0) {\n          opt.windowBits = -opt.windowBits;\n        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n          opt.windowBits += 16;\n        }\n        this.err = 0; // error code, if happens (0 = Z_OK)\n        this.msg = ''; // error message\n        this.ended = false; // used to avoid multiple onEnd() calls\n        this.chunks = []; // chunks of compressed data\n\n        this.strm = new ZStream();\n        this.strm.avail_out = 0;\n        var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n        if (status !== Z_OK) {\n          throw new Error(msg[status]);\n        }\n        if (opt.header) {\n          zlib_deflate.deflateSetHeader(this.strm, opt.header);\n        }\n        if (opt.dictionary) {\n          var dict;\n          // Convert data if needed\n          if (typeof opt.dictionary === 'string') {\n            // If we need to compress text, change encoding to utf8.\n            dict = strings.string2buf(opt.dictionary);\n          } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n            dict = new Uint8Array(opt.dictionary);\n          } else {\n            dict = opt.dictionary;\n          }\n          status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n          if (status !== Z_OK) {\n            throw new Error(msg[status]);\n          }\n          this._dict_set = true;\n        }\n      }\n\n      /**\r\n       * Deflate#push(data[, mode]) -> Boolean\r\n       * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\r\n       *   converted to utf8 byte sequence.\r\n       * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\r\n       *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\r\n       *\r\n       * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\r\n       * new compressed chunks. Returns `true` on success. The last data block must have\r\n       * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\r\n       * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\r\n       * can use mode Z_SYNC_FLUSH, keeping the compression context.\r\n       *\r\n       * On fail call [[Deflate#onEnd]] with error code and return false.\r\n       *\r\n       * We strongly recommend to use `Uint8Array` on input for best speed (output\r\n       * array format is detected automatically). Also, don't skip last param and always\r\n       * use the same type in your code (boolean or number). That will improve JS speed.\r\n       *\r\n       * For regular `Array`-s make sure all elements are [0..255].\r\n       *\r\n       * ##### Example\r\n       *\r\n       * ```javascript\r\n       * push(chunk, false); // push one of data chunks\r\n       * ...\r\n       * push(chunk, true);  // push last chunk\r\n       * ```\r\n       **/\n      Deflate.prototype.push = function (data, mode) {\n        var strm = this.strm;\n        var chunkSize = this.options.chunkSize;\n        var status, _mode;\n        if (this.ended) {\n          return false;\n        }\n        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n        // Convert data if needed\n        if (typeof data === 'string') {\n          // If we need to compress text, change encoding to utf8.\n          strm.input = strings.string2buf(data);\n        } else if (toString.call(data) === '[object ArrayBuffer]') {\n          strm.input = new Uint8Array(data);\n        } else {\n          strm.input = data;\n        }\n        strm.next_in = 0;\n        strm.avail_in = strm.input.length;\n        do {\n          if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n          }\n          status = zlib_deflate.deflate(strm, _mode); /* no bad return value */\n\n          if (status !== Z_STREAM_END && status !== Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n          }\n          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {\n            if (this.options.to === 'string') {\n              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n            } else {\n              this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n            }\n          }\n        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n        // Finalize on the last chunk.\n        if (_mode === Z_FINISH) {\n          status = zlib_deflate.deflateEnd(this.strm);\n          this.onEnd(status);\n          this.ended = true;\n          return status === Z_OK;\n        }\n\n        // callback interim results if Z_SYNC_FLUSH.\n        if (_mode === Z_SYNC_FLUSH) {\n          this.onEnd(Z_OK);\n          strm.avail_out = 0;\n          return true;\n        }\n        return true;\n      };\n\n      /**\r\n       * Deflate#onData(chunk) -> Void\r\n       * - chunk (Uint8Array|Array|String): output data. Type of array depends\r\n       *   on js engine support. When string output requested, each chunk\r\n       *   will be string.\r\n       *\r\n       * By default, stores data blocks in `chunks[]` property and glue\r\n       * those in `onEnd`. Override this handler, if you need another behaviour.\r\n       **/\n      Deflate.prototype.onData = function (chunk) {\n        this.chunks.push(chunk);\n      };\n\n      /**\r\n       * Deflate#onEnd(status) -> Void\r\n       * - status (Number): deflate status. 0 (Z_OK) on success,\r\n       *   other if not.\r\n       *\r\n       * Called once after you tell deflate that the input stream is\r\n       * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\r\n       * or if an error happened. By default - join collected chunks,\r\n       * free memory and fill `results` / `err` properties.\r\n       **/\n      Deflate.prototype.onEnd = function (status) {\n        // On success - join\n        if (status === Z_OK) {\n          if (this.options.to === 'string') {\n            this.result = this.chunks.join('');\n          } else {\n            this.result = utils.flattenChunks(this.chunks);\n          }\n        }\n        this.chunks = [];\n        this.err = status;\n        this.msg = this.strm.msg;\n      };\n\n      /**\r\n       * deflate(data[, options]) -> Uint8Array|Array|String\r\n       * - data (Uint8Array|Array|String): input data to compress.\r\n       * - options (Object): zlib deflate options.\r\n       *\r\n       * Compress `data` with deflate algorithm and `options`.\r\n       *\r\n       * Supported options are:\r\n       *\r\n       * - level\r\n       * - windowBits\r\n       * - memLevel\r\n       * - strategy\r\n       * - dictionary\r\n       *\r\n       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\r\n       * for more information on these.\r\n       *\r\n       * Sugar (options):\r\n       *\r\n       * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\r\n       *   negative windowBits implicitly.\r\n       * - `to` (String) - if equal to 'string', then result will be \"binary string\"\r\n       *    (each char code [0..255])\r\n       *\r\n       * ##### Example:\r\n       *\r\n       * ```javascript\r\n       * var pako = require('pako')\r\n       *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\r\n       *\r\n       * console.log(pako.deflate(data));\r\n       * ```\r\n       **/\n      function deflate(input, options) {\n        var deflator = new Deflate(options);\n        deflator.push(input, true);\n\n        // That will never happens, if you don't cheat with options :)\n        if (deflator.err) {\n          throw deflator.msg || msg[deflator.err];\n        }\n        return deflator.result;\n      }\n\n      /**\r\n       * deflateRaw(data[, options]) -> Uint8Array|Array|String\r\n       * - data (Uint8Array|Array|String): input data to compress.\r\n       * - options (Object): zlib deflate options.\r\n       *\r\n       * The same as [[deflate]], but creates raw data, without wrapper\r\n       * (header and adler32 crc).\r\n       **/\n      function deflateRaw(input, options) {\n        options = options || {};\n        options.raw = true;\n        return deflate(input, options);\n      }\n\n      /**\r\n       * gzip(data[, options]) -> Uint8Array|Array|String\r\n       * - data (Uint8Array|Array|String): input data to compress.\r\n       * - options (Object): zlib deflate options.\r\n       *\r\n       * The same as [[deflate]], but create gzip wrapper instead of\r\n       * deflate one.\r\n       **/\n      function gzip(input, options) {\n        options = options || {};\n        options.gzip = true;\n        return deflate(input, options);\n      }\n      exports.Deflate = Deflate;\n      exports.deflate = deflate;\n      exports.deflateRaw = deflateRaw;\n      exports.gzip = gzip;\n    }, {\n      \"./utils/common\": 5,\n      \"./utils/strings\": 6,\n      \"./zlib/deflate\": 9,\n      \"./zlib/messages\": 10,\n      \"./zlib/zstream\": 12\n    }],\n    5: [function (require, module, exports) {\n      'use strict';\n\n      var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';\n      function _has(obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n      }\n      exports.assign = function (obj /*from1, from2, from3, ...*/) {\n        var sources = Array.prototype.slice.call(arguments, 1);\n        while (sources.length) {\n          var source = sources.shift();\n          if (!source) {\n            continue;\n          }\n          if (typeof source !== 'object') {\n            throw new TypeError(source + 'must be non-object');\n          }\n          for (var p in source) {\n            if (_has(source, p)) {\n              obj[p] = source[p];\n            }\n          }\n        }\n        return obj;\n      };\n\n      // reduce buffer size, avoiding mem copy\n      exports.shrinkBuf = function (buf, size) {\n        if (buf.length === size) {\n          return buf;\n        }\n        if (buf.subarray) {\n          return buf.subarray(0, size);\n        }\n        buf.length = size;\n        return buf;\n      };\n      var fnTyped = {\n        arraySet: function (dest, src, src_offs, len, dest_offs) {\n          if (src.subarray && dest.subarray) {\n            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n            return;\n          }\n          // Fallback to ordinary array\n          for (var i = 0; i < len; i++) {\n            dest[dest_offs + i] = src[src_offs + i];\n          }\n        },\n        // Join array of chunks to single array.\n        flattenChunks: function (chunks) {\n          var i, l, len, pos, chunk, result;\n\n          // calculate data length\n          len = 0;\n          for (i = 0, l = chunks.length; i < l; i++) {\n            len += chunks[i].length;\n          }\n\n          // join chunks\n          result = new Uint8Array(len);\n          pos = 0;\n          for (i = 0, l = chunks.length; i < l; i++) {\n            chunk = chunks[i];\n            result.set(chunk, pos);\n            pos += chunk.length;\n          }\n          return result;\n        }\n      };\n      var fnUntyped = {\n        arraySet: function (dest, src, src_offs, len, dest_offs) {\n          for (var i = 0; i < len; i++) {\n            dest[dest_offs + i] = src[src_offs + i];\n          }\n        },\n        // Join array of chunks to single array.\n        flattenChunks: function (chunks) {\n          return [].concat.apply([], chunks);\n        }\n      };\n\n      // Enable/Disable typed arrays use, for testing\n      //\n      exports.setTyped = function (on) {\n        if (on) {\n          exports.Buf8 = Uint8Array;\n          exports.Buf16 = Uint16Array;\n          exports.Buf32 = Int32Array;\n          exports.assign(exports, fnTyped);\n        } else {\n          exports.Buf8 = Array;\n          exports.Buf16 = Array;\n          exports.Buf32 = Array;\n          exports.assign(exports, fnUntyped);\n        }\n      };\n      exports.setTyped(TYPED_OK);\n    }, {}],\n    6: [function (require, module, exports) {\n      // String encode/decode helpers\n      'use strict';\n\n      var utils = require('./common');\n\n      // Quick check if we can use fast array to bin string conversion\n      //\n      // - apply(Array) can fail on Android 2.2\n      // - apply(Uint8Array) can fail on iOS 5.1 Safari\n      //\n      var STR_APPLY_OK = true;\n      var STR_APPLY_UIA_OK = true;\n      try {\n        String.fromCharCode.apply(null, [0]);\n      } catch (__) {\n        STR_APPLY_OK = false;\n      }\n      try {\n        String.fromCharCode.apply(null, new Uint8Array(1));\n      } catch (__) {\n        STR_APPLY_UIA_OK = false;\n      }\n\n      // Table with utf8 lengths (calculated by first byte of sequence)\n      // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n      // because max possible codepoint is 0x10ffff\n      var _utf8len = new utils.Buf8(256);\n      for (var q = 0; q < 256; q++) {\n        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n      }\n      _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n      // convert string to array (typed, when possible)\n      exports.string2buf = function (str) {\n        var buf,\n          c,\n          c2,\n          m_pos,\n          i,\n          str_len = str.length,\n          buf_len = 0;\n\n        // count binary size\n        for (m_pos = 0; m_pos < str_len; m_pos++) {\n          c = str.charCodeAt(m_pos);\n          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n              c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n              m_pos++;\n            }\n          }\n          buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n        }\n\n        // allocate buffer\n        buf = new utils.Buf8(buf_len);\n\n        // convert\n        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n          c = str.charCodeAt(m_pos);\n          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n              c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n              m_pos++;\n            }\n          }\n          if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n          } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n          } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n          } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n          }\n        }\n        return buf;\n      };\n\n      // Helper (used in 2 places)\n      function buf2binstring(buf, len) {\n        // On Chrome, the arguments in a function call that are allowed is `65534`.\n        // If the length of the buffer is smaller than that, we can use this optimization,\n        // otherwise we will take a slower path.\n        if (len < 65534) {\n          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {\n            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n          }\n        }\n        var result = '';\n        for (var i = 0; i < len; i++) {\n          result += String.fromCharCode(buf[i]);\n        }\n        return result;\n      }\n\n      // Convert byte array to binary string\n      exports.buf2binstring = function (buf) {\n        return buf2binstring(buf, buf.length);\n      };\n\n      // Convert binary string (typed, when possible)\n      exports.binstring2buf = function (str) {\n        var buf = new utils.Buf8(str.length);\n        for (var i = 0, len = buf.length; i < len; i++) {\n          buf[i] = str.charCodeAt(i);\n        }\n        return buf;\n      };\n\n      // convert array to string\n      exports.buf2string = function (buf, max) {\n        var i, out, c, c_len;\n        var len = max || buf.length;\n\n        // Reserve max possible length (2 words per char)\n        // NB: by unknown reasons, Array is significantly faster for\n        //     String.fromCharCode.apply than Uint16Array.\n        var utf16buf = new Array(len * 2);\n        for (out = 0, i = 0; i < len;) {\n          c = buf[i++];\n          // quick process ascii\n          if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n          }\n          c_len = _utf8len[c];\n          // skip 5 & 6 byte codes\n          if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n          }\n\n          // apply mask on first byte\n          c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n          // join the rest\n          while (c_len > 1 && i < len) {\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n          }\n\n          // terminated by end of string?\n          if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n          }\n          if (c < 0x10000) {\n            utf16buf[out++] = c;\n          } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n          }\n        }\n        return buf2binstring(utf16buf, out);\n      };\n\n      // Calculate max possible position in utf8 buffer,\n      // that will not break sequence. If that's not possible\n      // - (very small limits) return max size as is.\n      //\n      // buf[] - utf8 bytes array\n      // max   - length limit (mandatory);\n      exports.utf8border = function (buf, max) {\n        var pos;\n        max = max || buf.length;\n        if (max > buf.length) {\n          max = buf.length;\n        }\n\n        // go back from last position, until start of sequence found\n        pos = max - 1;\n        while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n          pos--;\n        }\n\n        // Very small and broken sequence,\n        // return max, because we should return something anyway.\n        if (pos < 0) {\n          return max;\n        }\n\n        // If we came to start of buffer - that means buffer is too small,\n        // return max too.\n        if (pos === 0) {\n          return max;\n        }\n        return pos + _utf8len[buf[pos]] > max ? pos : max;\n      };\n    }, {\n      \"./common\": 5\n    }],\n    7: [function (require, module, exports) {\n      'use strict';\n\n      // Note: adler32 takes 12% for level 0 and 2% for level 6.\n      // It isn't worth it to make additional optimizations as in original.\n      // Small size is preferable.\n\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n      function adler32(adler, buf, len, pos) {\n        var s1 = adler & 0xffff | 0,\n          s2 = adler >>> 16 & 0xffff | 0,\n          n = 0;\n        while (len !== 0) {\n          // Set limit ~ twice less than 5552, to keep\n          // s2 in 31-bits, because we force signed ints.\n          // in other case %= will fail.\n          n = len > 2000 ? 2000 : len;\n          len -= n;\n          do {\n            s1 = s1 + buf[pos++] | 0;\n            s2 = s2 + s1 | 0;\n          } while (--n);\n          s1 %= 65521;\n          s2 %= 65521;\n        }\n        return s1 | s2 << 16 | 0;\n      }\n      module.exports = adler32;\n    }, {}],\n    8: [function (require, module, exports) {\n      'use strict';\n\n      // Note: we can't get significant speed boost here.\n      // So write code to minimize size - no pregenerated tables\n      // and array tools dependencies.\n\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n\n      // Use ordinary array, since untyped makes no boost here\n      function makeTable() {\n        var c,\n          table = [];\n        for (var n = 0; n < 256; n++) {\n          c = n;\n          for (var k = 0; k < 8; k++) {\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n          }\n          table[n] = c;\n        }\n        return table;\n      }\n\n      // Create table on load. Just 255 signed longs. Not a problem.\n      var crcTable = makeTable();\n      function crc32(crc, buf, len, pos) {\n        var t = crcTable,\n          end = pos + len;\n        crc ^= -1;\n        for (var i = pos; i < end; i++) {\n          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n        }\n        return crc ^ -1; // >>> 0;\n      }\n\n      module.exports = crc32;\n    }, {}],\n    9: [function (require, module, exports) {\n      'use strict';\n\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n      var utils = require('../utils/common');\n      var trees = require('./trees');\n      var adler32 = require('./adler32');\n      var crc32 = require('./crc32');\n      var msg = require('./messages');\n\n      /* Public constants ==========================================================*/\n      /* ===========================================================================*/\n\n      /* Allowed flush values; see deflate() and inflate() below for details */\n      var Z_NO_FLUSH = 0;\n      var Z_PARTIAL_FLUSH = 1;\n      //var Z_SYNC_FLUSH    = 2;\n      var Z_FULL_FLUSH = 3;\n      var Z_FINISH = 4;\n      var Z_BLOCK = 5;\n      //var Z_TREES         = 6;\n\n      /* Return codes for the compression/decompression functions. Negative values\r\n       * are errors, positive values are used for special but normal events.\r\n       */\n      var Z_OK = 0;\n      var Z_STREAM_END = 1;\n      //var Z_NEED_DICT     = 2;\n      //var Z_ERRNO         = -1;\n      var Z_STREAM_ERROR = -2;\n      var Z_DATA_ERROR = -3;\n      //var Z_MEM_ERROR     = -4;\n      var Z_BUF_ERROR = -5;\n      //var Z_VERSION_ERROR = -6;\n\n      /* compression levels */\n      //var Z_NO_COMPRESSION      = 0;\n      //var Z_BEST_SPEED          = 1;\n      //var Z_BEST_COMPRESSION    = 9;\n      var Z_DEFAULT_COMPRESSION = -1;\n      var Z_FILTERED = 1;\n      var Z_HUFFMAN_ONLY = 2;\n      var Z_RLE = 3;\n      var Z_FIXED = 4;\n      var Z_DEFAULT_STRATEGY = 0;\n\n      /* Possible values of the data_type field (though see inflate()) */\n      //var Z_BINARY              = 0;\n      //var Z_TEXT                = 1;\n      //var Z_ASCII               = 1; // = Z_TEXT\n      var Z_UNKNOWN = 2;\n\n      /* The deflate compression method */\n      var Z_DEFLATED = 8;\n\n      /*============================================================================*/\n\n      var MAX_MEM_LEVEL = 9;\n      /* Maximum value for memLevel in deflateInit2 */\n      var MAX_WBITS = 15;\n      /* 32K LZ77 window */\n      var DEF_MEM_LEVEL = 8;\n      var LENGTH_CODES = 29;\n      /* number of length codes, not counting the special END_BLOCK code */\n      var LITERALS = 256;\n      /* number of literal bytes 0..255 */\n      var L_CODES = LITERALS + 1 + LENGTH_CODES;\n      /* number of Literal or Length codes, including the END_BLOCK code */\n      var D_CODES = 30;\n      /* number of distance codes */\n      var BL_CODES = 19;\n      /* number of codes used to transfer the bit lengths */\n      var HEAP_SIZE = 2 * L_CODES + 1;\n      /* maximum heap size */\n      var MAX_BITS = 15;\n      /* All codes must not exceed MAX_BITS bits */\n\n      var MIN_MATCH = 3;\n      var MAX_MATCH = 258;\n      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n      var PRESET_DICT = 0x20;\n      var INIT_STATE = 42;\n      var EXTRA_STATE = 69;\n      var NAME_STATE = 73;\n      var COMMENT_STATE = 91;\n      var HCRC_STATE = 103;\n      var BUSY_STATE = 113;\n      var FINISH_STATE = 666;\n      var BS_NEED_MORE = 1; /* block not completed, need more input or more output */\n      var BS_BLOCK_DONE = 2; /* block flush performed */\n      var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n      var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */\n\n      var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n      function err(strm, errorCode) {\n        strm.msg = msg[errorCode];\n        return errorCode;\n      }\n      function rank(f) {\n        return (f << 1) - (f > 4 ? 9 : 0);\n      }\n      function zero(buf) {\n        var len = buf.length;\n        while (--len >= 0) {\n          buf[len] = 0;\n        }\n      }\n\n      /* =========================================================================\r\n       * Flush as much pending output as possible. All deflate() output goes\r\n       * through this function so some applications may wish to modify it\r\n       * to avoid allocating a large strm->output buffer and copying into it.\r\n       * (See also read_buf()).\r\n       */\n      function flush_pending(strm) {\n        var s = strm.state;\n\n        //_tr_flush_bits(s);\n        var len = s.pending;\n        if (len > strm.avail_out) {\n          len = strm.avail_out;\n        }\n        if (len === 0) {\n          return;\n        }\n        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n        strm.next_out += len;\n        s.pending_out += len;\n        strm.total_out += len;\n        strm.avail_out -= len;\n        s.pending -= len;\n        if (s.pending === 0) {\n          s.pending_out = 0;\n        }\n      }\n      function flush_block_only(s, last) {\n        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n        s.block_start = s.strstart;\n        flush_pending(s.strm);\n      }\n      function put_byte(s, b) {\n        s.pending_buf[s.pending++] = b;\n      }\n\n      /* =========================================================================\r\n       * Put a short in the pending buffer. The 16-bit value is put in MSB order.\r\n       * IN assertion: the stream state is correct and there is enough room in\r\n       * pending_buf.\r\n       */\n      function putShortMSB(s, b) {\n        //  put_byte(s, (Byte)(b >> 8));\n        //  put_byte(s, (Byte)(b & 0xff));\n        s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n        s.pending_buf[s.pending++] = b & 0xff;\n      }\n\n      /* ===========================================================================\r\n       * Read a new buffer from the current input stream, update the adler32\r\n       * and total number of bytes read.  All deflate() input goes through\r\n       * this function so some applications may wish to modify it to avoid\r\n       * allocating a large strm->input buffer and copying from it.\r\n       * (See also flush_pending()).\r\n       */\n      function read_buf(strm, buf, start, size) {\n        var len = strm.avail_in;\n        if (len > size) {\n          len = size;\n        }\n        if (len === 0) {\n          return 0;\n        }\n        strm.avail_in -= len;\n\n        // zmemcpy(buf, strm->next_in, len);\n        utils.arraySet(buf, strm.input, strm.next_in, len, start);\n        if (strm.state.wrap === 1) {\n          strm.adler = adler32(strm.adler, buf, len, start);\n        } else if (strm.state.wrap === 2) {\n          strm.adler = crc32(strm.adler, buf, len, start);\n        }\n        strm.next_in += len;\n        strm.total_in += len;\n        return len;\n      }\n\n      /* ===========================================================================\r\n       * Set match_start to the longest match starting at the given string and\r\n       * return its length. Matches shorter or equal to prev_length are discarded,\r\n       * in which case the result is equal to prev_length and match_start is\r\n       * garbage.\r\n       * IN assertions: cur_match is the head of the hash chain for the current\r\n       *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\r\n       * OUT assertion: the match length is not greater than s->lookahead.\r\n       */\n      function longest_match(s, cur_match) {\n        var chain_length = s.max_chain_length; /* max hash chain length */\n        var scan = s.strstart; /* current string */\n        var match; /* matched string */\n        var len; /* length of current match */\n        var best_len = s.prev_length; /* best match length so far */\n        var nice_match = s.nice_match; /* stop if match long enough */\n        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;\n\n        var _win = s.window; // shortcut\n\n        var wmask = s.w_mask;\n        var prev = s.prev;\n\n        /* Stop when cur_match becomes <= limit. To simplify the code,\r\n         * we prevent matches with the string of window index 0.\r\n         */\n\n        var strend = s.strstart + MAX_MATCH;\n        var scan_end1 = _win[scan + best_len - 1];\n        var scan_end = _win[scan + best_len];\n\n        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\r\n         * It is easy to get rid of this optimization if necessary.\r\n         */\n        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n        /* Do not waste too much time if we already have a good match: */\n        if (s.prev_length >= s.good_match) {\n          chain_length >>= 2;\n        }\n        /* Do not look for matches beyond the end of the input. This is necessary\r\n         * to make deflate deterministic.\r\n         */\n        if (nice_match > s.lookahead) {\n          nice_match = s.lookahead;\n        }\n\n        // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n        do {\n          // Assert(cur_match < s->strstart, \"no future\");\n          match = cur_match;\n\n          /* Skip to next match if the match length cannot increase\r\n           * or if the match length is less than 2.  Note that the checks below\r\n           * for insufficient lookahead only occur occasionally for performance\r\n           * reasons.  Therefore uninitialized memory will be accessed, and\r\n           * conditional jumps will be made that depend on those values.\r\n           * However the length of the match is limited to the lookahead, so\r\n           * the output of deflate is not affected by the uninitialized values.\r\n           */\n\n          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n            continue;\n          }\n\n          /* The check at best_len-1 can be removed because it will be made\r\n           * again later. (This heuristic is not always a win.)\r\n           * It is not necessary to compare scan[2] and match[2] since they\r\n           * are always equal when the other bytes match, given that\r\n           * the hash keys are equal and that HASH_BITS >= 8.\r\n           */\n          scan += 2;\n          match++;\n          // Assert(*scan == *match, \"match[2]?\");\n\n          /* We check for insufficient lookahead only every 8th comparison;\r\n           * the 256th check will be made at strstart+258.\r\n           */\n          do {\n            /*jshint noempty:false*/\n          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n\n          // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n          len = MAX_MATCH - (strend - scan);\n          scan = strend - MAX_MATCH;\n          if (len > best_len) {\n            s.match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) {\n              break;\n            }\n            scan_end1 = _win[scan + best_len - 1];\n            scan_end = _win[scan + best_len];\n          }\n        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n        if (best_len <= s.lookahead) {\n          return best_len;\n        }\n        return s.lookahead;\n      }\n\n      /* ===========================================================================\r\n       * Fill the window when the lookahead becomes insufficient.\r\n       * Updates strstart and lookahead.\r\n       *\r\n       * IN assertion: lookahead < MIN_LOOKAHEAD\r\n       * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\r\n       *    At least one byte has been read, or avail_in == 0; reads are\r\n       *    performed for at least two bytes (required for the zip translate_eol\r\n       *    option -- not supported here).\r\n       */\n      function fill_window(s) {\n        var _w_size = s.w_size;\n        var p, n, m, more, str;\n\n        //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n        do {\n          more = s.window_size - s.lookahead - s.strstart;\n\n          // JS ints have 32 bit, block below not needed\n          /* Deal with !@#$% 64K limit: */\n          //if (sizeof(int) <= 2) {\n          //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n          //        more = wsize;\n          //\n          //  } else if (more == (unsigned)(-1)) {\n          //        /* Very unlikely, but possible on 16 bit machine if\n          //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n          //         */\n          //        more--;\n          //    }\n          //}\n\n          /* If the window is almost full and there is insufficient lookahead,\r\n           * move the upper half to the lower one to make room in the upper half.\r\n           */\n          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n            s.match_start -= _w_size;\n            s.strstart -= _w_size;\n            /* we now have strstart >= MAX_DIST */\n            s.block_start -= _w_size;\n\n            /* Slide the hash table (could be avoided with 32 bit values\r\n             at the expense of memory usage). We slide even when level == 0\r\n             to keep the hash table consistent if we switch back to level > 0\r\n             later. (Using level 0 permanently is not an optimal usage of\r\n             zlib, so we don't care about this pathological case.)\r\n             */\n\n            n = s.hash_size;\n            p = n;\n            do {\n              m = s.head[--p];\n              s.head[p] = m >= _w_size ? m - _w_size : 0;\n            } while (--n);\n            n = _w_size;\n            p = n;\n            do {\n              m = s.prev[--p];\n              s.prev[p] = m >= _w_size ? m - _w_size : 0;\n              /* If n is not on any hash chain, prev[n] is garbage but\r\n               * its value will never be used.\r\n               */\n            } while (--n);\n            more += _w_size;\n          }\n          if (s.strm.avail_in === 0) {\n            break;\n          }\n\n          /* If there was no sliding:\r\n           *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\r\n           *    more == window_size - lookahead - strstart\r\n           * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\r\n           * => more >= window_size - 2*WSIZE + 2\r\n           * In the BIG_MEM or MMAP case (not yet supported),\r\n           *   window_size == input_size + MIN_LOOKAHEAD  &&\r\n           *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\r\n           * Otherwise, window_size == 2*WSIZE so more >= 2.\r\n           * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\r\n           */\n          //Assert(more >= 2, \"more < 2\");\n          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n          s.lookahead += n;\n\n          /* Initialize the hash value now that we have some input: */\n          if (s.lookahead + s.insert >= MIN_MATCH) {\n            str = s.strstart - s.insert;\n            s.ins_h = s.window[str];\n\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //        Call update_hash() MIN_MATCH-3 more times\n            //#endif\n            while (s.insert) {\n              /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n              s.prev[str & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = str;\n              str++;\n              s.insert--;\n              if (s.lookahead + s.insert < MIN_MATCH) {\n                break;\n              }\n            }\n          }\n          /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\r\n           * but this is not important since only literal bytes will be emitted.\r\n           */\n        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n        /* If the WIN_INIT bytes after the end of the current data have never been\r\n         * written, then zero those bytes in order to avoid memory check reports of\r\n         * the use of uninitialized (or uninitialised as Julian writes) bytes by\r\n         * the longest match routines.  Update the high water mark for the next\r\n         * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\r\n         * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\r\n         */\n        //  if (s.high_water < s.window_size) {\n        //    var curr = s.strstart + s.lookahead;\n        //    var init = 0;\n        //\n        //    if (s.high_water < curr) {\n        //      /* Previous high water mark below current data -- zero WIN_INIT\n        //       * bytes or up to end of window, whichever is less.\n        //       */\n        //      init = s.window_size - curr;\n        //      if (init > WIN_INIT)\n        //        init = WIN_INIT;\n        //      zmemzero(s->window + curr, (unsigned)init);\n        //      s->high_water = curr + init;\n        //    }\n        //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n        //      /* High water mark at or above current data, but below current data\n        //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n        //       * to end of window, whichever is less.\n        //       */\n        //      init = (ulg)curr + WIN_INIT - s->high_water;\n        //      if (init > s->window_size - s->high_water)\n        //        init = s->window_size - s->high_water;\n        //      zmemzero(s->window + s->high_water, (unsigned)init);\n        //      s->high_water += init;\n        //    }\n        //  }\n        //\n        //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n        //    \"not enough room for search\");\n      }\n\n      /* ===========================================================================\r\n       * Copy without compression as much as possible from the input stream, return\r\n       * the current block state.\r\n       * This function does not insert new strings in the dictionary since\r\n       * uncompressible data is probably not useful. This function is used\r\n       * only for the level=0 compression option.\r\n       * NOTE: this function should be optimized to avoid extra copying from\r\n       * window to pending_buf.\r\n       */\n      function deflate_stored(s, flush) {\n        /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\r\n         * to pending_buf_size, and each stored block has a 5 byte header:\r\n         */\n        var max_block_size = 0xffff;\n        if (max_block_size > s.pending_buf_size - 5) {\n          max_block_size = s.pending_buf_size - 5;\n        }\n\n        /* Copy as much as possible from input to output: */\n        for (;;) {\n          /* Fill the window as much as possible: */\n          if (s.lookahead <= 1) {\n            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n            //  s->block_start >= (long)s->w_size, \"slide too late\");\n            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n            //        s.block_start >= s.w_size)) {\n            //        throw  new Error(\"slide too late\");\n            //      }\n\n            fill_window(s);\n            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n              break;\n            }\n            /* flush the current block */\n          }\n          //Assert(s->block_start >= 0L, \"block gone\");\n          //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n          s.strstart += s.lookahead;\n          s.lookahead = 0;\n\n          /* Emit a stored block if pending_buf will be full: */\n          var max_start = s.block_start + max_block_size;\n          if (s.strstart === 0 || s.strstart >= max_start) {\n            /* strstart == 0 is possible when wraparound on 16-bit machine */\n            s.lookahead = s.strstart - max_start;\n            s.strstart = max_start;\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n          }\n          /* Flush if we may have to slide, otherwise block_start may become\r\n           * negative and the data will be gone:\r\n           */\n          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n          }\n        }\n\n        s.insert = 0;\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n          return BS_FINISH_DONE;\n        }\n        if (s.strstart > s.block_start) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n        return BS_NEED_MORE;\n      }\n\n      /* ===========================================================================\r\n       * Compress as much as possible from the input stream, return the current\r\n       * block state.\r\n       * This function does not perform lazy evaluation of matches and inserts\r\n       * new strings in the dictionary only for unmatched strings or for short\r\n       * matches. It is used only for the fast compression options.\r\n       */\n      function deflate_fast(s, flush) {\n        var hash_head; /* head of the hash chain */\n        var bflush; /* set if current block must be flushed */\n\n        for (;;) {\n          /* Make sure that we always have enough lookahead, except\r\n           * at the end of the input file. We need MAX_MATCH bytes\r\n           * for the next match, plus MIN_MATCH bytes to insert the\r\n           * string following the next match.\r\n           */\n          if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n              break; /* flush the current block */\n            }\n          }\n\n          /* Insert the string window[strstart .. strstart+2] in the\r\n           * dictionary, and set hash_head to the head of the hash chain:\r\n           */\n          hash_head = 0 /*NIL*/;\n          if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n          }\n\n          /* Find the longest match, discarding those <= prev_length.\r\n           * At this point we have always match_length < MIN_MATCH\r\n           */\n          if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\r\n             * of window index 0 (in particular we have to avoid a match\r\n             * of the string with itself at the start of the input file).\r\n             */\n            s.match_length = longest_match(s, hash_head);\n            /* longest_match() sets match_start */\n          }\n\n          if (s.match_length >= MIN_MATCH) {\n            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n            /*** _tr_tally_dist(s, s.strstart - s.match_start,\r\n                           s.match_length - MIN_MATCH, bflush); ***/\n            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n\n            /* Insert new strings in the hash table only if the match length\r\n             * is not too large. This saves time but degrades compression.\r\n             */\n            if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n              s.match_length--; /* string at strstart already in table */\n              do {\n                s.strstart++;\n                /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = s.strstart;\n                /***/\n                /* strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n                 * always MIN_MATCH bytes ahead.\r\n                 */\n              } while (--s.match_length !== 0);\n              s.strstart++;\n            } else {\n              s.strstart += s.match_length;\n              s.match_length = 0;\n              s.ins_h = s.window[s.strstart];\n              /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n              //#if MIN_MATCH != 3\n              //                Call UPDATE_HASH() MIN_MATCH-3 more times\n              //#endif\n              /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\r\n               * matter since it will be recomputed at next deflate call.\r\n               */\n            }\n          } else {\n            /* No match, output a literal byte */\n            //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n          }\n          if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n          }\n        }\n\n        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n          return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n        return BS_BLOCK_DONE;\n      }\n\n      /* ===========================================================================\r\n       * Same as above, but achieves better compression. We use a lazy\r\n       * evaluation for matches: a match is finally adopted only if there is\r\n       * no better match at the next window position.\r\n       */\n      function deflate_slow(s, flush) {\n        var hash_head; /* head of hash chain */\n        var bflush; /* set if current block must be flushed */\n\n        var max_insert;\n\n        /* Process the input block. */\n        for (;;) {\n          /* Make sure that we always have enough lookahead, except\r\n           * at the end of the input file. We need MAX_MATCH bytes\r\n           * for the next match, plus MIN_MATCH bytes to insert the\r\n           * string following the next match.\r\n           */\n          if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n              break;\n            } /* flush the current block */\n          }\n\n          /* Insert the string window[strstart .. strstart+2] in the\r\n           * dictionary, and set hash_head to the head of the hash chain:\r\n           */\n          hash_head = 0 /*NIL*/;\n          if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n          }\n\n          /* Find the longest match, discarding those <= prev_length.\r\n           */\n          s.prev_length = s.match_length;\n          s.prev_match = s.match_start;\n          s.match_length = MIN_MATCH - 1;\n          if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {\n            /* To simplify the code, we prevent matches with the string\r\n             * of window index 0 (in particular we have to avoid a match\r\n             * of the string with itself at the start of the input file).\r\n             */\n            s.match_length = longest_match(s, hash_head);\n            /* longest_match() sets match_start */\n\n            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {\n              /* If prev_match is also MIN_MATCH, match_start is garbage\r\n               * but we will ignore the current match anyway.\r\n               */\n              s.match_length = MIN_MATCH - 1;\n            }\n          }\n          /* If there was a match at the previous step and the current\r\n           * match is not better, output the previous match:\r\n           */\n          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n            max_insert = s.strstart + s.lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n\n            //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\r\n                           s.prev_length - MIN_MATCH, bflush);***/\n            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n            /* Insert in hash table all strings up to the end of the match.\r\n             * strstart-1 and strstart are already inserted. If there is not\r\n             * enough lookahead, the last two strings are not inserted in\r\n             * the hash table.\r\n             */\n            s.lookahead -= s.prev_length - 1;\n            s.prev_length -= 2;\n            do {\n              if (++s.strstart <= max_insert) {\n                /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = s.strstart;\n                /***/\n              }\n            } while (--s.prev_length !== 0);\n            s.match_available = 0;\n            s.match_length = MIN_MATCH - 1;\n            s.strstart++;\n            if (bflush) {\n              /*** FLUSH_BLOCK(s, 0); ***/\n              flush_block_only(s, false);\n              if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n              }\n              /***/\n            }\n          } else if (s.match_available) {\n            /* If there was no match at the previous position, output a\r\n             * single literal. If there was a match but the current match\r\n             * is longer, truncate the previous match to a single literal.\r\n             */\n            //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n            if (bflush) {\n              /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n              flush_block_only(s, false);\n              /***/\n            }\n\n            s.strstart++;\n            s.lookahead--;\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n          } else {\n            /* There is no previous match to compare with, wait for\r\n             * the next step to decide.\r\n             */\n            s.match_available = 1;\n            s.strstart++;\n            s.lookahead--;\n          }\n        }\n        //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n        if (s.match_available) {\n          //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n          s.match_available = 0;\n        }\n        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n          return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n        return BS_BLOCK_DONE;\n      }\n\n      /* ===========================================================================\r\n       * For Z_RLE, simply look for runs of bytes, generate matches only of distance\r\n       * one.  Do not maintain a hash table.  (It will be regenerated if this run of\r\n       * deflate switches away from Z_RLE.)\r\n       */\n      function deflate_rle(s, flush) {\n        var bflush; /* set if current block must be flushed */\n        var prev; /* byte at distance one to match */\n        var scan, strend; /* scan goes up to strend for length of run */\n\n        var _win = s.window;\n        for (;;) {\n          /* Make sure that we always have enough lookahead, except\r\n           * at the end of the input file. We need MAX_MATCH bytes\r\n           * for the longest run, plus one for the unrolled loop.\r\n           */\n          if (s.lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n              break;\n            } /* flush the current block */\n          }\n\n          /* See how many times the previous byte repeats */\n          s.match_length = 0;\n          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n            scan = s.strstart - 1;\n            prev = _win[scan];\n            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n              strend = s.strstart + MAX_MATCH;\n              do {\n                /*jshint noempty:false*/\n              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n              s.match_length = MAX_MATCH - (strend - scan);\n              if (s.match_length > s.lookahead) {\n                s.match_length = s.lookahead;\n              }\n            }\n            //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n          }\n\n          /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n          if (s.match_length >= MIN_MATCH) {\n            //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            s.strstart += s.match_length;\n            s.match_length = 0;\n          } else {\n            /* No match, output a literal byte */\n            //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n          }\n          if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n          }\n        }\n\n        s.insert = 0;\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n          return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n        return BS_BLOCK_DONE;\n      }\n\n      /* ===========================================================================\r\n       * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\r\n       * (It will be regenerated if this run of deflate switches away from Huffman.)\r\n       */\n      function deflate_huff(s, flush) {\n        var bflush; /* set if current block must be flushed */\n\n        for (;;) {\n          /* Make sure that we have a literal to write. */\n          if (s.lookahead === 0) {\n            fill_window(s);\n            if (s.lookahead === 0) {\n              if (flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n              }\n              break; /* flush the current block */\n            }\n          }\n\n          /* Output a literal byte */\n          s.match_length = 0;\n          //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n          if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n          }\n        }\n\n        s.insert = 0;\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n          return BS_FINISH_DONE;\n        }\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n        return BS_BLOCK_DONE;\n      }\n\n      /* Values for max_lazy_match, good_match and max_chain_length, depending on\r\n       * the desired pack level (0..9). The values given below have been tuned to\r\n       * exclude worst case performance for pathological files. Better values may be\r\n       * found for specific files.\r\n       */\n      function Config(good_length, max_lazy, nice_length, max_chain, func) {\n        this.good_length = good_length;\n        this.max_lazy = max_lazy;\n        this.nice_length = nice_length;\n        this.max_chain = max_chain;\n        this.func = func;\n      }\n      var configuration_table;\n      configuration_table = [/*      good lazy nice chain */\n      new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */\n      new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */\n      new Config(4, 5, 16, 8, deflate_fast), /* 2 */\n      new Config(4, 6, 32, 32, deflate_fast), /* 3 */\n\n      new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */\n      new Config(8, 16, 32, 32, deflate_slow), /* 5 */\n      new Config(8, 16, 128, 128, deflate_slow), /* 6 */\n      new Config(8, 32, 128, 256, deflate_slow), /* 7 */\n      new Config(32, 128, 258, 1024, deflate_slow), /* 8 */\n      new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */];\n\n      /* ===========================================================================\r\n       * Initialize the \"longest match\" routines for a new zlib stream\r\n       */\n      function lm_init(s) {\n        s.window_size = 2 * s.w_size;\n\n        /*** CLEAR_HASH(s); ***/\n        zero(s.head); // Fill with NIL (= 0);\n\n        /* Set the default configuration parameters:\r\n         */\n        s.max_lazy_match = configuration_table[s.level].max_lazy;\n        s.good_match = configuration_table[s.level].good_length;\n        s.nice_match = configuration_table[s.level].nice_length;\n        s.max_chain_length = configuration_table[s.level].max_chain;\n        s.strstart = 0;\n        s.block_start = 0;\n        s.lookahead = 0;\n        s.insert = 0;\n        s.match_length = s.prev_length = MIN_MATCH - 1;\n        s.match_available = 0;\n        s.ins_h = 0;\n      }\n      function DeflateState() {\n        this.strm = null; /* pointer back to this zlib stream */\n        this.status = 0; /* as the name implies */\n        this.pending_buf = null; /* output still pending */\n        this.pending_buf_size = 0; /* size of pending_buf */\n        this.pending_out = 0; /* next pending byte to output to the stream */\n        this.pending = 0; /* nb of bytes in the pending buffer */\n        this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */\n        this.gzhead = null; /* gzip header information to write */\n        this.gzindex = 0; /* where in extra, name, or comment */\n        this.method = Z_DEFLATED; /* can only be DEFLATED */\n        this.last_flush = -1; /* value of flush param for previous deflate call */\n\n        this.w_size = 0; /* LZ77 window size (32K by default) */\n        this.w_bits = 0; /* log2(w_size)  (8..16) */\n        this.w_mask = 0; /* w_size - 1 */\n\n        this.window = null;\n        /* Sliding window. Input bytes are read into the second half of the window,\r\n         * and move to the first half later to keep a dictionary of at least wSize\r\n         * bytes. With this organization, matches are limited to a distance of\r\n         * wSize-MAX_MATCH bytes, but this ensures that IO is always\r\n         * performed with a length multiple of the block size.\r\n         */\n\n        this.window_size = 0;\n        /* Actual size of window: 2*wSize, except when the user input buffer\r\n         * is directly used as sliding window.\r\n         */\n\n        this.prev = null;\n        /* Link to older string with same hash index. To limit the size of this\r\n         * array to 64K, this link is maintained only for the last 32K strings.\r\n         * An index in this array is thus a window index modulo 32K.\r\n         */\n\n        this.head = null; /* Heads of the hash chains or NIL. */\n\n        this.ins_h = 0; /* hash index of string to be inserted */\n        this.hash_size = 0; /* number of elements in hash table */\n        this.hash_bits = 0; /* log2(hash_size) */\n        this.hash_mask = 0; /* hash_size-1 */\n\n        this.hash_shift = 0;\n        /* Number of bits by which ins_h must be shifted at each input\r\n         * step. It must be such that after MIN_MATCH steps, the oldest\r\n         * byte no longer takes part in the hash key, that is:\r\n         *   hash_shift * MIN_MATCH >= hash_bits\r\n         */\n\n        this.block_start = 0;\n        /* Window position at the beginning of the current output block. Gets\r\n         * negative when the window is moved backwards.\r\n         */\n\n        this.match_length = 0; /* length of best match */\n        this.prev_match = 0; /* previous match */\n        this.match_available = 0; /* set if previous match exists */\n        this.strstart = 0; /* start of string to insert */\n        this.match_start = 0; /* start of matching string */\n        this.lookahead = 0; /* number of valid bytes ahead in window */\n\n        this.prev_length = 0;\n        /* Length of the best match at previous step. Matches not greater than this\r\n         * are discarded. This is used in the lazy match evaluation.\r\n         */\n\n        this.max_chain_length = 0;\n        /* To speed up deflation, hash chains are never searched beyond this\r\n         * length.  A higher limit improves compression ratio but degrades the\r\n         * speed.\r\n         */\n\n        this.max_lazy_match = 0;\n        /* Attempt to find a better match only when the current match is strictly\r\n         * smaller than this value. This mechanism is used only for compression\r\n         * levels >= 4.\r\n         */\n        // That's alias to max_lazy_match, don't use directly\n        //this.max_insert_length = 0;\n        /* Insert new strings in the hash table only if the match length is not\r\n         * greater than this length. This saves time but degrades compression.\r\n         * max_insert_length is used only for compression levels <= 3.\r\n         */\n\n        this.level = 0; /* compression level (1..9) */\n        this.strategy = 0; /* favor or force Huffman coding*/\n\n        this.good_match = 0;\n        /* Use a faster search when the previous match is longer than this */\n\n        this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n        /* used by trees.c: */\n\n        /* Didn't use ct_data typedef below to suppress compiler warning */\n\n        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n        // Use flat array of DOUBLE size, with interleaved fata,\n        // because JS does not support effective\n        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n        zero(this.dyn_ltree);\n        zero(this.dyn_dtree);\n        zero(this.bl_tree);\n        this.l_desc = null; /* desc. for literal tree */\n        this.d_desc = null; /* desc. for distance tree */\n        this.bl_desc = null; /* desc. for bit length tree */\n\n        //ush bl_count[MAX_BITS+1];\n        this.bl_count = new utils.Buf16(MAX_BITS + 1);\n        /* number of codes at each bit length for an optimal tree */\n\n        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n        this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */\n        zero(this.heap);\n        this.heap_len = 0; /* number of elements in the heap */\n        this.heap_max = 0; /* element of largest frequency */\n        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\r\n         * The same heap array is used to build all trees.\r\n         */\n\n        this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n        zero(this.depth);\n        /* Depth of each subtree used as tie breaker for trees of equal frequency\r\n         */\n\n        this.l_buf = 0; /* buffer index for literals or lengths */\n\n        this.lit_bufsize = 0;\n        /* Size of match buffer for literals/lengths.  There are 4 reasons for\r\n         * limiting lit_bufsize to 64K:\r\n         *   - frequencies can be kept in 16 bit counters\r\n         *   - if compression is not successful for the first block, all input\r\n         *     data is still in the window so we can still emit a stored block even\r\n         *     when input comes from standard input.  (This can also be done for\r\n         *     all blocks if lit_bufsize is not greater than 32K.)\r\n         *   - if compression is not successful for a file smaller than 64K, we can\r\n         *     even emit a stored file instead of a stored block (saving 5 bytes).\r\n         *     This is applicable only for zip (not gzip or zlib).\r\n         *   - creating new Huffman trees less frequently may not provide fast\r\n         *     adaptation to changes in the input data statistics. (Take for\r\n         *     example a binary file with poorly compressible code followed by\r\n         *     a highly compressible string table.) Smaller buffer sizes give\r\n         *     fast adaptation but have of course the overhead of transmitting\r\n         *     trees more frequently.\r\n         *   - I can't count above 4\r\n         */\n\n        this.last_lit = 0; /* running index in l_buf */\n\n        this.d_buf = 0;\n        /* Buffer index for distances. To simplify the code, d_buf and l_buf have\r\n         * the same number of elements. To use different lengths, an extra flag\r\n         * array would be necessary.\r\n         */\n\n        this.opt_len = 0; /* bit length of current block with optimal trees */\n        this.static_len = 0; /* bit length of current block with static trees */\n        this.matches = 0; /* number of string matches in current block */\n        this.insert = 0; /* bytes at end of window left to insert */\n\n        this.bi_buf = 0;\n        /* Output buffer. bits are inserted starting at the bottom (least\r\n         * significant bits).\r\n         */\n        this.bi_valid = 0;\n        /* Number of valid bits in bi_buf.  All bits above the last valid bit\r\n         * are always zero.\r\n         */\n\n        // Used for window memory init. We safely ignore it for JS. That makes\n        // sense only for pointers and memory check tools.\n        //this.high_water = 0;\n        /* High water mark offset in window for initialized bytes -- bytes above\r\n         * this are set to zero in order to avoid memory check warnings when\r\n         * longest match routines access bytes past the input.  This is then\r\n         * updated to the new high water mark.\r\n         */\n      }\n\n      function deflateResetKeep(strm) {\n        var s;\n        if (!strm || !strm.state) {\n          return err(strm, Z_STREAM_ERROR);\n        }\n        strm.total_in = strm.total_out = 0;\n        strm.data_type = Z_UNKNOWN;\n        s = strm.state;\n        s.pending = 0;\n        s.pending_out = 0;\n        if (s.wrap < 0) {\n          s.wrap = -s.wrap;\n          /* was made negative by deflate(..., Z_FINISH); */\n        }\n\n        s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n        strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n        : 1; // adler32(0, Z_NULL, 0)\n        s.last_flush = Z_NO_FLUSH;\n        trees._tr_init(s);\n        return Z_OK;\n      }\n      function deflateReset(strm) {\n        var ret = deflateResetKeep(strm);\n        if (ret === Z_OK) {\n          lm_init(strm.state);\n        }\n        return ret;\n      }\n      function deflateSetHeader(strm, head) {\n        if (!strm || !strm.state) {\n          return Z_STREAM_ERROR;\n        }\n        if (strm.state.wrap !== 2) {\n          return Z_STREAM_ERROR;\n        }\n        strm.state.gzhead = head;\n        return Z_OK;\n      }\n      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n        if (!strm) {\n          // === Z_NULL\n          return Z_STREAM_ERROR;\n        }\n        var wrap = 1;\n        if (level === Z_DEFAULT_COMPRESSION) {\n          level = 6;\n        }\n        if (windowBits < 0) {\n          /* suppress zlib wrapper */\n          wrap = 0;\n          windowBits = -windowBits;\n        } else if (windowBits > 15) {\n          wrap = 2; /* write gzip wrapper instead */\n          windowBits -= 16;\n        }\n        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n          return err(strm, Z_STREAM_ERROR);\n        }\n        if (windowBits === 8) {\n          windowBits = 9;\n        }\n        /* until 256-byte window bug fixed */\n\n        var s = new DeflateState();\n        strm.state = s;\n        s.strm = strm;\n        s.wrap = wrap;\n        s.gzhead = null;\n        s.w_bits = windowBits;\n        s.w_size = 1 << s.w_bits;\n        s.w_mask = s.w_size - 1;\n        s.hash_bits = memLevel + 7;\n        s.hash_size = 1 << s.hash_bits;\n        s.hash_mask = s.hash_size - 1;\n        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n        s.window = new utils.Buf8(s.w_size * 2);\n        s.head = new utils.Buf16(s.hash_size);\n        s.prev = new utils.Buf16(s.w_size);\n\n        // Don't need mem init magic for JS.\n        //s.high_water = 0;  /* nothing written to s->window yet */\n\n        s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */\n\n        s.pending_buf_size = s.lit_bufsize * 4;\n\n        //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n        //s->pending_buf = (uchf *) overlay;\n        s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n        // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n        //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n        s.d_buf = 1 * s.lit_bufsize;\n\n        //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n        s.l_buf = (1 + 2) * s.lit_bufsize;\n        s.level = level;\n        s.strategy = strategy;\n        s.method = method;\n        return deflateReset(strm);\n      }\n      function deflateInit(strm, level) {\n        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n      }\n      function deflate(strm, flush) {\n        var old_flush, s;\n        var beg, val; // for gzip header write only\n\n        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n        }\n        s = strm.state;\n        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n        }\n        s.strm = strm; /* just in case */\n        old_flush = s.last_flush;\n        s.last_flush = flush;\n\n        /* Write the header */\n        if (s.status === INIT_STATE) {\n          if (s.wrap === 2) {\n            // GZIP header\n            strm.adler = 0; //crc32(0L, Z_NULL, 0);\n            put_byte(s, 31);\n            put_byte(s, 139);\n            put_byte(s, 8);\n            if (!s.gzhead) {\n              // s->gzhead == Z_NULL\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n              put_byte(s, OS_CODE);\n              s.status = BUSY_STATE;\n            } else {\n              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n              put_byte(s, s.gzhead.time & 0xff);\n              put_byte(s, s.gzhead.time >> 8 & 0xff);\n              put_byte(s, s.gzhead.time >> 16 & 0xff);\n              put_byte(s, s.gzhead.time >> 24 & 0xff);\n              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n              put_byte(s, s.gzhead.os & 0xff);\n              if (s.gzhead.extra && s.gzhead.extra.length) {\n                put_byte(s, s.gzhead.extra.length & 0xff);\n                put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n              }\n              if (s.gzhead.hcrc) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n              }\n              s.gzindex = 0;\n              s.status = EXTRA_STATE;\n            }\n          } else\n            // DEFLATE header\n            {\n              var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n              var level_flags = -1;\n              if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                level_flags = 0;\n              } else if (s.level < 6) {\n                level_flags = 1;\n              } else if (s.level === 6) {\n                level_flags = 2;\n              } else {\n                level_flags = 3;\n              }\n              header |= level_flags << 6;\n              if (s.strstart !== 0) {\n                header |= PRESET_DICT;\n              }\n              header += 31 - header % 31;\n              s.status = BUSY_STATE;\n              putShortMSB(s, header);\n\n              /* Save the adler32 of the preset dictionary: */\n              if (s.strstart !== 0) {\n                putShortMSB(s, strm.adler >>> 16);\n                putShortMSB(s, strm.adler & 0xffff);\n              }\n              strm.adler = 1; // adler32(0L, Z_NULL, 0);\n            }\n        }\n\n        //#ifdef GZIP\n        if (s.status === EXTRA_STATE) {\n          if (s.gzhead.extra /* != Z_NULL*/) {\n            beg = s.pending; /* start of bytes to update crc */\n\n            while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n              if (s.pending === s.pending_buf_size) {\n                if (s.gzhead.hcrc && s.pending > beg) {\n                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                }\n                flush_pending(strm);\n                beg = s.pending;\n                if (s.pending === s.pending_buf_size) {\n                  break;\n                }\n              }\n              put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n              s.gzindex++;\n            }\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (s.gzindex === s.gzhead.extra.length) {\n              s.gzindex = 0;\n              s.status = NAME_STATE;\n            }\n          } else {\n            s.status = NAME_STATE;\n          }\n        }\n        if (s.status === NAME_STATE) {\n          if (s.gzhead.name /* != Z_NULL*/) {\n            beg = s.pending; /* start of bytes to update crc */\n            //int val;\n\n            do {\n              if (s.pending === s.pending_buf_size) {\n                if (s.gzhead.hcrc && s.pending > beg) {\n                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                }\n                flush_pending(strm);\n                beg = s.pending;\n                if (s.pending === s.pending_buf_size) {\n                  val = 1;\n                  break;\n                }\n              }\n              // JS specific: little magic to add zero terminator to end of string\n              if (s.gzindex < s.gzhead.name.length) {\n                val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n              } else {\n                val = 0;\n              }\n              put_byte(s, val);\n            } while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n              s.gzindex = 0;\n              s.status = COMMENT_STATE;\n            }\n          } else {\n            s.status = COMMENT_STATE;\n          }\n        }\n        if (s.status === COMMENT_STATE) {\n          if (s.gzhead.comment /* != Z_NULL*/) {\n            beg = s.pending; /* start of bytes to update crc */\n            //int val;\n\n            do {\n              if (s.pending === s.pending_buf_size) {\n                if (s.gzhead.hcrc && s.pending > beg) {\n                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                }\n                flush_pending(strm);\n                beg = s.pending;\n                if (s.pending === s.pending_buf_size) {\n                  val = 1;\n                  break;\n                }\n              }\n              // JS specific: little magic to add zero terminator to end of string\n              if (s.gzindex < s.gzhead.comment.length) {\n                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n              } else {\n                val = 0;\n              }\n              put_byte(s, val);\n            } while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n              s.status = HCRC_STATE;\n            }\n          } else {\n            s.status = HCRC_STATE;\n          }\n        }\n        if (s.status === HCRC_STATE) {\n          if (s.gzhead.hcrc) {\n            if (s.pending + 2 > s.pending_buf_size) {\n              flush_pending(strm);\n            }\n            if (s.pending + 2 <= s.pending_buf_size) {\n              put_byte(s, strm.adler & 0xff);\n              put_byte(s, strm.adler >> 8 & 0xff);\n              strm.adler = 0; //crc32(0L, Z_NULL, 0);\n              s.status = BUSY_STATE;\n            }\n          } else {\n            s.status = BUSY_STATE;\n          }\n        }\n        //#endif\n\n        /* Flush as much pending output as possible */\n        if (s.pending !== 0) {\n          flush_pending(strm);\n          if (strm.avail_out === 0) {\n            /* Since avail_out is 0, deflate will be called again with\r\n             * more output space, but possibly with both pending and\r\n             * avail_in equal to zero. There won't be anything to do,\r\n             * but this is not an error situation so make sure we\r\n             * return OK instead of BUF_ERROR at next call of deflate:\r\n             */\n            s.last_flush = -1;\n            return Z_OK;\n          }\n\n          /* Make sure there is something to do and avoid duplicate consecutive\r\n           * flushes. For repeated and useless calls with Z_FINISH, we keep\r\n           * returning Z_STREAM_END instead of Z_BUF_ERROR.\r\n           */\n        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n          return err(strm, Z_BUF_ERROR);\n        }\n\n        /* User must not provide more input after the first FINISH: */\n        if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n          return err(strm, Z_BUF_ERROR);\n        }\n\n        /* Start a new block or continue the current one.\r\n         */\n        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n            s.status = FINISH_STATE;\n          }\n          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n            if (strm.avail_out === 0) {\n              s.last_flush = -1;\n              /* avoid BUF_ERROR next call, see above */\n            }\n\n            return Z_OK;\n            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\r\n             * of deflate should use the same flush parameter to make sure\r\n             * that the flush is complete. So we don't have to output an\r\n             * empty block here, this will be done at next call. This also\r\n             * ensures that for a very small output buffer, we emit at most\r\n             * one empty block.\r\n             */\n          }\n\n          if (bstate === BS_BLOCK_DONE) {\n            if (flush === Z_PARTIAL_FLUSH) {\n              trees._tr_align(s);\n            } else if (flush !== Z_BLOCK) {\n              /* FULL_FLUSH or SYNC_FLUSH */\n\n              trees._tr_stored_block(s, 0, 0, false);\n              /* For a full flush, this empty block will be recognized\r\n               * as a special marker by inflate_sync().\r\n               */\n              if (flush === Z_FULL_FLUSH) {\n                /*** CLEAR_HASH(s); ***/ /* forget history */\n                zero(s.head); // Fill with NIL (= 0);\n\n                if (s.lookahead === 0) {\n                  s.strstart = 0;\n                  s.block_start = 0;\n                  s.insert = 0;\n                }\n              }\n            }\n            flush_pending(strm);\n            if (strm.avail_out === 0) {\n              s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n              return Z_OK;\n            }\n          }\n        }\n        //Assert(strm->avail_out > 0, \"bug2\");\n        //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n        if (flush !== Z_FINISH) {\n          return Z_OK;\n        }\n        if (s.wrap <= 0) {\n          return Z_STREAM_END;\n        }\n\n        /* Write the trailer */\n        if (s.wrap === 2) {\n          put_byte(s, strm.adler & 0xff);\n          put_byte(s, strm.adler >> 8 & 0xff);\n          put_byte(s, strm.adler >> 16 & 0xff);\n          put_byte(s, strm.adler >> 24 & 0xff);\n          put_byte(s, strm.total_in & 0xff);\n          put_byte(s, strm.total_in >> 8 & 0xff);\n          put_byte(s, strm.total_in >> 16 & 0xff);\n          put_byte(s, strm.total_in >> 24 & 0xff);\n        } else {\n          putShortMSB(s, strm.adler >>> 16);\n          putShortMSB(s, strm.adler & 0xffff);\n        }\n        flush_pending(strm);\n        /* If avail_out is zero, the application will call deflate again\r\n         * to flush the rest.\r\n         */\n        if (s.wrap > 0) {\n          s.wrap = -s.wrap;\n        }\n        /* write the trailer only once! */\n        return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n      }\n      function deflateEnd(strm) {\n        var status;\n        if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {\n          return Z_STREAM_ERROR;\n        }\n        status = strm.state.status;\n        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n          return err(strm, Z_STREAM_ERROR);\n        }\n        strm.state = null;\n        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n      }\n\n      /* =========================================================================\r\n       * Initializes the compression dictionary from the given byte\r\n       * sequence without producing any compressed output.\r\n       */\n      function deflateSetDictionary(strm, dictionary) {\n        var dictLength = dictionary.length;\n        var s;\n        var str, n;\n        var wrap;\n        var avail;\n        var next;\n        var input;\n        var tmpDict;\n        if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {\n          return Z_STREAM_ERROR;\n        }\n        s = strm.state;\n        wrap = s.wrap;\n        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n          return Z_STREAM_ERROR;\n        }\n\n        /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n        if (wrap === 1) {\n          /* adler32(strm->adler, dictionary, dictLength); */\n          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n        }\n        s.wrap = 0; /* avoid computing Adler-32 in read_buf */\n\n        /* if dictionary would fill window, just replace the history */\n        if (dictLength >= s.w_size) {\n          if (wrap === 0) {\n            /* already empty otherwise */\n            /*** CLEAR_HASH(s); ***/\n            zero(s.head); // Fill with NIL (= 0);\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n          /* use the tail */\n          // dictionary = dictionary.slice(dictLength - s.w_size);\n          tmpDict = new utils.Buf8(s.w_size);\n          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n          dictionary = tmpDict;\n          dictLength = s.w_size;\n        }\n        /* insert dictionary into window and hash */\n        avail = strm.avail_in;\n        next = strm.next_in;\n        input = strm.input;\n        strm.avail_in = dictLength;\n        strm.next_in = 0;\n        strm.input = dictionary;\n        fill_window(s);\n        while (s.lookahead >= MIN_MATCH) {\n          str = s.strstart;\n          n = s.lookahead - (MIN_MATCH - 1);\n          do {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n          } while (--n);\n          s.strstart = str;\n          s.lookahead = MIN_MATCH - 1;\n          fill_window(s);\n        }\n        s.strstart += s.lookahead;\n        s.block_start = s.strstart;\n        s.insert = s.lookahead;\n        s.lookahead = 0;\n        s.match_length = s.prev_length = MIN_MATCH - 1;\n        s.match_available = 0;\n        strm.next_in = next;\n        strm.input = input;\n        strm.avail_in = avail;\n        s.wrap = wrap;\n        return Z_OK;\n      }\n      exports.deflateInit = deflateInit;\n      exports.deflateInit2 = deflateInit2;\n      exports.deflateReset = deflateReset;\n      exports.deflateResetKeep = deflateResetKeep;\n      exports.deflateSetHeader = deflateSetHeader;\n      exports.deflate = deflate;\n      exports.deflateEnd = deflateEnd;\n      exports.deflateSetDictionary = deflateSetDictionary;\n      exports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n      /* Not implemented\r\n      exports.deflateBound = deflateBound;\r\n      exports.deflateCopy = deflateCopy;\r\n      exports.deflateParams = deflateParams;\r\n      exports.deflatePending = deflatePending;\r\n      exports.deflatePrime = deflatePrime;\r\n      exports.deflateTune = deflateTune;\r\n      */\n    }, {\n      \"../utils/common\": 5,\n      \"./adler32\": 7,\n      \"./crc32\": 8,\n      \"./messages\": 10,\n      \"./trees\": 11\n    }],\n    10: [function (require, module, exports) {\n      'use strict';\n\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n      module.exports = {\n        2: 'need dictionary',\n        /* Z_NEED_DICT       2  */\n        1: 'stream end',\n        /* Z_STREAM_END      1  */\n        0: '',\n        /* Z_OK              0  */\n        '-1': 'file error',\n        /* Z_ERRNO         (-1) */\n        '-2': 'stream error',\n        /* Z_STREAM_ERROR  (-2) */\n        '-3': 'data error',\n        /* Z_DATA_ERROR    (-3) */\n        '-4': 'insufficient memory',\n        /* Z_MEM_ERROR     (-4) */\n        '-5': 'buffer error',\n        /* Z_BUF_ERROR     (-5) */\n        '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */\n      };\n    }, {}],\n    11: [function (require, module, exports) {\n      'use strict';\n\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n\n      /* eslint-disable space-unary-ops */\n      var utils = require('../utils/common');\n\n      /* Public constants ==========================================================*/\n      /* ===========================================================================*/\n\n      //var Z_FILTERED          = 1;\n      //var Z_HUFFMAN_ONLY      = 2;\n      //var Z_RLE               = 3;\n      var Z_FIXED = 4;\n      //var Z_DEFAULT_STRATEGY  = 0;\n\n      /* Possible values of the data_type field (though see inflate()) */\n      var Z_BINARY = 0;\n      var Z_TEXT = 1;\n      //var Z_ASCII             = 1; // = Z_TEXT\n      var Z_UNKNOWN = 2;\n\n      /*============================================================================*/\n\n      function zero(buf) {\n        var len = buf.length;\n        while (--len >= 0) {\n          buf[len] = 0;\n        }\n      }\n\n      // From zutil.h\n\n      var STORED_BLOCK = 0;\n      var STATIC_TREES = 1;\n      var DYN_TREES = 2;\n      /* The three kinds of block type */\n\n      var MIN_MATCH = 3;\n      var MAX_MATCH = 258;\n      /* The minimum and maximum match lengths */\n\n      // From deflate.h\n      /* ===========================================================================\r\n       * Internal compression state.\r\n       */\n\n      var LENGTH_CODES = 29;\n      /* number of length codes, not counting the special END_BLOCK code */\n\n      var LITERALS = 256;\n      /* number of literal bytes 0..255 */\n\n      var L_CODES = LITERALS + 1 + LENGTH_CODES;\n      /* number of Literal or Length codes, including the END_BLOCK code */\n\n      var D_CODES = 30;\n      /* number of distance codes */\n\n      var BL_CODES = 19;\n      /* number of codes used to transfer the bit lengths */\n\n      var HEAP_SIZE = 2 * L_CODES + 1;\n      /* maximum heap size */\n\n      var MAX_BITS = 15;\n      /* All codes must not exceed MAX_BITS bits */\n\n      var Buf_size = 16;\n      /* size of bit buffer in bi_buf */\n\n      /* ===========================================================================\r\n       * Constants\r\n       */\n\n      var MAX_BL_BITS = 7;\n      /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n      var END_BLOCK = 256;\n      /* end of block literal code */\n\n      var REP_3_6 = 16;\n      /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n      var REPZ_3_10 = 17;\n      /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n      var REPZ_11_138 = 18;\n      /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n      /* eslint-disable comma-spacing,array-bracket-spacing */\n      var extra_lbits = /* extra bits for each length code */\n      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n      var extra_dbits = /* extra bits for each distance code */\n      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n      var extra_blbits = /* extra bits for each bit length code */\n      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      /* eslint-enable comma-spacing,array-bracket-spacing */\n\n      /* The lengths of the bit length codes are sent in order of decreasing\r\n       * probability, to avoid transmitting the lengths for unused bit length codes.\r\n       */\n\n      /* ===========================================================================\r\n       * Local data. These are initialized only once.\r\n       */\n\n      // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n      var DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n      // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n      var static_ltree = new Array((L_CODES + 2) * 2);\n      zero(static_ltree);\n      /* The static literal tree. Since the bit lengths are imposed, there is no\r\n       * need for the L_CODES extra codes used during heap construction. However\r\n       * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\r\n       * below).\r\n       */\n\n      var static_dtree = new Array(D_CODES * 2);\n      zero(static_dtree);\n      /* The static distance tree. (Actually a trivial tree since all codes use\r\n       * 5 bits.)\r\n       */\n\n      var _dist_code = new Array(DIST_CODE_LEN);\n      zero(_dist_code);\n      /* Distance codes. The first 256 values correspond to the distances\r\n       * 3 .. 258, the last 256 values correspond to the top 8 bits of\r\n       * the 15 bit distances.\r\n       */\n\n      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n      zero(_length_code);\n      /* length code for each normalized match length (0 == MIN_MATCH) */\n\n      var base_length = new Array(LENGTH_CODES);\n      zero(base_length);\n      /* First normalized length for each code (0 = MIN_MATCH) */\n\n      var base_dist = new Array(D_CODES);\n      zero(base_dist);\n      /* First normalized distance for each code (0 = distance of 1) */\n\n      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n        this.static_tree = static_tree; /* static tree or NULL */\n        this.extra_bits = extra_bits; /* extra bits for each code or NULL */\n        this.extra_base = extra_base; /* base index for extra_bits */\n        this.elems = elems; /* max number of elements in the tree */\n        this.max_length = max_length; /* max bit length for the codes */\n\n        // show if `static_tree` has data or dummy - needed for monomorphic objects\n        this.has_stree = static_tree && static_tree.length;\n      }\n      var static_l_desc;\n      var static_d_desc;\n      var static_bl_desc;\n      function TreeDesc(dyn_tree, stat_desc) {\n        this.dyn_tree = dyn_tree; /* the dynamic tree */\n        this.max_code = 0; /* largest code with non zero frequency */\n        this.stat_desc = stat_desc; /* the corresponding static tree */\n      }\n\n      function d_code(dist) {\n        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n      }\n\n      /* ===========================================================================\r\n       * Output a short LSB first on the stream.\r\n       * IN assertion: there is enough room in pendingBuf.\r\n       */\n      function put_short(s, w) {\n        //    put_byte(s, (uch)((w) & 0xff));\n        //    put_byte(s, (uch)((ush)(w) >> 8));\n        s.pending_buf[s.pending++] = w & 0xff;\n        s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n      }\n\n      /* ===========================================================================\r\n       * Send a value on a given number of bits.\r\n       * IN assertion: length <= 16 and value fits in length bits.\r\n       */\n      function send_bits(s, value, length) {\n        if (s.bi_valid > Buf_size - length) {\n          s.bi_buf |= value << s.bi_valid & 0xffff;\n          put_short(s, s.bi_buf);\n          s.bi_buf = value >> Buf_size - s.bi_valid;\n          s.bi_valid += length - Buf_size;\n        } else {\n          s.bi_buf |= value << s.bi_valid & 0xffff;\n          s.bi_valid += length;\n        }\n      }\n      function send_code(s, c, tree) {\n        send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);\n      }\n\n      /* ===========================================================================\r\n       * Reverse the first len bits of a code, using straightforward code (a faster\r\n       * method would use a table)\r\n       * IN assertion: 1 <= len <= 15\r\n       */\n      function bi_reverse(code, len) {\n        var res = 0;\n        do {\n          res |= code & 1;\n          code >>>= 1;\n          res <<= 1;\n        } while (--len > 0);\n        return res >>> 1;\n      }\n\n      /* ===========================================================================\r\n       * Flush the bit buffer, keeping at most 7 bits in it.\r\n       */\n      function bi_flush(s) {\n        if (s.bi_valid === 16) {\n          put_short(s, s.bi_buf);\n          s.bi_buf = 0;\n          s.bi_valid = 0;\n        } else if (s.bi_valid >= 8) {\n          s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n          s.bi_buf >>= 8;\n          s.bi_valid -= 8;\n        }\n      }\n\n      /* ===========================================================================\r\n       * Compute the optimal bit lengths for a tree and update the total bit length\r\n       * for the current block.\r\n       * IN assertion: the fields freq and dad are set, heap[heap_max] and\r\n       *    above are the tree nodes sorted by increasing frequency.\r\n       * OUT assertions: the field len is set to the optimal bit length, the\r\n       *     array bl_count contains the frequencies for each bit length.\r\n       *     The length opt_len is updated; static_len is also updated if stree is\r\n       *     not null.\r\n       */\n      function gen_bitlen(s, desc)\n      //    deflate_state *s;\n      //    tree_desc *desc;    /* the tree descriptor */\n      {\n        var tree = desc.dyn_tree;\n        var max_code = desc.max_code;\n        var stree = desc.stat_desc.static_tree;\n        var has_stree = desc.stat_desc.has_stree;\n        var extra = desc.stat_desc.extra_bits;\n        var base = desc.stat_desc.extra_base;\n        var max_length = desc.stat_desc.max_length;\n        var h; /* heap index */\n        var n, m; /* iterate over the tree elements */\n        var bits; /* bit length */\n        var xbits; /* extra bits */\n        var f; /* frequency */\n        var overflow = 0; /* number of elements with bit length too large */\n\n        for (bits = 0; bits <= MAX_BITS; bits++) {\n          s.bl_count[bits] = 0;\n        }\n\n        /* In a first pass, compute the optimal bit lengths (which may\r\n         * overflow in the case of the bit length tree).\r\n         */\n        tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */\n\n        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n          n = s.heap[h];\n          bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;\n          if (bits > max_length) {\n            bits = max_length;\n            overflow++;\n          }\n          tree[n * 2 + 1] /*.Len*/ = bits;\n          /* We overwrite tree[n].Dad which is no longer needed */\n\n          if (n > max_code) {\n            continue;\n          } /* not a leaf node */\n\n          s.bl_count[bits]++;\n          xbits = 0;\n          if (n >= base) {\n            xbits = extra[n - base];\n          }\n          f = tree[n * 2] /*.Freq*/;\n          s.opt_len += f * (bits + xbits);\n          if (has_stree) {\n            s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);\n          }\n        }\n        if (overflow === 0) {\n          return;\n        }\n\n        // Trace((stderr,\"\\nbit length overflow\\n\"));\n        /* This happens for example on obj2 and pic of the Calgary corpus */\n\n        /* Find the first bit length which could increase: */\n        do {\n          bits = max_length - 1;\n          while (s.bl_count[bits] === 0) {\n            bits--;\n          }\n          s.bl_count[bits]--; /* move one leaf down the tree */\n          s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n          s.bl_count[max_length]--;\n          /* The brother of the overflow item also moves one step up,\r\n           * but this does not affect bl_count[max_length]\r\n           */\n          overflow -= 2;\n        } while (overflow > 0);\n\n        /* Now recompute all bit lengths, scanning in increasing frequency.\r\n         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\r\n         * lengths instead of fixing only the wrong ones. This idea is taken\r\n         * from 'ar' written by Haruhiko Okumura.)\r\n         */\n        for (bits = max_length; bits !== 0; bits--) {\n          n = s.bl_count[bits];\n          while (n !== 0) {\n            m = s.heap[--h];\n            if (m > max_code) {\n              continue;\n            }\n            if (tree[m * 2 + 1] /*.Len*/ !== bits) {\n              // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n              s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;\n              tree[m * 2 + 1] /*.Len*/ = bits;\n            }\n            n--;\n          }\n        }\n      }\n\n      /* ===========================================================================\r\n       * Generate the codes for a given tree and bit counts (which need not be\r\n       * optimal).\r\n       * IN assertion: the array bl_count contains the bit length statistics for\r\n       * the given tree and the field len is set for all tree elements.\r\n       * OUT assertion: the field code is set for all tree elements of non\r\n       *     zero code length.\r\n       */\n      function gen_codes(tree, max_code, bl_count)\n      //    ct_data *tree;             /* the tree to decorate */\n      //    int max_code;              /* largest code with non zero frequency */\n      //    ushf *bl_count;            /* number of codes at each bit length */\n      {\n        var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n        var code = 0; /* running code value */\n        var bits; /* bit index */\n        var n; /* code index */\n\n        /* The distribution counts are first used to generate the code values\r\n         * without bit reversal.\r\n         */\n        for (bits = 1; bits <= MAX_BITS; bits++) {\n          next_code[bits] = code = code + bl_count[bits - 1] << 1;\n        }\n        /* Check that the bit counts in bl_count are consistent. The last code\r\n         * must be all ones.\r\n         */\n        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n        //        \"inconsistent bit counts\");\n        //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n        for (n = 0; n <= max_code; n++) {\n          var len = tree[n * 2 + 1] /*.Len*/;\n          if (len === 0) {\n            continue;\n          }\n          /* Now reverse the bits */\n          tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);\n\n          //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n          //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n        }\n      }\n\n      /* ===========================================================================\r\n       * Initialize the various 'constant' tables.\r\n       */\n      function tr_static_init() {\n        var n; /* iterates over tree elements */\n        var bits; /* bit counter */\n        var length; /* length value */\n        var code; /* code value */\n        var dist; /* distance index */\n        var bl_count = new Array(MAX_BITS + 1);\n        /* number of codes at each bit length for an optimal tree */\n\n        // do check in _tr_init()\n        //if (static_init_done) return;\n\n        /* For some embedded targets, global variables are not initialized: */\n        /*#ifdef NO_INIT_GLOBAL_POINTERS\r\n          static_l_desc.static_tree = static_ltree;\r\n          static_l_desc.extra_bits = extra_lbits;\r\n          static_d_desc.static_tree = static_dtree;\r\n          static_d_desc.extra_bits = extra_dbits;\r\n          static_bl_desc.extra_bits = extra_blbits;\r\n        #endif*/\n\n        /* Initialize the mapping length (0..255) -> length code (0..28) */\n        length = 0;\n        for (code = 0; code < LENGTH_CODES - 1; code++) {\n          base_length[code] = length;\n          for (n = 0; n < 1 << extra_lbits[code]; n++) {\n            _length_code[length++] = code;\n          }\n        }\n        //Assert (length == 256, \"tr_static_init: length != 256\");\n        /* Note that the length 255 (match length 258) can be represented\r\n         * in two different ways: code 284 + 5 bits or code 285, so we\r\n         * overwrite length_code[255] to use the best encoding:\r\n         */\n        _length_code[length - 1] = code;\n\n        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n        dist = 0;\n        for (code = 0; code < 16; code++) {\n          base_dist[code] = dist;\n          for (n = 0; n < 1 << extra_dbits[code]; n++) {\n            _dist_code[dist++] = code;\n          }\n        }\n        //Assert (dist == 256, \"tr_static_init: dist != 256\");\n        dist >>= 7; /* from now on, all distances are divided by 128 */\n        for (; code < D_CODES; code++) {\n          base_dist[code] = dist << 7;\n          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n            _dist_code[256 + dist++] = code;\n          }\n        }\n        //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n        /* Construct the codes of the static literal tree */\n        for (bits = 0; bits <= MAX_BITS; bits++) {\n          bl_count[bits] = 0;\n        }\n        n = 0;\n        while (n <= 143) {\n          static_ltree[n * 2 + 1] /*.Len*/ = 8;\n          n++;\n          bl_count[8]++;\n        }\n        while (n <= 255) {\n          static_ltree[n * 2 + 1] /*.Len*/ = 9;\n          n++;\n          bl_count[9]++;\n        }\n        while (n <= 279) {\n          static_ltree[n * 2 + 1] /*.Len*/ = 7;\n          n++;\n          bl_count[7]++;\n        }\n        while (n <= 287) {\n          static_ltree[n * 2 + 1] /*.Len*/ = 8;\n          n++;\n          bl_count[8]++;\n        }\n        /* Codes 286 and 287 do not exist, but we must include them in the\r\n         * tree construction to get a canonical Huffman tree (longest code\r\n         * all ones)\r\n         */\n        gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n        /* The static distance tree is trivial: */\n        for (n = 0; n < D_CODES; n++) {\n          static_dtree[n * 2 + 1] /*.Len*/ = 5;\n          static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);\n        }\n\n        // Now data ready and we can init static trees\n        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n\n        //static_init_done = true;\n      }\n\n      /* ===========================================================================\r\n       * Initialize a new block.\r\n       */\n      function init_block(s) {\n        var n; /* iterates over tree elements */\n\n        /* Initialize the trees. */\n        for (n = 0; n < L_CODES; n++) {\n          s.dyn_ltree[n * 2] /*.Freq*/ = 0;\n        }\n        for (n = 0; n < D_CODES; n++) {\n          s.dyn_dtree[n * 2] /*.Freq*/ = 0;\n        }\n        for (n = 0; n < BL_CODES; n++) {\n          s.bl_tree[n * 2] /*.Freq*/ = 0;\n        }\n        s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;\n        s.opt_len = s.static_len = 0;\n        s.last_lit = s.matches = 0;\n      }\n\n      /* ===========================================================================\r\n       * Flush the bit buffer and align the output on a byte boundary\r\n       */\n      function bi_windup(s) {\n        if (s.bi_valid > 8) {\n          put_short(s, s.bi_buf);\n        } else if (s.bi_valid > 0) {\n          //put_byte(s, (Byte)s->bi_buf);\n          s.pending_buf[s.pending++] = s.bi_buf;\n        }\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      }\n\n      /* ===========================================================================\r\n       * Copy a stored block, storing first the length and its\r\n       * one's complement if requested.\r\n       */\n      function copy_block(s, buf, len, header)\n      //DeflateState *s;\n      //charf    *buf;    /* the input data */\n      //unsigned len;     /* its length */\n      //int      header;  /* true if block header must be written */\n      {\n        bi_windup(s); /* align on byte boundary */\n\n        if (header) {\n          put_short(s, len);\n          put_short(s, ~len);\n        }\n        //  while (len--) {\n        //    put_byte(s, *buf++);\n        //  }\n        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n        s.pending += len;\n      }\n\n      /* ===========================================================================\r\n       * Compares to subtrees, using the tree depth as tie breaker when\r\n       * the subtrees have equal frequency. This minimizes the worst case length.\r\n       */\n      function smaller(tree, n, m, depth) {\n        var _n2 = n * 2;\n        var _m2 = m * 2;\n        return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];\n      }\n\n      /* ===========================================================================\r\n       * Restore the heap property by moving down the tree starting at node k,\r\n       * exchanging a node with the smallest of its two sons if necessary, stopping\r\n       * when the heap property is re-established (each father smaller than its\r\n       * two sons).\r\n       */\n      function pqdownheap(s, tree, k)\n      //    deflate_state *s;\n      //    ct_data *tree;  /* the tree to restore */\n      //    int k;               /* node to move down */\n      {\n        var v = s.heap[k];\n        var j = k << 1; /* left son of k */\n        while (j <= s.heap_len) {\n          /* Set j to the smallest of the two sons: */\n          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n            j++;\n          }\n          /* Exit if v is smaller than both sons */\n          if (smaller(tree, v, s.heap[j], s.depth)) {\n            break;\n          }\n\n          /* Exchange v with the smallest son */\n          s.heap[k] = s.heap[j];\n          k = j;\n\n          /* And continue down the tree, setting j to the left son of k */\n          j <<= 1;\n        }\n        s.heap[k] = v;\n      }\n\n      // inlined manually\n      // var SMALLEST = 1;\n\n      /* ===========================================================================\r\n       * Send the block data compressed using the given Huffman trees\r\n       */\n      function compress_block(s, ltree, dtree)\n      //    deflate_state *s;\n      //    const ct_data *ltree; /* literal tree */\n      //    const ct_data *dtree; /* distance tree */\n      {\n        var dist; /* distance of matched string */\n        var lc; /* match length or unmatched char (if dist == 0) */\n        var lx = 0; /* running index in l_buf */\n        var code; /* the code to send */\n        var extra; /* number of extra bits to send */\n\n        if (s.last_lit !== 0) {\n          do {\n            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n            lc = s.pending_buf[s.l_buf + lx];\n            lx++;\n            if (dist === 0) {\n              send_code(s, lc, ltree); /* send a literal byte */\n              //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n            } else {\n              /* Here, lc is the match length - MIN_MATCH */\n              code = _length_code[lc];\n              send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n              extra = extra_lbits[code];\n              if (extra !== 0) {\n                lc -= base_length[code];\n                send_bits(s, lc, extra); /* send the extra length bits */\n              }\n\n              dist--; /* dist is now the match distance - 1 */\n              code = d_code(dist);\n              //Assert (code < D_CODES, \"bad d_code\");\n\n              send_code(s, code, dtree); /* send the distance code */\n              extra = extra_dbits[code];\n              if (extra !== 0) {\n                dist -= base_dist[code];\n                send_bits(s, dist, extra); /* send the extra distance bits */\n              }\n            } /* literal or match pair ? */\n\n            /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n            //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n            //       \"pendingBuf overflow\");\n          } while (lx < s.last_lit);\n        }\n        send_code(s, END_BLOCK, ltree);\n      }\n\n      /* ===========================================================================\r\n       * Construct one Huffman tree and assigns the code bit strings and lengths.\r\n       * Update the total bit length for the current block.\r\n       * IN assertion: the field freq is set for all tree elements.\r\n       * OUT assertions: the fields len and code are set to the optimal bit length\r\n       *     and corresponding code. The length opt_len is updated; static_len is\r\n       *     also updated if stree is not null. The field max_code is set.\r\n       */\n      function build_tree(s, desc)\n      //    deflate_state *s;\n      //    tree_desc *desc; /* the tree descriptor */\n      {\n        var tree = desc.dyn_tree;\n        var stree = desc.stat_desc.static_tree;\n        var has_stree = desc.stat_desc.has_stree;\n        var elems = desc.stat_desc.elems;\n        var n, m; /* iterate over heap elements */\n        var max_code = -1; /* largest code with non zero frequency */\n        var node; /* new node being created */\n\n        /* Construct the initial heap, with least frequent element in\r\n         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\r\n         * heap[0] is not used.\r\n         */\n        s.heap_len = 0;\n        s.heap_max = HEAP_SIZE;\n        for (n = 0; n < elems; n++) {\n          if (tree[n * 2] /*.Freq*/ !== 0) {\n            s.heap[++s.heap_len] = max_code = n;\n            s.depth[n] = 0;\n          } else {\n            tree[n * 2 + 1] /*.Len*/ = 0;\n          }\n        }\n\n        /* The pkzip format requires that at least one distance code exists,\r\n         * and that at least one bit should be sent even if there is only one\r\n         * possible code. So to avoid special checks later on we force at least\r\n         * two codes of non zero frequency.\r\n         */\n        while (s.heap_len < 2) {\n          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n          tree[node * 2] /*.Freq*/ = 1;\n          s.depth[node] = 0;\n          s.opt_len--;\n          if (has_stree) {\n            s.static_len -= stree[node * 2 + 1] /*.Len*/;\n          }\n          /* node is 0 or 1 so it does not have extra bits */\n        }\n\n        desc.max_code = max_code;\n\n        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\r\n         * establish sub-heaps of increasing lengths:\r\n         */\n        for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {\n          pqdownheap(s, tree, n);\n        }\n\n        /* Construct the Huffman tree by repeatedly combining the least two\r\n         * frequent nodes.\r\n         */\n        node = elems; /* next internal node of the tree */\n        do {\n          //pqremove(s, tree, n);  /* n = node of least frequency */\n          /*** pqremove ***/\n          n = s.heap[1 /*SMALLEST*/];\n          s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];\n          pqdownheap(s, tree, 1 /*SMALLEST*/);\n          /***/\n\n          m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */\n\n          s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n          s.heap[--s.heap_max] = m;\n\n          /* Create a new node father of n and m */\n          tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;\n          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n          tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;\n\n          /* and insert the new node in the heap */\n          s.heap[1 /*SMALLEST*/] = node++;\n          pqdownheap(s, tree, 1 /*SMALLEST*/);\n        } while (s.heap_len >= 2);\n        s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];\n\n        /* At this point, the fields freq and dad are set. We can now\r\n         * generate the bit lengths.\r\n         */\n        gen_bitlen(s, desc);\n\n        /* The field len is now set, we can generate the bit codes */\n        gen_codes(tree, max_code, s.bl_count);\n      }\n\n      /* ===========================================================================\r\n       * Scan a literal or distance tree to determine the frequencies of the codes\r\n       * in the bit length tree.\r\n       */\n      function scan_tree(s, tree, max_code)\n      //    deflate_state *s;\n      //    ct_data *tree;   /* the tree to be scanned */\n      //    int max_code;    /* and its largest code of non zero frequency */\n      {\n        var n; /* iterates over all tree elements */\n        var prevlen = -1; /* last emitted length */\n        var curlen; /* length of current code */\n\n        var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */\n\n        var count = 0; /* repeat count of the current code */\n        var max_count = 7; /* max repeat count */\n        var min_count = 4; /* min repeat count */\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        }\n        tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */\n\n        for (n = 0; n <= max_code; n++) {\n          curlen = nextlen;\n          nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;\n\n          if (++count < max_count && curlen === nextlen) {\n            continue;\n          } else if (count < min_count) {\n            s.bl_tree[curlen * 2] /*.Freq*/ += count;\n          } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n              s.bl_tree[curlen * 2] /*.Freq*/++;\n            }\n            s.bl_tree[REP_3_6 * 2] /*.Freq*/++;\n          } else if (count <= 10) {\n            s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;\n          } else {\n            s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;\n          }\n\n          count = 0;\n          prevlen = curlen;\n          if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n          } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n          } else {\n            max_count = 7;\n            min_count = 4;\n          }\n        }\n      }\n\n      /* ===========================================================================\r\n       * Send a literal or distance tree in compressed form, using the codes in\r\n       * bl_tree.\r\n       */\n      function send_tree(s, tree, max_code)\n      //    deflate_state *s;\n      //    ct_data *tree; /* the tree to be scanned */\n      //    int max_code;       /* and its largest code of non zero frequency */\n      {\n        var n; /* iterates over all tree elements */\n        var prevlen = -1; /* last emitted length */\n        var curlen; /* length of current code */\n\n        var nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */\n\n        var count = 0; /* repeat count of the current code */\n        var max_count = 7; /* max repeat count */\n        var min_count = 4; /* min repeat count */\n\n        /* tree[max_code+1].Len = -1; */ /* guard already set */\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        }\n        for (n = 0; n <= max_code; n++) {\n          curlen = nextlen;\n          nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;\n\n          if (++count < max_count && curlen === nextlen) {\n            continue;\n          } else if (count < min_count) {\n            do {\n              send_code(s, curlen, s.bl_tree);\n            } while (--count !== 0);\n          } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n              send_code(s, curlen, s.bl_tree);\n              count--;\n            }\n            //Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s.bl_tree);\n            send_bits(s, count - 3, 2);\n          } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s.bl_tree);\n            send_bits(s, count - 3, 3);\n          } else {\n            send_code(s, REPZ_11_138, s.bl_tree);\n            send_bits(s, count - 11, 7);\n          }\n          count = 0;\n          prevlen = curlen;\n          if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n          } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n          } else {\n            max_count = 7;\n            min_count = 4;\n          }\n        }\n      }\n\n      /* ===========================================================================\r\n       * Construct the Huffman tree for the bit lengths and return the index in\r\n       * bl_order of the last bit length code to send.\r\n       */\n      function build_bl_tree(s) {\n        var max_blindex; /* index of last bit length code of non zero freq */\n\n        /* Determine the bit length frequencies for literal and distance trees */\n        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n        /* Build the bit length tree: */\n        build_tree(s, s.bl_desc);\n        /* opt_len now includes the length of the tree representations, except\r\n         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\r\n         */\n\n        /* Determine the number of bit length codes to send. The pkzip format\r\n         * requires that at least 4 bit length codes be sent. (appnote.txt says\r\n         * 3 but the actual value used is 4.)\r\n         */\n        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {\n            break;\n          }\n        }\n        /* Update opt_len to include the bit length tree and counts */\n        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n        //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n        //        s->opt_len, s->static_len));\n\n        return max_blindex;\n      }\n\n      /* ===========================================================================\r\n       * Send the header for a block using dynamic Huffman trees: the counts, the\r\n       * lengths of the bit length codes, the literal tree and the distance tree.\r\n       * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\r\n       */\n      function send_all_trees(s, lcodes, dcodes, blcodes)\n      //    deflate_state *s;\n      //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n      {\n        var rank; /* index in bl_order */\n\n        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n        //        \"too many codes\");\n        //Tracev((stderr, \"\\nbl counts: \"));\n        send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n        send_bits(s, dcodes - 1, 5);\n        send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */\n        for (rank = 0; rank < blcodes; rank++) {\n          //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);\n        }\n        //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n        send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n        //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n        send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n        //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n      }\n\n      /* ===========================================================================\r\n       * Check if the data type is TEXT or BINARY, using the following algorithm:\r\n       * - TEXT if the two conditions below are satisfied:\r\n       *    a) There are no non-portable control characters belonging to the\r\n       *       \"black list\" (0..6, 14..25, 28..31).\r\n       *    b) There is at least one printable character belonging to the\r\n       *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\r\n       * - BINARY otherwise.\r\n       * - The following partially-portable control characters form a\r\n       *   \"gray list\" that is ignored in this detection algorithm:\r\n       *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\r\n       * IN assertion: the fields Freq of dyn_ltree are set.\r\n       */\n      function detect_data_type(s) {\n        /* black_mask is the bit mask of black-listed bytes\r\n         * set bits 0..6, 14..25, and 28..31\r\n         * 0xf3ffc07f = binary 11110011111111111100000001111111\r\n         */\n        var black_mask = 0xf3ffc07f;\n        var n;\n\n        /* Check for non-textual (\"black-listed\") bytes. */\n        for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n          if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {\n            return Z_BINARY;\n          }\n        }\n\n        /* Check for textual (\"white-listed\") bytes. */\n        if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {\n          return Z_TEXT;\n        }\n        for (n = 32; n < LITERALS; n++) {\n          if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {\n            return Z_TEXT;\n          }\n        }\n\n        /* There are no \"black-listed\" or \"white-listed\" bytes:\r\n         * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\r\n         */\n        return Z_BINARY;\n      }\n      var static_init_done = false;\n\n      /* ===========================================================================\r\n       * Initialize the tree data structures for a new zlib stream.\r\n       */\n      function _tr_init(s) {\n        if (!static_init_done) {\n          tr_static_init();\n          static_init_done = true;\n        }\n        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n\n        /* Initialize the first block of the first file: */\n        init_block(s);\n      }\n\n      /* ===========================================================================\r\n       * Send a stored block\r\n       */\n      function _tr_stored_block(s, buf, stored_len, last)\n      //DeflateState *s;\n      //charf *buf;       /* input block */\n      //ulg stored_len;   /* length of input block */\n      //int last;         /* one if this is the last block for a file */\n      {\n        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */\n        copy_block(s, buf, stored_len, true); /* with header */\n      }\n\n      /* ===========================================================================\r\n       * Send one empty static block to give enough lookahead for inflate.\r\n       * This takes 10 bits, of which 7 may remain in the bit buffer.\r\n       */\n      function _tr_align(s) {\n        send_bits(s, STATIC_TREES << 1, 3);\n        send_code(s, END_BLOCK, static_ltree);\n        bi_flush(s);\n      }\n\n      /* ===========================================================================\r\n       * Determine the best encoding for the current block: dynamic trees, static\r\n       * trees or store, and output the encoded block to the zip file.\r\n       */\n      function _tr_flush_block(s, buf, stored_len, last)\n      //DeflateState *s;\n      //charf *buf;       /* input block, or NULL if too old */\n      //ulg stored_len;   /* length of input block */\n      //int last;         /* one if this is the last block for a file */\n      {\n        var opt_lenb, static_lenb; /* opt_len and static_len in bytes */\n        var max_blindex = 0; /* index of last bit length code of non zero freq */\n\n        /* Build the Huffman trees unless a stored block is forced */\n        if (s.level > 0) {\n          /* Check if the file is binary or text */\n          if (s.strm.data_type === Z_UNKNOWN) {\n            s.strm.data_type = detect_data_type(s);\n          }\n\n          /* Construct the literal and distance trees */\n          build_tree(s, s.l_desc);\n          // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n          //        s->static_len));\n\n          build_tree(s, s.d_desc);\n          // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n          //        s->static_len));\n          /* At this point, opt_len and static_len are the total bit lengths of\r\n           * the compressed block data, excluding the tree representations.\r\n           */\n\n          /* Build the bit length tree for the above two trees, and get the index\r\n           * in bl_order of the last bit length code to send.\r\n           */\n          max_blindex = build_bl_tree(s);\n\n          /* Determine the best encoding. Compute the block lengths in bytes. */\n          opt_lenb = s.opt_len + 3 + 7 >>> 3;\n          static_lenb = s.static_len + 3 + 7 >>> 3;\n\n          // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n          //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n          //        s->last_lit));\n\n          if (static_lenb <= opt_lenb) {\n            opt_lenb = static_lenb;\n          }\n        } else {\n          // Assert(buf != (char*)0, \"lost buf\");\n          opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n        }\n\n        if (stored_len + 4 <= opt_lenb && buf !== -1) {\n          /* 4: two words for the lengths */\n\n          /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\r\n           * Otherwise we can't have processed more than WSIZE input bytes since\r\n           * the last block flush, because compression would have been\r\n           * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\r\n           * transform a block into a stored block.\r\n           */\n          _tr_stored_block(s, buf, stored_len, last);\n        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n          compress_block(s, static_ltree, static_dtree);\n        } else {\n          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n          compress_block(s, s.dyn_ltree, s.dyn_dtree);\n        }\n        // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n        /* The above check is made mod 2^32, for files larger than 512 MB\r\n         * and uLong implemented on 32 bits.\r\n         */\n        init_block(s);\n        if (last) {\n          bi_windup(s);\n        }\n        // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n        //       s->compressed_len-7*last));\n      }\n\n      /* ===========================================================================\r\n       * Save the match info and tally the frequency counts. Return true if\r\n       * the current block must be flushed.\r\n       */\n      function _tr_tally(s, dist, lc)\n      //    deflate_state *s;\n      //    unsigned dist;  /* distance of matched string */\n      //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n      {\n        //var out_length, in_length, dcode;\n\n        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n        s.last_lit++;\n        if (dist === 0) {\n          /* lc is the unmatched char */\n          s.dyn_ltree[lc * 2] /*.Freq*/++;\n        } else {\n          s.matches++;\n          /* Here, lc is the match length - MIN_MATCH */\n          dist--; /* dist = match distance - 1 */\n          //Assert((ush)dist < (ush)MAX_DIST(s) &&\n          //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n          //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;\n          s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;\n        }\n\n        // (!) This block is disabled in zlib defaults,\n        // don't enable it for binary compatibility\n\n        //#ifdef TRUNCATE_BLOCK\n        //  /* Try to guess if it is profitable to stop the current block here */\n        //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n        //    /* Compute an upper bound for the compressed length */\n        //    out_length = s.last_lit*8;\n        //    in_length = s.strstart - s.block_start;\n        //\n        //    for (dcode = 0; dcode < D_CODES; dcode++) {\n        //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n        //    }\n        //    out_length >>>= 3;\n        //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n        //    //       s->last_lit, in_length, out_length,\n        //    //       100L - out_length*100L/in_length));\n        //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n        //      return true;\n        //    }\n        //  }\n        //#endif\n\n        return s.last_lit === s.lit_bufsize - 1;\n        /* We avoid equality with lit_bufsize because of wraparound at 64K\r\n         * on 16 bit machines and because stored blocks are restricted to\r\n         * 64K-1 bytes.\r\n         */\n      }\n\n      exports._tr_init = _tr_init;\n      exports._tr_stored_block = _tr_stored_block;\n      exports._tr_flush_block = _tr_flush_block;\n      exports._tr_tally = _tr_tally;\n      exports._tr_align = _tr_align;\n    }, {\n      \"../utils/common\": 5\n    }],\n    12: [function (require, module, exports) {\n      'use strict';\n\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n      function ZStream() {\n        /* next input byte */\n        this.input = null; // JS specific, because we have no pointers\n        this.next_in = 0;\n        /* number of bytes available at input */\n        this.avail_in = 0;\n        /* total number of input bytes read so far */\n        this.total_in = 0;\n        /* next output byte should be put there */\n        this.output = null; // JS specific, because we have no pointers\n        this.next_out = 0;\n        /* remaining free space at output */\n        this.avail_out = 0;\n        /* total number of bytes output so far */\n        this.total_out = 0;\n        /* last error message, NULL if no error */\n        this.msg = '' /*Z_NULL*/;\n        /* not visible by applications */\n        this.state = null;\n        /* best guess about the data type: binary or text */\n        this.data_type = 2 /*Z_UNKNOWN*/;\n        /* adler32 value of the uncompressed data */\n        this.adler = 0;\n      }\n      module.exports = ZStream;\n    }, {}]\n  }, {}, [3])(3);\n});","map":{"version":3,"names":["f","exports","module","define","amd","g","window","global","self","plantumlEncoder","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","pako","data","deflateRaw","level","to","encode6bit","b","String","fromCharCode","append3bytes","b1","b2","b3","c1","c2","c3","c4","charCodeAt","deflate","encode64","encode","puml","deflated","zlib_deflate","utils","strings","msg","ZStream","toString","Object","prototype","Z_NO_FLUSH","Z_FINISH","Z_OK","Z_STREAM_END","Z_SYNC_FLUSH","Z_DEFAULT_COMPRESSION","Z_DEFAULT_STRATEGY","Z_DEFLATED","Deflate","options","assign","method","chunkSize","windowBits","memLevel","strategy","opt","raw","gzip","err","ended","chunks","strm","avail_out","status","deflateInit2","header","deflateSetHeader","dictionary","dict","string2buf","Uint8Array","deflateSetDictionary","_dict_set","push","mode","_mode","input","next_in","avail_in","output","Buf8","next_out","onEnd","onData","buf2binstring","shrinkBuf","deflateEnd","chunk","result","join","flattenChunks","deflator","TYPED_OK","Uint16Array","Int32Array","_has","obj","key","hasOwnProperty","sources","Array","slice","arguments","source","shift","TypeError","buf","size","subarray","fnTyped","arraySet","dest","src","src_offs","len","dest_offs","set","l","pos","fnUntyped","concat","apply","setTyped","on","Buf16","Buf32","STR_APPLY_OK","STR_APPLY_UIA_OK","__","_utf8len","q","str","m_pos","str_len","buf_len","binstring2buf","buf2string","max","out","c_len","utf16buf","utf8border","adler32","adler","s1","s2","makeTable","table","k","crcTable","crc32","crc","end","trees","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_BLOCK","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_UNKNOWN","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","errorCode","rank","zero","flush_pending","s","state","pending","pending_buf","pending_out","total_out","flush_block_only","last","_tr_flush_block","block_start","strstart","put_byte","putShortMSB","read_buf","start","wrap","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","prev","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","m","more","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","_tr_tally","max_lazy_match","last_lit","deflate_slow","max_insert","prev_match","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","DeflateState","gzhead","gzindex","last_flush","w_bits","hash_bits","dyn_ltree","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","deflateResetKeep","data_type","_tr_init","deflateReset","ret","deflateInit","old_flush","beg","val","text","hcrc","extra","name","comment","time","os","level_flags","bstate","_tr_align","_tr_stored_block","dictLength","avail","next","tmpDict","deflateInfo","Z_BINARY","Z_TEXT","STORED_BLOCK","STATIC_TREES","DYN_TREES","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","w","send_bits","value","send_code","tree","bi_reverse","res","bi_flush","gen_bitlen","desc","stree","base","h","bits","xbits","overflow","gen_codes","next_code","tr_static_init","init_block","bi_windup","copy_block","smaller","_n2","_m2","pqdownheap","v","j","compress_block","ltree","dtree","lc","lx","build_tree","node","scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","send_all_trees","lcodes","dcodes","blcodes","detect_data_type","black_mask","static_init_done","stored_len","opt_lenb","static_lenb"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/plantuml-encoder/dist/plantuml-encoder.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.plantumlEncoder = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\r\n'use strict'\r\n\r\nvar pako = require('pako/lib/deflate.js')\r\n\r\nmodule.exports = function (data) {\r\n  return pako.deflateRaw(data, { level: 9, to: 'string' })\r\n}\r\n\r\n},{\"pako/lib/deflate.js\":4}],2:[function(require,module,exports){\r\n'use strict'\r\n\r\n// Encode code taken from the PlantUML website:\r\n// http://plantuml.sourceforge.net/codejavascript2.html\r\n\r\n// It is described as being \"a transformation close to base64\"\r\n// The code has been slightly modified to pass linters\r\n\r\nfunction encode6bit (b) {\r\n  if (b < 10) {\r\n    return String.fromCharCode(48 + b)\r\n  }\r\n  b -= 10\r\n  if (b < 26) {\r\n    return String.fromCharCode(65 + b)\r\n  }\r\n  b -= 26\r\n  if (b < 26) {\r\n    return String.fromCharCode(97 + b)\r\n  }\r\n  b -= 26\r\n  if (b === 0) {\r\n    return '-'\r\n  }\r\n  if (b === 1) {\r\n    return '_'\r\n  }\r\n  return '?'\r\n}\r\n\r\nfunction append3bytes (b1, b2, b3) {\r\n  var c1 = b1 >> 2\r\n  var c2 = ((b1 & 0x3) << 4) | (b2 >> 4)\r\n  var c3 = ((b2 & 0xF) << 2) | (b3 >> 6)\r\n  var c4 = b3 & 0x3F\r\n  var r = ''\r\n  r += encode6bit(c1 & 0x3F)\r\n  r += encode6bit(c2 & 0x3F)\r\n  r += encode6bit(c3 & 0x3F)\r\n  r += encode6bit(c4 & 0x3F)\r\n  return r\r\n}\r\n\r\nmodule.exports = function (data) {\r\n  var r = ''\r\n  for (var i = 0; i < data.length; i += 3) {\r\n    if (i + 2 === data.length) {\r\n      r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0)\r\n    } else if (i + 1 === data.length) {\r\n      r += append3bytes(data.charCodeAt(i), 0, 0)\r\n    } else {\r\n      r += append3bytes(data.charCodeAt(i),\r\n        data.charCodeAt(i + 1),\r\n        data.charCodeAt(i + 2))\r\n    }\r\n  }\r\n  return r\r\n}\r\n\r\n},{}],3:[function(require,module,exports){\r\n'use strict'\r\n\r\nvar deflate = require('./deflate')\r\nvar encode64 = require('./encode64')\r\n\r\nmodule.exports.encode = function (puml) {\r\n  var deflated = deflate(puml)\r\n  return encode64(deflated)\r\n}\r\n\r\n},{\"./deflate\":1,\"./encode64\":2}],4:[function(require,module,exports){\r\n'use strict';\r\n\r\n\r\nvar zlib_deflate = require('./zlib/deflate');\r\nvar utils        = require('./utils/common');\r\nvar strings      = require('./utils/strings');\r\nvar msg          = require('./zlib/messages');\r\nvar ZStream      = require('./zlib/zstream');\r\n\r\nvar toString = Object.prototype.toString;\r\n\r\n/* Public constants ==========================================================*/\r\n/* ===========================================================================*/\r\n\r\nvar Z_NO_FLUSH      = 0;\r\nvar Z_FINISH        = 4;\r\n\r\nvar Z_OK            = 0;\r\nvar Z_STREAM_END    = 1;\r\nvar Z_SYNC_FLUSH    = 2;\r\n\r\nvar Z_DEFAULT_COMPRESSION = -1;\r\n\r\nvar Z_DEFAULT_STRATEGY    = 0;\r\n\r\nvar Z_DEFLATED  = 8;\r\n\r\n/* ===========================================================================*/\r\n\r\n\r\n/**\r\n * class Deflate\r\n *\r\n * Generic JS-style wrapper for zlib calls. If you don't need\r\n * streaming behaviour - use more simple functions: [[deflate]],\r\n * [[deflateRaw]] and [[gzip]].\r\n **/\r\n\r\n/* internal\r\n * Deflate.chunks -> Array\r\n *\r\n * Chunks of output data, if [[Deflate#onData]] not overridden.\r\n **/\r\n\r\n/**\r\n * Deflate.result -> Uint8Array|Array\r\n *\r\n * Compressed result, generated by default [[Deflate#onData]]\r\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\r\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\r\n * push a chunk with explicit flush (call [[Deflate#push]] with\r\n * `Z_SYNC_FLUSH` param).\r\n **/\r\n\r\n/**\r\n * Deflate.err -> Number\r\n *\r\n * Error code after deflate finished. 0 (Z_OK) on success.\r\n * You will not need it in real life, because deflate errors\r\n * are possible only on wrong options or bad `onData` / `onEnd`\r\n * custom handlers.\r\n **/\r\n\r\n/**\r\n * Deflate.msg -> String\r\n *\r\n * Error message, if [[Deflate.err]] != 0\r\n **/\r\n\r\n\r\n/**\r\n * new Deflate(options)\r\n * - options (Object): zlib deflate options.\r\n *\r\n * Creates new deflator instance with specified params. Throws exception\r\n * on bad params. Supported options:\r\n *\r\n * - `level`\r\n * - `windowBits`\r\n * - `memLevel`\r\n * - `strategy`\r\n * - `dictionary`\r\n *\r\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\r\n * for more information on these.\r\n *\r\n * Additional options, for internal needs:\r\n *\r\n * - `chunkSize` - size of generated data chunks (16K by default)\r\n * - `raw` (Boolean) - do raw deflate\r\n * - `gzip` (Boolean) - create gzip wrapper\r\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\r\n *    (each char code [0..255])\r\n * - `header` (Object) - custom header for gzip\r\n *   - `text` (Boolean) - true if compressed data believed to be text\r\n *   - `time` (Number) - modification time, unix timestamp\r\n *   - `os` (Number) - operation system code\r\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\r\n *   - `name` (String) - file name (binary string)\r\n *   - `comment` (String) - comment (binary string)\r\n *   - `hcrc` (Boolean) - true if header crc should be added\r\n *\r\n * ##### Example:\r\n *\r\n * ```javascript\r\n * var pako = require('pako')\r\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\r\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\r\n *\r\n * var deflate = new pako.Deflate({ level: 3});\r\n *\r\n * deflate.push(chunk1, false);\r\n * deflate.push(chunk2, true);  // true -> last chunk\r\n *\r\n * if (deflate.err) { throw new Error(deflate.err); }\r\n *\r\n * console.log(deflate.result);\r\n * ```\r\n **/\r\nfunction Deflate(options) {\r\n  if (!(this instanceof Deflate)) return new Deflate(options);\r\n\r\n  this.options = utils.assign({\r\n    level: Z_DEFAULT_COMPRESSION,\r\n    method: Z_DEFLATED,\r\n    chunkSize: 16384,\r\n    windowBits: 15,\r\n    memLevel: 8,\r\n    strategy: Z_DEFAULT_STRATEGY,\r\n    to: ''\r\n  }, options || {});\r\n\r\n  var opt = this.options;\r\n\r\n  if (opt.raw && (opt.windowBits > 0)) {\r\n    opt.windowBits = -opt.windowBits;\r\n  }\r\n\r\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\r\n    opt.windowBits += 16;\r\n  }\r\n\r\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\r\n  this.msg    = '';     // error message\r\n  this.ended  = false;  // used to avoid multiple onEnd() calls\r\n  this.chunks = [];     // chunks of compressed data\r\n\r\n  this.strm = new ZStream();\r\n  this.strm.avail_out = 0;\r\n\r\n  var status = zlib_deflate.deflateInit2(\r\n    this.strm,\r\n    opt.level,\r\n    opt.method,\r\n    opt.windowBits,\r\n    opt.memLevel,\r\n    opt.strategy\r\n  );\r\n\r\n  if (status !== Z_OK) {\r\n    throw new Error(msg[status]);\r\n  }\r\n\r\n  if (opt.header) {\r\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\r\n  }\r\n\r\n  if (opt.dictionary) {\r\n    var dict;\r\n    // Convert data if needed\r\n    if (typeof opt.dictionary === 'string') {\r\n      // If we need to compress text, change encoding to utf8.\r\n      dict = strings.string2buf(opt.dictionary);\r\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\r\n      dict = new Uint8Array(opt.dictionary);\r\n    } else {\r\n      dict = opt.dictionary;\r\n    }\r\n\r\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\r\n\r\n    if (status !== Z_OK) {\r\n      throw new Error(msg[status]);\r\n    }\r\n\r\n    this._dict_set = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Deflate#push(data[, mode]) -> Boolean\r\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\r\n *   converted to utf8 byte sequence.\r\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\r\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\r\n *\r\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\r\n * new compressed chunks. Returns `true` on success. The last data block must have\r\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\r\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\r\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\r\n *\r\n * On fail call [[Deflate#onEnd]] with error code and return false.\r\n *\r\n * We strongly recommend to use `Uint8Array` on input for best speed (output\r\n * array format is detected automatically). Also, don't skip last param and always\r\n * use the same type in your code (boolean or number). That will improve JS speed.\r\n *\r\n * For regular `Array`-s make sure all elements are [0..255].\r\n *\r\n * ##### Example\r\n *\r\n * ```javascript\r\n * push(chunk, false); // push one of data chunks\r\n * ...\r\n * push(chunk, true);  // push last chunk\r\n * ```\r\n **/\r\nDeflate.prototype.push = function (data, mode) {\r\n  var strm = this.strm;\r\n  var chunkSize = this.options.chunkSize;\r\n  var status, _mode;\r\n\r\n  if (this.ended) { return false; }\r\n\r\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\r\n\r\n  // Convert data if needed\r\n  if (typeof data === 'string') {\r\n    // If we need to compress text, change encoding to utf8.\r\n    strm.input = strings.string2buf(data);\r\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\r\n    strm.input = new Uint8Array(data);\r\n  } else {\r\n    strm.input = data;\r\n  }\r\n\r\n  strm.next_in = 0;\r\n  strm.avail_in = strm.input.length;\r\n\r\n  do {\r\n    if (strm.avail_out === 0) {\r\n      strm.output = new utils.Buf8(chunkSize);\r\n      strm.next_out = 0;\r\n      strm.avail_out = chunkSize;\r\n    }\r\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\r\n\r\n    if (status !== Z_STREAM_END && status !== Z_OK) {\r\n      this.onEnd(status);\r\n      this.ended = true;\r\n      return false;\r\n    }\r\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\r\n      if (this.options.to === 'string') {\r\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\r\n      } else {\r\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\r\n      }\r\n    }\r\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\r\n\r\n  // Finalize on the last chunk.\r\n  if (_mode === Z_FINISH) {\r\n    status = zlib_deflate.deflateEnd(this.strm);\r\n    this.onEnd(status);\r\n    this.ended = true;\r\n    return status === Z_OK;\r\n  }\r\n\r\n  // callback interim results if Z_SYNC_FLUSH.\r\n  if (_mode === Z_SYNC_FLUSH) {\r\n    this.onEnd(Z_OK);\r\n    strm.avail_out = 0;\r\n    return true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n\r\n/**\r\n * Deflate#onData(chunk) -> Void\r\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\r\n *   on js engine support. When string output requested, each chunk\r\n *   will be string.\r\n *\r\n * By default, stores data blocks in `chunks[]` property and glue\r\n * those in `onEnd`. Override this handler, if you need another behaviour.\r\n **/\r\nDeflate.prototype.onData = function (chunk) {\r\n  this.chunks.push(chunk);\r\n};\r\n\r\n\r\n/**\r\n * Deflate#onEnd(status) -> Void\r\n * - status (Number): deflate status. 0 (Z_OK) on success,\r\n *   other if not.\r\n *\r\n * Called once after you tell deflate that the input stream is\r\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\r\n * or if an error happened. By default - join collected chunks,\r\n * free memory and fill `results` / `err` properties.\r\n **/\r\nDeflate.prototype.onEnd = function (status) {\r\n  // On success - join\r\n  if (status === Z_OK) {\r\n    if (this.options.to === 'string') {\r\n      this.result = this.chunks.join('');\r\n    } else {\r\n      this.result = utils.flattenChunks(this.chunks);\r\n    }\r\n  }\r\n  this.chunks = [];\r\n  this.err = status;\r\n  this.msg = this.strm.msg;\r\n};\r\n\r\n\r\n/**\r\n * deflate(data[, options]) -> Uint8Array|Array|String\r\n * - data (Uint8Array|Array|String): input data to compress.\r\n * - options (Object): zlib deflate options.\r\n *\r\n * Compress `data` with deflate algorithm and `options`.\r\n *\r\n * Supported options are:\r\n *\r\n * - level\r\n * - windowBits\r\n * - memLevel\r\n * - strategy\r\n * - dictionary\r\n *\r\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\r\n * for more information on these.\r\n *\r\n * Sugar (options):\r\n *\r\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\r\n *   negative windowBits implicitly.\r\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\r\n *    (each char code [0..255])\r\n *\r\n * ##### Example:\r\n *\r\n * ```javascript\r\n * var pako = require('pako')\r\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\r\n *\r\n * console.log(pako.deflate(data));\r\n * ```\r\n **/\r\nfunction deflate(input, options) {\r\n  var deflator = new Deflate(options);\r\n\r\n  deflator.push(input, true);\r\n\r\n  // That will never happens, if you don't cheat with options :)\r\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\r\n\r\n  return deflator.result;\r\n}\r\n\r\n\r\n/**\r\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\r\n * - data (Uint8Array|Array|String): input data to compress.\r\n * - options (Object): zlib deflate options.\r\n *\r\n * The same as [[deflate]], but creates raw data, without wrapper\r\n * (header and adler32 crc).\r\n **/\r\nfunction deflateRaw(input, options) {\r\n  options = options || {};\r\n  options.raw = true;\r\n  return deflate(input, options);\r\n}\r\n\r\n\r\n/**\r\n * gzip(data[, options]) -> Uint8Array|Array|String\r\n * - data (Uint8Array|Array|String): input data to compress.\r\n * - options (Object): zlib deflate options.\r\n *\r\n * The same as [[deflate]], but create gzip wrapper instead of\r\n * deflate one.\r\n **/\r\nfunction gzip(input, options) {\r\n  options = options || {};\r\n  options.gzip = true;\r\n  return deflate(input, options);\r\n}\r\n\r\n\r\nexports.Deflate = Deflate;\r\nexports.deflate = deflate;\r\nexports.deflateRaw = deflateRaw;\r\nexports.gzip = gzip;\r\n\r\n},{\"./utils/common\":5,\"./utils/strings\":6,\"./zlib/deflate\":9,\"./zlib/messages\":10,\"./zlib/zstream\":12}],5:[function(require,module,exports){\r\n'use strict';\r\n\r\n\r\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\r\n                (typeof Uint16Array !== 'undefined') &&\r\n                (typeof Int32Array !== 'undefined');\r\n\r\nfunction _has(obj, key) {\r\n  return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\n\r\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\r\n  var sources = Array.prototype.slice.call(arguments, 1);\r\n  while (sources.length) {\r\n    var source = sources.shift();\r\n    if (!source) { continue; }\r\n\r\n    if (typeof source !== 'object') {\r\n      throw new TypeError(source + 'must be non-object');\r\n    }\r\n\r\n    for (var p in source) {\r\n      if (_has(source, p)) {\r\n        obj[p] = source[p];\r\n      }\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\n\r\n// reduce buffer size, avoiding mem copy\r\nexports.shrinkBuf = function (buf, size) {\r\n  if (buf.length === size) { return buf; }\r\n  if (buf.subarray) { return buf.subarray(0, size); }\r\n  buf.length = size;\r\n  return buf;\r\n};\r\n\r\n\r\nvar fnTyped = {\r\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\r\n    if (src.subarray && dest.subarray) {\r\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\r\n      return;\r\n    }\r\n    // Fallback to ordinary array\r\n    for (var i = 0; i < len; i++) {\r\n      dest[dest_offs + i] = src[src_offs + i];\r\n    }\r\n  },\r\n  // Join array of chunks to single array.\r\n  flattenChunks: function (chunks) {\r\n    var i, l, len, pos, chunk, result;\r\n\r\n    // calculate data length\r\n    len = 0;\r\n    for (i = 0, l = chunks.length; i < l; i++) {\r\n      len += chunks[i].length;\r\n    }\r\n\r\n    // join chunks\r\n    result = new Uint8Array(len);\r\n    pos = 0;\r\n    for (i = 0, l = chunks.length; i < l; i++) {\r\n      chunk = chunks[i];\r\n      result.set(chunk, pos);\r\n      pos += chunk.length;\r\n    }\r\n\r\n    return result;\r\n  }\r\n};\r\n\r\nvar fnUntyped = {\r\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\r\n    for (var i = 0; i < len; i++) {\r\n      dest[dest_offs + i] = src[src_offs + i];\r\n    }\r\n  },\r\n  // Join array of chunks to single array.\r\n  flattenChunks: function (chunks) {\r\n    return [].concat.apply([], chunks);\r\n  }\r\n};\r\n\r\n\r\n// Enable/Disable typed arrays use, for testing\r\n//\r\nexports.setTyped = function (on) {\r\n  if (on) {\r\n    exports.Buf8  = Uint8Array;\r\n    exports.Buf16 = Uint16Array;\r\n    exports.Buf32 = Int32Array;\r\n    exports.assign(exports, fnTyped);\r\n  } else {\r\n    exports.Buf8  = Array;\r\n    exports.Buf16 = Array;\r\n    exports.Buf32 = Array;\r\n    exports.assign(exports, fnUntyped);\r\n  }\r\n};\r\n\r\nexports.setTyped(TYPED_OK);\r\n\r\n},{}],6:[function(require,module,exports){\r\n// String encode/decode helpers\r\n'use strict';\r\n\r\n\r\nvar utils = require('./common');\r\n\r\n\r\n// Quick check if we can use fast array to bin string conversion\r\n//\r\n// - apply(Array) can fail on Android 2.2\r\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\r\n//\r\nvar STR_APPLY_OK = true;\r\nvar STR_APPLY_UIA_OK = true;\r\n\r\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\r\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\r\n\r\n\r\n// Table with utf8 lengths (calculated by first byte of sequence)\r\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\r\n// because max possible codepoint is 0x10ffff\r\nvar _utf8len = new utils.Buf8(256);\r\nfor (var q = 0; q < 256; q++) {\r\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\r\n}\r\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\r\n\r\n\r\n// convert string to array (typed, when possible)\r\nexports.string2buf = function (str) {\r\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\r\n\r\n  // count binary size\r\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\r\n    c = str.charCodeAt(m_pos);\r\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\r\n      c2 = str.charCodeAt(m_pos + 1);\r\n      if ((c2 & 0xfc00) === 0xdc00) {\r\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\r\n        m_pos++;\r\n      }\r\n    }\r\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\r\n  }\r\n\r\n  // allocate buffer\r\n  buf = new utils.Buf8(buf_len);\r\n\r\n  // convert\r\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\r\n    c = str.charCodeAt(m_pos);\r\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\r\n      c2 = str.charCodeAt(m_pos + 1);\r\n      if ((c2 & 0xfc00) === 0xdc00) {\r\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\r\n        m_pos++;\r\n      }\r\n    }\r\n    if (c < 0x80) {\r\n      /* one byte */\r\n      buf[i++] = c;\r\n    } else if (c < 0x800) {\r\n      /* two bytes */\r\n      buf[i++] = 0xC0 | (c >>> 6);\r\n      buf[i++] = 0x80 | (c & 0x3f);\r\n    } else if (c < 0x10000) {\r\n      /* three bytes */\r\n      buf[i++] = 0xE0 | (c >>> 12);\r\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\r\n      buf[i++] = 0x80 | (c & 0x3f);\r\n    } else {\r\n      /* four bytes */\r\n      buf[i++] = 0xf0 | (c >>> 18);\r\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\r\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\r\n      buf[i++] = 0x80 | (c & 0x3f);\r\n    }\r\n  }\r\n\r\n  return buf;\r\n};\r\n\r\n// Helper (used in 2 places)\r\nfunction buf2binstring(buf, len) {\r\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\r\n  // If the length of the buffer is smaller than that, we can use this optimization,\r\n  // otherwise we will take a slower path.\r\n  if (len < 65534) {\r\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\r\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\r\n    }\r\n  }\r\n\r\n  var result = '';\r\n  for (var i = 0; i < len; i++) {\r\n    result += String.fromCharCode(buf[i]);\r\n  }\r\n  return result;\r\n}\r\n\r\n\r\n// Convert byte array to binary string\r\nexports.buf2binstring = function (buf) {\r\n  return buf2binstring(buf, buf.length);\r\n};\r\n\r\n\r\n// Convert binary string (typed, when possible)\r\nexports.binstring2buf = function (str) {\r\n  var buf = new utils.Buf8(str.length);\r\n  for (var i = 0, len = buf.length; i < len; i++) {\r\n    buf[i] = str.charCodeAt(i);\r\n  }\r\n  return buf;\r\n};\r\n\r\n\r\n// convert array to string\r\nexports.buf2string = function (buf, max) {\r\n  var i, out, c, c_len;\r\n  var len = max || buf.length;\r\n\r\n  // Reserve max possible length (2 words per char)\r\n  // NB: by unknown reasons, Array is significantly faster for\r\n  //     String.fromCharCode.apply than Uint16Array.\r\n  var utf16buf = new Array(len * 2);\r\n\r\n  for (out = 0, i = 0; i < len;) {\r\n    c = buf[i++];\r\n    // quick process ascii\r\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\r\n\r\n    c_len = _utf8len[c];\r\n    // skip 5 & 6 byte codes\r\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\r\n\r\n    // apply mask on first byte\r\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\r\n    // join the rest\r\n    while (c_len > 1 && i < len) {\r\n      c = (c << 6) | (buf[i++] & 0x3f);\r\n      c_len--;\r\n    }\r\n\r\n    // terminated by end of string?\r\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\r\n\r\n    if (c < 0x10000) {\r\n      utf16buf[out++] = c;\r\n    } else {\r\n      c -= 0x10000;\r\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\r\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\r\n    }\r\n  }\r\n\r\n  return buf2binstring(utf16buf, out);\r\n};\r\n\r\n\r\n// Calculate max possible position in utf8 buffer,\r\n// that will not break sequence. If that's not possible\r\n// - (very small limits) return max size as is.\r\n//\r\n// buf[] - utf8 bytes array\r\n// max   - length limit (mandatory);\r\nexports.utf8border = function (buf, max) {\r\n  var pos;\r\n\r\n  max = max || buf.length;\r\n  if (max > buf.length) { max = buf.length; }\r\n\r\n  // go back from last position, until start of sequence found\r\n  pos = max - 1;\r\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\r\n\r\n  // Very small and broken sequence,\r\n  // return max, because we should return something anyway.\r\n  if (pos < 0) { return max; }\r\n\r\n  // If we came to start of buffer - that means buffer is too small,\r\n  // return max too.\r\n  if (pos === 0) { return max; }\r\n\r\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\r\n};\r\n\r\n},{\"./common\":5}],7:[function(require,module,exports){\r\n'use strict';\r\n\r\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\r\n// It isn't worth it to make additional optimizations as in original.\r\n// Small size is preferable.\r\n\r\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\r\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\r\n//\r\n// This software is provided 'as-is', without any express or implied\r\n// warranty. In no event will the authors be held liable for any damages\r\n// arising from the use of this software.\r\n//\r\n// Permission is granted to anyone to use this software for any purpose,\r\n// including commercial applications, and to alter it and redistribute it\r\n// freely, subject to the following restrictions:\r\n//\r\n// 1. The origin of this software must not be misrepresented; you must not\r\n//   claim that you wrote the original software. If you use this software\r\n//   in a product, an acknowledgment in the product documentation would be\r\n//   appreciated but is not required.\r\n// 2. Altered source versions must be plainly marked as such, and must not be\r\n//   misrepresented as being the original software.\r\n// 3. This notice may not be removed or altered from any source distribution.\r\n\r\nfunction adler32(adler, buf, len, pos) {\r\n  var s1 = (adler & 0xffff) |0,\r\n      s2 = ((adler >>> 16) & 0xffff) |0,\r\n      n = 0;\r\n\r\n  while (len !== 0) {\r\n    // Set limit ~ twice less than 5552, to keep\r\n    // s2 in 31-bits, because we force signed ints.\r\n    // in other case %= will fail.\r\n    n = len > 2000 ? 2000 : len;\r\n    len -= n;\r\n\r\n    do {\r\n      s1 = (s1 + buf[pos++]) |0;\r\n      s2 = (s2 + s1) |0;\r\n    } while (--n);\r\n\r\n    s1 %= 65521;\r\n    s2 %= 65521;\r\n  }\r\n\r\n  return (s1 | (s2 << 16)) |0;\r\n}\r\n\r\n\r\nmodule.exports = adler32;\r\n\r\n},{}],8:[function(require,module,exports){\r\n'use strict';\r\n\r\n// Note: we can't get significant speed boost here.\r\n// So write code to minimize size - no pregenerated tables\r\n// and array tools dependencies.\r\n\r\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\r\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\r\n//\r\n// This software is provided 'as-is', without any express or implied\r\n// warranty. In no event will the authors be held liable for any damages\r\n// arising from the use of this software.\r\n//\r\n// Permission is granted to anyone to use this software for any purpose,\r\n// including commercial applications, and to alter it and redistribute it\r\n// freely, subject to the following restrictions:\r\n//\r\n// 1. The origin of this software must not be misrepresented; you must not\r\n//   claim that you wrote the original software. If you use this software\r\n//   in a product, an acknowledgment in the product documentation would be\r\n//   appreciated but is not required.\r\n// 2. Altered source versions must be plainly marked as such, and must not be\r\n//   misrepresented as being the original software.\r\n// 3. This notice may not be removed or altered from any source distribution.\r\n\r\n// Use ordinary array, since untyped makes no boost here\r\nfunction makeTable() {\r\n  var c, table = [];\r\n\r\n  for (var n = 0; n < 256; n++) {\r\n    c = n;\r\n    for (var k = 0; k < 8; k++) {\r\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\r\n    }\r\n    table[n] = c;\r\n  }\r\n\r\n  return table;\r\n}\r\n\r\n// Create table on load. Just 255 signed longs. Not a problem.\r\nvar crcTable = makeTable();\r\n\r\n\r\nfunction crc32(crc, buf, len, pos) {\r\n  var t = crcTable,\r\n      end = pos + len;\r\n\r\n  crc ^= -1;\r\n\r\n  for (var i = pos; i < end; i++) {\r\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\r\n  }\r\n\r\n  return (crc ^ (-1)); // >>> 0;\r\n}\r\n\r\n\r\nmodule.exports = crc32;\r\n\r\n},{}],9:[function(require,module,exports){\r\n'use strict';\r\n\r\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\r\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\r\n//\r\n// This software is provided 'as-is', without any express or implied\r\n// warranty. In no event will the authors be held liable for any damages\r\n// arising from the use of this software.\r\n//\r\n// Permission is granted to anyone to use this software for any purpose,\r\n// including commercial applications, and to alter it and redistribute it\r\n// freely, subject to the following restrictions:\r\n//\r\n// 1. The origin of this software must not be misrepresented; you must not\r\n//   claim that you wrote the original software. If you use this software\r\n//   in a product, an acknowledgment in the product documentation would be\r\n//   appreciated but is not required.\r\n// 2. Altered source versions must be plainly marked as such, and must not be\r\n//   misrepresented as being the original software.\r\n// 3. This notice may not be removed or altered from any source distribution.\r\n\r\nvar utils   = require('../utils/common');\r\nvar trees   = require('./trees');\r\nvar adler32 = require('./adler32');\r\nvar crc32   = require('./crc32');\r\nvar msg     = require('./messages');\r\n\r\n/* Public constants ==========================================================*/\r\n/* ===========================================================================*/\r\n\r\n\r\n/* Allowed flush values; see deflate() and inflate() below for details */\r\nvar Z_NO_FLUSH      = 0;\r\nvar Z_PARTIAL_FLUSH = 1;\r\n//var Z_SYNC_FLUSH    = 2;\r\nvar Z_FULL_FLUSH    = 3;\r\nvar Z_FINISH        = 4;\r\nvar Z_BLOCK         = 5;\r\n//var Z_TREES         = 6;\r\n\r\n\r\n/* Return codes for the compression/decompression functions. Negative values\r\n * are errors, positive values are used for special but normal events.\r\n */\r\nvar Z_OK            = 0;\r\nvar Z_STREAM_END    = 1;\r\n//var Z_NEED_DICT     = 2;\r\n//var Z_ERRNO         = -1;\r\nvar Z_STREAM_ERROR  = -2;\r\nvar Z_DATA_ERROR    = -3;\r\n//var Z_MEM_ERROR     = -4;\r\nvar Z_BUF_ERROR     = -5;\r\n//var Z_VERSION_ERROR = -6;\r\n\r\n\r\n/* compression levels */\r\n//var Z_NO_COMPRESSION      = 0;\r\n//var Z_BEST_SPEED          = 1;\r\n//var Z_BEST_COMPRESSION    = 9;\r\nvar Z_DEFAULT_COMPRESSION = -1;\r\n\r\n\r\nvar Z_FILTERED            = 1;\r\nvar Z_HUFFMAN_ONLY        = 2;\r\nvar Z_RLE                 = 3;\r\nvar Z_FIXED               = 4;\r\nvar Z_DEFAULT_STRATEGY    = 0;\r\n\r\n/* Possible values of the data_type field (though see inflate()) */\r\n//var Z_BINARY              = 0;\r\n//var Z_TEXT                = 1;\r\n//var Z_ASCII               = 1; // = Z_TEXT\r\nvar Z_UNKNOWN             = 2;\r\n\r\n\r\n/* The deflate compression method */\r\nvar Z_DEFLATED  = 8;\r\n\r\n/*============================================================================*/\r\n\r\n\r\nvar MAX_MEM_LEVEL = 9;\r\n/* Maximum value for memLevel in deflateInit2 */\r\nvar MAX_WBITS = 15;\r\n/* 32K LZ77 window */\r\nvar DEF_MEM_LEVEL = 8;\r\n\r\n\r\nvar LENGTH_CODES  = 29;\r\n/* number of length codes, not counting the special END_BLOCK code */\r\nvar LITERALS      = 256;\r\n/* number of literal bytes 0..255 */\r\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\r\n/* number of Literal or Length codes, including the END_BLOCK code */\r\nvar D_CODES       = 30;\r\n/* number of distance codes */\r\nvar BL_CODES      = 19;\r\n/* number of codes used to transfer the bit lengths */\r\nvar HEAP_SIZE     = 2 * L_CODES + 1;\r\n/* maximum heap size */\r\nvar MAX_BITS  = 15;\r\n/* All codes must not exceed MAX_BITS bits */\r\n\r\nvar MIN_MATCH = 3;\r\nvar MAX_MATCH = 258;\r\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\r\n\r\nvar PRESET_DICT = 0x20;\r\n\r\nvar INIT_STATE = 42;\r\nvar EXTRA_STATE = 69;\r\nvar NAME_STATE = 73;\r\nvar COMMENT_STATE = 91;\r\nvar HCRC_STATE = 103;\r\nvar BUSY_STATE = 113;\r\nvar FINISH_STATE = 666;\r\n\r\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\r\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\r\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\r\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\r\n\r\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\r\n\r\nfunction err(strm, errorCode) {\r\n  strm.msg = msg[errorCode];\r\n  return errorCode;\r\n}\r\n\r\nfunction rank(f) {\r\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\r\n}\r\n\r\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\r\n\r\n\r\n/* =========================================================================\r\n * Flush as much pending output as possible. All deflate() output goes\r\n * through this function so some applications may wish to modify it\r\n * to avoid allocating a large strm->output buffer and copying into it.\r\n * (See also read_buf()).\r\n */\r\nfunction flush_pending(strm) {\r\n  var s = strm.state;\r\n\r\n  //_tr_flush_bits(s);\r\n  var len = s.pending;\r\n  if (len > strm.avail_out) {\r\n    len = strm.avail_out;\r\n  }\r\n  if (len === 0) { return; }\r\n\r\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\r\n  strm.next_out += len;\r\n  s.pending_out += len;\r\n  strm.total_out += len;\r\n  strm.avail_out -= len;\r\n  s.pending -= len;\r\n  if (s.pending === 0) {\r\n    s.pending_out = 0;\r\n  }\r\n}\r\n\r\n\r\nfunction flush_block_only(s, last) {\r\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\r\n  s.block_start = s.strstart;\r\n  flush_pending(s.strm);\r\n}\r\n\r\n\r\nfunction put_byte(s, b) {\r\n  s.pending_buf[s.pending++] = b;\r\n}\r\n\r\n\r\n/* =========================================================================\r\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\r\n * IN assertion: the stream state is correct and there is enough room in\r\n * pending_buf.\r\n */\r\nfunction putShortMSB(s, b) {\r\n//  put_byte(s, (Byte)(b >> 8));\r\n//  put_byte(s, (Byte)(b & 0xff));\r\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\r\n  s.pending_buf[s.pending++] = b & 0xff;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Read a new buffer from the current input stream, update the adler32\r\n * and total number of bytes read.  All deflate() input goes through\r\n * this function so some applications may wish to modify it to avoid\r\n * allocating a large strm->input buffer and copying from it.\r\n * (See also flush_pending()).\r\n */\r\nfunction read_buf(strm, buf, start, size) {\r\n  var len = strm.avail_in;\r\n\r\n  if (len > size) { len = size; }\r\n  if (len === 0) { return 0; }\r\n\r\n  strm.avail_in -= len;\r\n\r\n  // zmemcpy(buf, strm->next_in, len);\r\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\r\n  if (strm.state.wrap === 1) {\r\n    strm.adler = adler32(strm.adler, buf, len, start);\r\n  }\r\n\r\n  else if (strm.state.wrap === 2) {\r\n    strm.adler = crc32(strm.adler, buf, len, start);\r\n  }\r\n\r\n  strm.next_in += len;\r\n  strm.total_in += len;\r\n\r\n  return len;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Set match_start to the longest match starting at the given string and\r\n * return its length. Matches shorter or equal to prev_length are discarded,\r\n * in which case the result is equal to prev_length and match_start is\r\n * garbage.\r\n * IN assertions: cur_match is the head of the hash chain for the current\r\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\r\n * OUT assertion: the match length is not greater than s->lookahead.\r\n */\r\nfunction longest_match(s, cur_match) {\r\n  var chain_length = s.max_chain_length;      /* max hash chain length */\r\n  var scan = s.strstart; /* current string */\r\n  var match;                       /* matched string */\r\n  var len;                           /* length of current match */\r\n  var best_len = s.prev_length;              /* best match length so far */\r\n  var nice_match = s.nice_match;             /* stop if match long enough */\r\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\r\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\r\n\r\n  var _win = s.window; // shortcut\r\n\r\n  var wmask = s.w_mask;\r\n  var prev  = s.prev;\r\n\r\n  /* Stop when cur_match becomes <= limit. To simplify the code,\r\n   * we prevent matches with the string of window index 0.\r\n   */\r\n\r\n  var strend = s.strstart + MAX_MATCH;\r\n  var scan_end1  = _win[scan + best_len - 1];\r\n  var scan_end   = _win[scan + best_len];\r\n\r\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\r\n   * It is easy to get rid of this optimization if necessary.\r\n   */\r\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\r\n\r\n  /* Do not waste too much time if we already have a good match: */\r\n  if (s.prev_length >= s.good_match) {\r\n    chain_length >>= 2;\r\n  }\r\n  /* Do not look for matches beyond the end of the input. This is necessary\r\n   * to make deflate deterministic.\r\n   */\r\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\r\n\r\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\r\n\r\n  do {\r\n    // Assert(cur_match < s->strstart, \"no future\");\r\n    match = cur_match;\r\n\r\n    /* Skip to next match if the match length cannot increase\r\n     * or if the match length is less than 2.  Note that the checks below\r\n     * for insufficient lookahead only occur occasionally for performance\r\n     * reasons.  Therefore uninitialized memory will be accessed, and\r\n     * conditional jumps will be made that depend on those values.\r\n     * However the length of the match is limited to the lookahead, so\r\n     * the output of deflate is not affected by the uninitialized values.\r\n     */\r\n\r\n    if (_win[match + best_len]     !== scan_end  ||\r\n        _win[match + best_len - 1] !== scan_end1 ||\r\n        _win[match]                !== _win[scan] ||\r\n        _win[++match]              !== _win[scan + 1]) {\r\n      continue;\r\n    }\r\n\r\n    /* The check at best_len-1 can be removed because it will be made\r\n     * again later. (This heuristic is not always a win.)\r\n     * It is not necessary to compare scan[2] and match[2] since they\r\n     * are always equal when the other bytes match, given that\r\n     * the hash keys are equal and that HASH_BITS >= 8.\r\n     */\r\n    scan += 2;\r\n    match++;\r\n    // Assert(*scan == *match, \"match[2]?\");\r\n\r\n    /* We check for insufficient lookahead only every 8th comparison;\r\n     * the 256th check will be made at strstart+258.\r\n     */\r\n    do {\r\n      /*jshint noempty:false*/\r\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\r\n             scan < strend);\r\n\r\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\r\n\r\n    len = MAX_MATCH - (strend - scan);\r\n    scan = strend - MAX_MATCH;\r\n\r\n    if (len > best_len) {\r\n      s.match_start = cur_match;\r\n      best_len = len;\r\n      if (len >= nice_match) {\r\n        break;\r\n      }\r\n      scan_end1  = _win[scan + best_len - 1];\r\n      scan_end   = _win[scan + best_len];\r\n    }\r\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\r\n\r\n  if (best_len <= s.lookahead) {\r\n    return best_len;\r\n  }\r\n  return s.lookahead;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Fill the window when the lookahead becomes insufficient.\r\n * Updates strstart and lookahead.\r\n *\r\n * IN assertion: lookahead < MIN_LOOKAHEAD\r\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\r\n *    At least one byte has been read, or avail_in == 0; reads are\r\n *    performed for at least two bytes (required for the zip translate_eol\r\n *    option -- not supported here).\r\n */\r\nfunction fill_window(s) {\r\n  var _w_size = s.w_size;\r\n  var p, n, m, more, str;\r\n\r\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\r\n\r\n  do {\r\n    more = s.window_size - s.lookahead - s.strstart;\r\n\r\n    // JS ints have 32 bit, block below not needed\r\n    /* Deal with !@#$% 64K limit: */\r\n    //if (sizeof(int) <= 2) {\r\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\r\n    //        more = wsize;\r\n    //\r\n    //  } else if (more == (unsigned)(-1)) {\r\n    //        /* Very unlikely, but possible on 16 bit machine if\r\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\r\n    //         */\r\n    //        more--;\r\n    //    }\r\n    //}\r\n\r\n\r\n    /* If the window is almost full and there is insufficient lookahead,\r\n     * move the upper half to the lower one to make room in the upper half.\r\n     */\r\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\r\n\r\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\r\n      s.match_start -= _w_size;\r\n      s.strstart -= _w_size;\r\n      /* we now have strstart >= MAX_DIST */\r\n      s.block_start -= _w_size;\r\n\r\n      /* Slide the hash table (could be avoided with 32 bit values\r\n       at the expense of memory usage). We slide even when level == 0\r\n       to keep the hash table consistent if we switch back to level > 0\r\n       later. (Using level 0 permanently is not an optimal usage of\r\n       zlib, so we don't care about this pathological case.)\r\n       */\r\n\r\n      n = s.hash_size;\r\n      p = n;\r\n      do {\r\n        m = s.head[--p];\r\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\r\n      } while (--n);\r\n\r\n      n = _w_size;\r\n      p = n;\r\n      do {\r\n        m = s.prev[--p];\r\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\r\n        /* If n is not on any hash chain, prev[n] is garbage but\r\n         * its value will never be used.\r\n         */\r\n      } while (--n);\r\n\r\n      more += _w_size;\r\n    }\r\n    if (s.strm.avail_in === 0) {\r\n      break;\r\n    }\r\n\r\n    /* If there was no sliding:\r\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\r\n     *    more == window_size - lookahead - strstart\r\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\r\n     * => more >= window_size - 2*WSIZE + 2\r\n     * In the BIG_MEM or MMAP case (not yet supported),\r\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\r\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\r\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\r\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\r\n     */\r\n    //Assert(more >= 2, \"more < 2\");\r\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\r\n    s.lookahead += n;\r\n\r\n    /* Initialize the hash value now that we have some input: */\r\n    if (s.lookahead + s.insert >= MIN_MATCH) {\r\n      str = s.strstart - s.insert;\r\n      s.ins_h = s.window[str];\r\n\r\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\r\n//#if MIN_MATCH != 3\r\n//        Call update_hash() MIN_MATCH-3 more times\r\n//#endif\r\n      while (s.insert) {\r\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\r\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\r\n\r\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\r\n        s.head[s.ins_h] = str;\r\n        str++;\r\n        s.insert--;\r\n        if (s.lookahead + s.insert < MIN_MATCH) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\r\n     * but this is not important since only literal bytes will be emitted.\r\n     */\r\n\r\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\r\n\r\n  /* If the WIN_INIT bytes after the end of the current data have never been\r\n   * written, then zero those bytes in order to avoid memory check reports of\r\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\r\n   * the longest match routines.  Update the high water mark for the next\r\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\r\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\r\n   */\r\n//  if (s.high_water < s.window_size) {\r\n//    var curr = s.strstart + s.lookahead;\r\n//    var init = 0;\r\n//\r\n//    if (s.high_water < curr) {\r\n//      /* Previous high water mark below current data -- zero WIN_INIT\r\n//       * bytes or up to end of window, whichever is less.\r\n//       */\r\n//      init = s.window_size - curr;\r\n//      if (init > WIN_INIT)\r\n//        init = WIN_INIT;\r\n//      zmemzero(s->window + curr, (unsigned)init);\r\n//      s->high_water = curr + init;\r\n//    }\r\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\r\n//      /* High water mark at or above current data, but below current data\r\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\r\n//       * to end of window, whichever is less.\r\n//       */\r\n//      init = (ulg)curr + WIN_INIT - s->high_water;\r\n//      if (init > s->window_size - s->high_water)\r\n//        init = s->window_size - s->high_water;\r\n//      zmemzero(s->window + s->high_water, (unsigned)init);\r\n//      s->high_water += init;\r\n//    }\r\n//  }\r\n//\r\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\r\n//    \"not enough room for search\");\r\n}\r\n\r\n/* ===========================================================================\r\n * Copy without compression as much as possible from the input stream, return\r\n * the current block state.\r\n * This function does not insert new strings in the dictionary since\r\n * uncompressible data is probably not useful. This function is used\r\n * only for the level=0 compression option.\r\n * NOTE: this function should be optimized to avoid extra copying from\r\n * window to pending_buf.\r\n */\r\nfunction deflate_stored(s, flush) {\r\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\r\n   * to pending_buf_size, and each stored block has a 5 byte header:\r\n   */\r\n  var max_block_size = 0xffff;\r\n\r\n  if (max_block_size > s.pending_buf_size - 5) {\r\n    max_block_size = s.pending_buf_size - 5;\r\n  }\r\n\r\n  /* Copy as much as possible from input to output: */\r\n  for (;;) {\r\n    /* Fill the window as much as possible: */\r\n    if (s.lookahead <= 1) {\r\n\r\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\r\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\r\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\r\n//        s.block_start >= s.w_size)) {\r\n//        throw  new Error(\"slide too late\");\r\n//      }\r\n\r\n      fill_window(s);\r\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n\r\n      if (s.lookahead === 0) {\r\n        break;\r\n      }\r\n      /* flush the current block */\r\n    }\r\n    //Assert(s->block_start >= 0L, \"block gone\");\r\n//    if (s.block_start < 0) throw new Error(\"block gone\");\r\n\r\n    s.strstart += s.lookahead;\r\n    s.lookahead = 0;\r\n\r\n    /* Emit a stored block if pending_buf will be full: */\r\n    var max_start = s.block_start + max_block_size;\r\n\r\n    if (s.strstart === 0 || s.strstart >= max_start) {\r\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\r\n      s.lookahead = s.strstart - max_start;\r\n      s.strstart = max_start;\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n\r\n\r\n    }\r\n    /* Flush if we may have to slide, otherwise block_start may become\r\n     * negative and the data will be gone:\r\n     */\r\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n\r\n  s.insert = 0;\r\n\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n\r\n  if (s.strstart > s.block_start) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n\r\n  return BS_NEED_MORE;\r\n}\r\n\r\n/* ===========================================================================\r\n * Compress as much as possible from the input stream, return the current\r\n * block state.\r\n * This function does not perform lazy evaluation of matches and inserts\r\n * new strings in the dictionary only for unmatched strings or for short\r\n * matches. It is used only for the fast compression options.\r\n */\r\nfunction deflate_fast(s, flush) {\r\n  var hash_head;        /* head of the hash chain */\r\n  var bflush;           /* set if current block must be flushed */\r\n\r\n  for (;;) {\r\n    /* Make sure that we always have enough lookahead, except\r\n     * at the end of the input file. We need MAX_MATCH bytes\r\n     * for the next match, plus MIN_MATCH bytes to insert the\r\n     * string following the next match.\r\n     */\r\n    if (s.lookahead < MIN_LOOKAHEAD) {\r\n      fill_window(s);\r\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      if (s.lookahead === 0) {\r\n        break; /* flush the current block */\r\n      }\r\n    }\r\n\r\n    /* Insert the string window[strstart .. strstart+2] in the\r\n     * dictionary, and set hash_head to the head of the hash chain:\r\n     */\r\n    hash_head = 0/*NIL*/;\r\n    if (s.lookahead >= MIN_MATCH) {\r\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n      s.head[s.ins_h] = s.strstart;\r\n      /***/\r\n    }\r\n\r\n    /* Find the longest match, discarding those <= prev_length.\r\n     * At this point we have always match_length < MIN_MATCH\r\n     */\r\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\r\n      /* To simplify the code, we prevent matches with the string\r\n       * of window index 0 (in particular we have to avoid a match\r\n       * of the string with itself at the start of the input file).\r\n       */\r\n      s.match_length = longest_match(s, hash_head);\r\n      /* longest_match() sets match_start */\r\n    }\r\n    if (s.match_length >= MIN_MATCH) {\r\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\r\n\r\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\r\n                     s.match_length - MIN_MATCH, bflush); ***/\r\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\r\n\r\n      s.lookahead -= s.match_length;\r\n\r\n      /* Insert new strings in the hash table only if the match length\r\n       * is not too large. This saves time but degrades compression.\r\n       */\r\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\r\n        s.match_length--; /* string at strstart already in table */\r\n        do {\r\n          s.strstart++;\r\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n          s.head[s.ins_h] = s.strstart;\r\n          /***/\r\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\r\n           * always MIN_MATCH bytes ahead.\r\n           */\r\n        } while (--s.match_length !== 0);\r\n        s.strstart++;\r\n      } else\r\n      {\r\n        s.strstart += s.match_length;\r\n        s.match_length = 0;\r\n        s.ins_h = s.window[s.strstart];\r\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\r\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\r\n\r\n//#if MIN_MATCH != 3\r\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\r\n//#endif\r\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\r\n         * matter since it will be recomputed at next deflate call.\r\n         */\r\n      }\r\n    } else {\r\n      /* No match, output a literal byte */\r\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\r\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\r\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\r\n\r\n      s.lookahead--;\r\n      s.strstart++;\r\n    }\r\n    if (bflush) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n/* ===========================================================================\r\n * Same as above, but achieves better compression. We use a lazy\r\n * evaluation for matches: a match is finally adopted only if there is\r\n * no better match at the next window position.\r\n */\r\nfunction deflate_slow(s, flush) {\r\n  var hash_head;          /* head of hash chain */\r\n  var bflush;              /* set if current block must be flushed */\r\n\r\n  var max_insert;\r\n\r\n  /* Process the input block. */\r\n  for (;;) {\r\n    /* Make sure that we always have enough lookahead, except\r\n     * at the end of the input file. We need MAX_MATCH bytes\r\n     * for the next match, plus MIN_MATCH bytes to insert the\r\n     * string following the next match.\r\n     */\r\n    if (s.lookahead < MIN_LOOKAHEAD) {\r\n      fill_window(s);\r\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      if (s.lookahead === 0) { break; } /* flush the current block */\r\n    }\r\n\r\n    /* Insert the string window[strstart .. strstart+2] in the\r\n     * dictionary, and set hash_head to the head of the hash chain:\r\n     */\r\n    hash_head = 0/*NIL*/;\r\n    if (s.lookahead >= MIN_MATCH) {\r\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n      s.head[s.ins_h] = s.strstart;\r\n      /***/\r\n    }\r\n\r\n    /* Find the longest match, discarding those <= prev_length.\r\n     */\r\n    s.prev_length = s.match_length;\r\n    s.prev_match = s.match_start;\r\n    s.match_length = MIN_MATCH - 1;\r\n\r\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\r\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\r\n      /* To simplify the code, we prevent matches with the string\r\n       * of window index 0 (in particular we have to avoid a match\r\n       * of the string with itself at the start of the input file).\r\n       */\r\n      s.match_length = longest_match(s, hash_head);\r\n      /* longest_match() sets match_start */\r\n\r\n      if (s.match_length <= 5 &&\r\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\r\n\r\n        /* If prev_match is also MIN_MATCH, match_start is garbage\r\n         * but we will ignore the current match anyway.\r\n         */\r\n        s.match_length = MIN_MATCH - 1;\r\n      }\r\n    }\r\n    /* If there was a match at the previous step and the current\r\n     * match is not better, output the previous match:\r\n     */\r\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\r\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\r\n      /* Do not insert strings in hash table beyond this. */\r\n\r\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\r\n\r\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\r\n                     s.prev_length - MIN_MATCH, bflush);***/\r\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\r\n      /* Insert in hash table all strings up to the end of the match.\r\n       * strstart-1 and strstart are already inserted. If there is not\r\n       * enough lookahead, the last two strings are not inserted in\r\n       * the hash table.\r\n       */\r\n      s.lookahead -= s.prev_length - 1;\r\n      s.prev_length -= 2;\r\n      do {\r\n        if (++s.strstart <= max_insert) {\r\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\r\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\r\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\r\n          s.head[s.ins_h] = s.strstart;\r\n          /***/\r\n        }\r\n      } while (--s.prev_length !== 0);\r\n      s.match_available = 0;\r\n      s.match_length = MIN_MATCH - 1;\r\n      s.strstart++;\r\n\r\n      if (bflush) {\r\n        /*** FLUSH_BLOCK(s, 0); ***/\r\n        flush_block_only(s, false);\r\n        if (s.strm.avail_out === 0) {\r\n          return BS_NEED_MORE;\r\n        }\r\n        /***/\r\n      }\r\n\r\n    } else if (s.match_available) {\r\n      /* If there was no match at the previous position, output a\r\n       * single literal. If there was a match but the current match\r\n       * is longer, truncate the previous match to a single literal.\r\n       */\r\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\r\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\r\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\r\n\r\n      if (bflush) {\r\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\r\n        flush_block_only(s, false);\r\n        /***/\r\n      }\r\n      s.strstart++;\r\n      s.lookahead--;\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n    } else {\r\n      /* There is no previous match to compare with, wait for\r\n       * the next step to decide.\r\n       */\r\n      s.match_available = 1;\r\n      s.strstart++;\r\n      s.lookahead--;\r\n    }\r\n  }\r\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\r\n  if (s.match_available) {\r\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\r\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\r\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\r\n\r\n    s.match_available = 0;\r\n  }\r\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\r\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\r\n * deflate switches away from Z_RLE.)\r\n */\r\nfunction deflate_rle(s, flush) {\r\n  var bflush;            /* set if current block must be flushed */\r\n  var prev;              /* byte at distance one to match */\r\n  var scan, strend;      /* scan goes up to strend for length of run */\r\n\r\n  var _win = s.window;\r\n\r\n  for (;;) {\r\n    /* Make sure that we always have enough lookahead, except\r\n     * at the end of the input file. We need MAX_MATCH bytes\r\n     * for the longest run, plus one for the unrolled loop.\r\n     */\r\n    if (s.lookahead <= MAX_MATCH) {\r\n      fill_window(s);\r\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      if (s.lookahead === 0) { break; } /* flush the current block */\r\n    }\r\n\r\n    /* See how many times the previous byte repeats */\r\n    s.match_length = 0;\r\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\r\n      scan = s.strstart - 1;\r\n      prev = _win[scan];\r\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\r\n        strend = s.strstart + MAX_MATCH;\r\n        do {\r\n          /*jshint noempty:false*/\r\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\r\n                 prev === _win[++scan] && prev === _win[++scan] &&\r\n                 prev === _win[++scan] && prev === _win[++scan] &&\r\n                 prev === _win[++scan] && prev === _win[++scan] &&\r\n                 scan < strend);\r\n        s.match_length = MAX_MATCH - (strend - scan);\r\n        if (s.match_length > s.lookahead) {\r\n          s.match_length = s.lookahead;\r\n        }\r\n      }\r\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\r\n    }\r\n\r\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\r\n    if (s.match_length >= MIN_MATCH) {\r\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\r\n\r\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\r\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\r\n\r\n      s.lookahead -= s.match_length;\r\n      s.strstart += s.match_length;\r\n      s.match_length = 0;\r\n    } else {\r\n      /* No match, output a literal byte */\r\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\r\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\r\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\r\n\r\n      s.lookahead--;\r\n      s.strstart++;\r\n    }\r\n    if (bflush) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n  s.insert = 0;\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n/* ===========================================================================\r\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\r\n * (It will be regenerated if this run of deflate switches away from Huffman.)\r\n */\r\nfunction deflate_huff(s, flush) {\r\n  var bflush;             /* set if current block must be flushed */\r\n\r\n  for (;;) {\r\n    /* Make sure that we have a literal to write. */\r\n    if (s.lookahead === 0) {\r\n      fill_window(s);\r\n      if (s.lookahead === 0) {\r\n        if (flush === Z_NO_FLUSH) {\r\n          return BS_NEED_MORE;\r\n        }\r\n        break;      /* flush the current block */\r\n      }\r\n    }\r\n\r\n    /* Output a literal byte */\r\n    s.match_length = 0;\r\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\r\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\r\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\r\n    s.lookahead--;\r\n    s.strstart++;\r\n    if (bflush) {\r\n      /*** FLUSH_BLOCK(s, 0); ***/\r\n      flush_block_only(s, false);\r\n      if (s.strm.avail_out === 0) {\r\n        return BS_NEED_MORE;\r\n      }\r\n      /***/\r\n    }\r\n  }\r\n  s.insert = 0;\r\n  if (flush === Z_FINISH) {\r\n    /*** FLUSH_BLOCK(s, 1); ***/\r\n    flush_block_only(s, true);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_FINISH_STARTED;\r\n    }\r\n    /***/\r\n    return BS_FINISH_DONE;\r\n  }\r\n  if (s.last_lit) {\r\n    /*** FLUSH_BLOCK(s, 0); ***/\r\n    flush_block_only(s, false);\r\n    if (s.strm.avail_out === 0) {\r\n      return BS_NEED_MORE;\r\n    }\r\n    /***/\r\n  }\r\n  return BS_BLOCK_DONE;\r\n}\r\n\r\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\r\n * the desired pack level (0..9). The values given below have been tuned to\r\n * exclude worst case performance for pathological files. Better values may be\r\n * found for specific files.\r\n */\r\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\r\n  this.good_length = good_length;\r\n  this.max_lazy = max_lazy;\r\n  this.nice_length = nice_length;\r\n  this.max_chain = max_chain;\r\n  this.func = func;\r\n}\r\n\r\nvar configuration_table;\r\n\r\nconfiguration_table = [\r\n  /*      good lazy nice chain */\r\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\r\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\r\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\r\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\r\n\r\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\r\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\r\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\r\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\r\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\r\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\r\n];\r\n\r\n\r\n/* ===========================================================================\r\n * Initialize the \"longest match\" routines for a new zlib stream\r\n */\r\nfunction lm_init(s) {\r\n  s.window_size = 2 * s.w_size;\r\n\r\n  /*** CLEAR_HASH(s); ***/\r\n  zero(s.head); // Fill with NIL (= 0);\r\n\r\n  /* Set the default configuration parameters:\r\n   */\r\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\r\n  s.good_match = configuration_table[s.level].good_length;\r\n  s.nice_match = configuration_table[s.level].nice_length;\r\n  s.max_chain_length = configuration_table[s.level].max_chain;\r\n\r\n  s.strstart = 0;\r\n  s.block_start = 0;\r\n  s.lookahead = 0;\r\n  s.insert = 0;\r\n  s.match_length = s.prev_length = MIN_MATCH - 1;\r\n  s.match_available = 0;\r\n  s.ins_h = 0;\r\n}\r\n\r\n\r\nfunction DeflateState() {\r\n  this.strm = null;            /* pointer back to this zlib stream */\r\n  this.status = 0;            /* as the name implies */\r\n  this.pending_buf = null;      /* output still pending */\r\n  this.pending_buf_size = 0;  /* size of pending_buf */\r\n  this.pending_out = 0;       /* next pending byte to output to the stream */\r\n  this.pending = 0;           /* nb of bytes in the pending buffer */\r\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\r\n  this.gzhead = null;         /* gzip header information to write */\r\n  this.gzindex = 0;           /* where in extra, name, or comment */\r\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\r\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\r\n\r\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\r\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\r\n  this.w_mask = 0;  /* w_size - 1 */\r\n\r\n  this.window = null;\r\n  /* Sliding window. Input bytes are read into the second half of the window,\r\n   * and move to the first half later to keep a dictionary of at least wSize\r\n   * bytes. With this organization, matches are limited to a distance of\r\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\r\n   * performed with a length multiple of the block size.\r\n   */\r\n\r\n  this.window_size = 0;\r\n  /* Actual size of window: 2*wSize, except when the user input buffer\r\n   * is directly used as sliding window.\r\n   */\r\n\r\n  this.prev = null;\r\n  /* Link to older string with same hash index. To limit the size of this\r\n   * array to 64K, this link is maintained only for the last 32K strings.\r\n   * An index in this array is thus a window index modulo 32K.\r\n   */\r\n\r\n  this.head = null;   /* Heads of the hash chains or NIL. */\r\n\r\n  this.ins_h = 0;       /* hash index of string to be inserted */\r\n  this.hash_size = 0;   /* number of elements in hash table */\r\n  this.hash_bits = 0;   /* log2(hash_size) */\r\n  this.hash_mask = 0;   /* hash_size-1 */\r\n\r\n  this.hash_shift = 0;\r\n  /* Number of bits by which ins_h must be shifted at each input\r\n   * step. It must be such that after MIN_MATCH steps, the oldest\r\n   * byte no longer takes part in the hash key, that is:\r\n   *   hash_shift * MIN_MATCH >= hash_bits\r\n   */\r\n\r\n  this.block_start = 0;\r\n  /* Window position at the beginning of the current output block. Gets\r\n   * negative when the window is moved backwards.\r\n   */\r\n\r\n  this.match_length = 0;      /* length of best match */\r\n  this.prev_match = 0;        /* previous match */\r\n  this.match_available = 0;   /* set if previous match exists */\r\n  this.strstart = 0;          /* start of string to insert */\r\n  this.match_start = 0;       /* start of matching string */\r\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\r\n\r\n  this.prev_length = 0;\r\n  /* Length of the best match at previous step. Matches not greater than this\r\n   * are discarded. This is used in the lazy match evaluation.\r\n   */\r\n\r\n  this.max_chain_length = 0;\r\n  /* To speed up deflation, hash chains are never searched beyond this\r\n   * length.  A higher limit improves compression ratio but degrades the\r\n   * speed.\r\n   */\r\n\r\n  this.max_lazy_match = 0;\r\n  /* Attempt to find a better match only when the current match is strictly\r\n   * smaller than this value. This mechanism is used only for compression\r\n   * levels >= 4.\r\n   */\r\n  // That's alias to max_lazy_match, don't use directly\r\n  //this.max_insert_length = 0;\r\n  /* Insert new strings in the hash table only if the match length is not\r\n   * greater than this length. This saves time but degrades compression.\r\n   * max_insert_length is used only for compression levels <= 3.\r\n   */\r\n\r\n  this.level = 0;     /* compression level (1..9) */\r\n  this.strategy = 0;  /* favor or force Huffman coding*/\r\n\r\n  this.good_match = 0;\r\n  /* Use a faster search when the previous match is longer than this */\r\n\r\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\r\n\r\n              /* used by trees.c: */\r\n\r\n  /* Didn't use ct_data typedef below to suppress compiler warning */\r\n\r\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\r\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\r\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\r\n\r\n  // Use flat array of DOUBLE size, with interleaved fata,\r\n  // because JS does not support effective\r\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\r\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\r\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\r\n  zero(this.dyn_ltree);\r\n  zero(this.dyn_dtree);\r\n  zero(this.bl_tree);\r\n\r\n  this.l_desc   = null;         /* desc. for literal tree */\r\n  this.d_desc   = null;         /* desc. for distance tree */\r\n  this.bl_desc  = null;         /* desc. for bit length tree */\r\n\r\n  //ush bl_count[MAX_BITS+1];\r\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\r\n  /* number of codes at each bit length for an optimal tree */\r\n\r\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\r\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\r\n  zero(this.heap);\r\n\r\n  this.heap_len = 0;               /* number of elements in the heap */\r\n  this.heap_max = 0;               /* element of largest frequency */\r\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\r\n   * The same heap array is used to build all trees.\r\n   */\r\n\r\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\r\n  zero(this.depth);\r\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\r\n   */\r\n\r\n  this.l_buf = 0;          /* buffer index for literals or lengths */\r\n\r\n  this.lit_bufsize = 0;\r\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\r\n   * limiting lit_bufsize to 64K:\r\n   *   - frequencies can be kept in 16 bit counters\r\n   *   - if compression is not successful for the first block, all input\r\n   *     data is still in the window so we can still emit a stored block even\r\n   *     when input comes from standard input.  (This can also be done for\r\n   *     all blocks if lit_bufsize is not greater than 32K.)\r\n   *   - if compression is not successful for a file smaller than 64K, we can\r\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\r\n   *     This is applicable only for zip (not gzip or zlib).\r\n   *   - creating new Huffman trees less frequently may not provide fast\r\n   *     adaptation to changes in the input data statistics. (Take for\r\n   *     example a binary file with poorly compressible code followed by\r\n   *     a highly compressible string table.) Smaller buffer sizes give\r\n   *     fast adaptation but have of course the overhead of transmitting\r\n   *     trees more frequently.\r\n   *   - I can't count above 4\r\n   */\r\n\r\n  this.last_lit = 0;      /* running index in l_buf */\r\n\r\n  this.d_buf = 0;\r\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\r\n   * the same number of elements. To use different lengths, an extra flag\r\n   * array would be necessary.\r\n   */\r\n\r\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\r\n  this.static_len = 0;    /* bit length of current block with static trees */\r\n  this.matches = 0;       /* number of string matches in current block */\r\n  this.insert = 0;        /* bytes at end of window left to insert */\r\n\r\n\r\n  this.bi_buf = 0;\r\n  /* Output buffer. bits are inserted starting at the bottom (least\r\n   * significant bits).\r\n   */\r\n  this.bi_valid = 0;\r\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\r\n   * are always zero.\r\n   */\r\n\r\n  // Used for window memory init. We safely ignore it for JS. That makes\r\n  // sense only for pointers and memory check tools.\r\n  //this.high_water = 0;\r\n  /* High water mark offset in window for initialized bytes -- bytes above\r\n   * this are set to zero in order to avoid memory check warnings when\r\n   * longest match routines access bytes past the input.  This is then\r\n   * updated to the new high water mark.\r\n   */\r\n}\r\n\r\n\r\nfunction deflateResetKeep(strm) {\r\n  var s;\r\n\r\n  if (!strm || !strm.state) {\r\n    return err(strm, Z_STREAM_ERROR);\r\n  }\r\n\r\n  strm.total_in = strm.total_out = 0;\r\n  strm.data_type = Z_UNKNOWN;\r\n\r\n  s = strm.state;\r\n  s.pending = 0;\r\n  s.pending_out = 0;\r\n\r\n  if (s.wrap < 0) {\r\n    s.wrap = -s.wrap;\r\n    /* was made negative by deflate(..., Z_FINISH); */\r\n  }\r\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\r\n  strm.adler = (s.wrap === 2) ?\r\n    0  // crc32(0, Z_NULL, 0)\r\n  :\r\n    1; // adler32(0, Z_NULL, 0)\r\n  s.last_flush = Z_NO_FLUSH;\r\n  trees._tr_init(s);\r\n  return Z_OK;\r\n}\r\n\r\n\r\nfunction deflateReset(strm) {\r\n  var ret = deflateResetKeep(strm);\r\n  if (ret === Z_OK) {\r\n    lm_init(strm.state);\r\n  }\r\n  return ret;\r\n}\r\n\r\n\r\nfunction deflateSetHeader(strm, head) {\r\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\r\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\r\n  strm.state.gzhead = head;\r\n  return Z_OK;\r\n}\r\n\r\n\r\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\r\n  if (!strm) { // === Z_NULL\r\n    return Z_STREAM_ERROR;\r\n  }\r\n  var wrap = 1;\r\n\r\n  if (level === Z_DEFAULT_COMPRESSION) {\r\n    level = 6;\r\n  }\r\n\r\n  if (windowBits < 0) { /* suppress zlib wrapper */\r\n    wrap = 0;\r\n    windowBits = -windowBits;\r\n  }\r\n\r\n  else if (windowBits > 15) {\r\n    wrap = 2;           /* write gzip wrapper instead */\r\n    windowBits -= 16;\r\n  }\r\n\r\n\r\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\r\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\r\n    strategy < 0 || strategy > Z_FIXED) {\r\n    return err(strm, Z_STREAM_ERROR);\r\n  }\r\n\r\n\r\n  if (windowBits === 8) {\r\n    windowBits = 9;\r\n  }\r\n  /* until 256-byte window bug fixed */\r\n\r\n  var s = new DeflateState();\r\n\r\n  strm.state = s;\r\n  s.strm = strm;\r\n\r\n  s.wrap = wrap;\r\n  s.gzhead = null;\r\n  s.w_bits = windowBits;\r\n  s.w_size = 1 << s.w_bits;\r\n  s.w_mask = s.w_size - 1;\r\n\r\n  s.hash_bits = memLevel + 7;\r\n  s.hash_size = 1 << s.hash_bits;\r\n  s.hash_mask = s.hash_size - 1;\r\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\r\n\r\n  s.window = new utils.Buf8(s.w_size * 2);\r\n  s.head = new utils.Buf16(s.hash_size);\r\n  s.prev = new utils.Buf16(s.w_size);\r\n\r\n  // Don't need mem init magic for JS.\r\n  //s.high_water = 0;  /* nothing written to s->window yet */\r\n\r\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\r\n\r\n  s.pending_buf_size = s.lit_bufsize * 4;\r\n\r\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\r\n  //s->pending_buf = (uchf *) overlay;\r\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\r\n\r\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\r\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\r\n  s.d_buf = 1 * s.lit_bufsize;\r\n\r\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\r\n  s.l_buf = (1 + 2) * s.lit_bufsize;\r\n\r\n  s.level = level;\r\n  s.strategy = strategy;\r\n  s.method = method;\r\n\r\n  return deflateReset(strm);\r\n}\r\n\r\nfunction deflateInit(strm, level) {\r\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\r\n}\r\n\r\n\r\nfunction deflate(strm, flush) {\r\n  var old_flush, s;\r\n  var beg, val; // for gzip header write only\r\n\r\n  if (!strm || !strm.state ||\r\n    flush > Z_BLOCK || flush < 0) {\r\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\r\n  }\r\n\r\n  s = strm.state;\r\n\r\n  if (!strm.output ||\r\n      (!strm.input && strm.avail_in !== 0) ||\r\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\r\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\r\n  }\r\n\r\n  s.strm = strm; /* just in case */\r\n  old_flush = s.last_flush;\r\n  s.last_flush = flush;\r\n\r\n  /* Write the header */\r\n  if (s.status === INIT_STATE) {\r\n\r\n    if (s.wrap === 2) { // GZIP header\r\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\r\n      put_byte(s, 31);\r\n      put_byte(s, 139);\r\n      put_byte(s, 8);\r\n      if (!s.gzhead) { // s->gzhead == Z_NULL\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, 0);\r\n        put_byte(s, s.level === 9 ? 2 :\r\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\r\n                     4 : 0));\r\n        put_byte(s, OS_CODE);\r\n        s.status = BUSY_STATE;\r\n      }\r\n      else {\r\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\r\n                    (s.gzhead.hcrc ? 2 : 0) +\r\n                    (!s.gzhead.extra ? 0 : 4) +\r\n                    (!s.gzhead.name ? 0 : 8) +\r\n                    (!s.gzhead.comment ? 0 : 16)\r\n        );\r\n        put_byte(s, s.gzhead.time & 0xff);\r\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\r\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\r\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\r\n        put_byte(s, s.level === 9 ? 2 :\r\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\r\n                     4 : 0));\r\n        put_byte(s, s.gzhead.os & 0xff);\r\n        if (s.gzhead.extra && s.gzhead.extra.length) {\r\n          put_byte(s, s.gzhead.extra.length & 0xff);\r\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\r\n        }\r\n        if (s.gzhead.hcrc) {\r\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\r\n        }\r\n        s.gzindex = 0;\r\n        s.status = EXTRA_STATE;\r\n      }\r\n    }\r\n    else // DEFLATE header\r\n    {\r\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\r\n      var level_flags = -1;\r\n\r\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\r\n        level_flags = 0;\r\n      } else if (s.level < 6) {\r\n        level_flags = 1;\r\n      } else if (s.level === 6) {\r\n        level_flags = 2;\r\n      } else {\r\n        level_flags = 3;\r\n      }\r\n      header |= (level_flags << 6);\r\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\r\n      header += 31 - (header % 31);\r\n\r\n      s.status = BUSY_STATE;\r\n      putShortMSB(s, header);\r\n\r\n      /* Save the adler32 of the preset dictionary: */\r\n      if (s.strstart !== 0) {\r\n        putShortMSB(s, strm.adler >>> 16);\r\n        putShortMSB(s, strm.adler & 0xffff);\r\n      }\r\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\r\n    }\r\n  }\r\n\r\n//#ifdef GZIP\r\n  if (s.status === EXTRA_STATE) {\r\n    if (s.gzhead.extra/* != Z_NULL*/) {\r\n      beg = s.pending;  /* start of bytes to update crc */\r\n\r\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\r\n        if (s.pending === s.pending_buf_size) {\r\n          if (s.gzhead.hcrc && s.pending > beg) {\r\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n          }\r\n          flush_pending(strm);\r\n          beg = s.pending;\r\n          if (s.pending === s.pending_buf_size) {\r\n            break;\r\n          }\r\n        }\r\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\r\n        s.gzindex++;\r\n      }\r\n      if (s.gzhead.hcrc && s.pending > beg) {\r\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n      }\r\n      if (s.gzindex === s.gzhead.extra.length) {\r\n        s.gzindex = 0;\r\n        s.status = NAME_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = NAME_STATE;\r\n    }\r\n  }\r\n  if (s.status === NAME_STATE) {\r\n    if (s.gzhead.name/* != Z_NULL*/) {\r\n      beg = s.pending;  /* start of bytes to update crc */\r\n      //int val;\r\n\r\n      do {\r\n        if (s.pending === s.pending_buf_size) {\r\n          if (s.gzhead.hcrc && s.pending > beg) {\r\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n          }\r\n          flush_pending(strm);\r\n          beg = s.pending;\r\n          if (s.pending === s.pending_buf_size) {\r\n            val = 1;\r\n            break;\r\n          }\r\n        }\r\n        // JS specific: little magic to add zero terminator to end of string\r\n        if (s.gzindex < s.gzhead.name.length) {\r\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\r\n        } else {\r\n          val = 0;\r\n        }\r\n        put_byte(s, val);\r\n      } while (val !== 0);\r\n\r\n      if (s.gzhead.hcrc && s.pending > beg) {\r\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n      }\r\n      if (val === 0) {\r\n        s.gzindex = 0;\r\n        s.status = COMMENT_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = COMMENT_STATE;\r\n    }\r\n  }\r\n  if (s.status === COMMENT_STATE) {\r\n    if (s.gzhead.comment/* != Z_NULL*/) {\r\n      beg = s.pending;  /* start of bytes to update crc */\r\n      //int val;\r\n\r\n      do {\r\n        if (s.pending === s.pending_buf_size) {\r\n          if (s.gzhead.hcrc && s.pending > beg) {\r\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n          }\r\n          flush_pending(strm);\r\n          beg = s.pending;\r\n          if (s.pending === s.pending_buf_size) {\r\n            val = 1;\r\n            break;\r\n          }\r\n        }\r\n        // JS specific: little magic to add zero terminator to end of string\r\n        if (s.gzindex < s.gzhead.comment.length) {\r\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\r\n        } else {\r\n          val = 0;\r\n        }\r\n        put_byte(s, val);\r\n      } while (val !== 0);\r\n\r\n      if (s.gzhead.hcrc && s.pending > beg) {\r\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\r\n      }\r\n      if (val === 0) {\r\n        s.status = HCRC_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = HCRC_STATE;\r\n    }\r\n  }\r\n  if (s.status === HCRC_STATE) {\r\n    if (s.gzhead.hcrc) {\r\n      if (s.pending + 2 > s.pending_buf_size) {\r\n        flush_pending(strm);\r\n      }\r\n      if (s.pending + 2 <= s.pending_buf_size) {\r\n        put_byte(s, strm.adler & 0xff);\r\n        put_byte(s, (strm.adler >> 8) & 0xff);\r\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\r\n        s.status = BUSY_STATE;\r\n      }\r\n    }\r\n    else {\r\n      s.status = BUSY_STATE;\r\n    }\r\n  }\r\n//#endif\r\n\r\n  /* Flush as much pending output as possible */\r\n  if (s.pending !== 0) {\r\n    flush_pending(strm);\r\n    if (strm.avail_out === 0) {\r\n      /* Since avail_out is 0, deflate will be called again with\r\n       * more output space, but possibly with both pending and\r\n       * avail_in equal to zero. There won't be anything to do,\r\n       * but this is not an error situation so make sure we\r\n       * return OK instead of BUF_ERROR at next call of deflate:\r\n       */\r\n      s.last_flush = -1;\r\n      return Z_OK;\r\n    }\r\n\r\n    /* Make sure there is something to do and avoid duplicate consecutive\r\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\r\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\r\n     */\r\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\r\n    flush !== Z_FINISH) {\r\n    return err(strm, Z_BUF_ERROR);\r\n  }\r\n\r\n  /* User must not provide more input after the first FINISH: */\r\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\r\n    return err(strm, Z_BUF_ERROR);\r\n  }\r\n\r\n  /* Start a new block or continue the current one.\r\n   */\r\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\r\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\r\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\r\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\r\n        configuration_table[s.level].func(s, flush));\r\n\r\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\r\n      s.status = FINISH_STATE;\r\n    }\r\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\r\n      if (strm.avail_out === 0) {\r\n        s.last_flush = -1;\r\n        /* avoid BUF_ERROR next call, see above */\r\n      }\r\n      return Z_OK;\r\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\r\n       * of deflate should use the same flush parameter to make sure\r\n       * that the flush is complete. So we don't have to output an\r\n       * empty block here, this will be done at next call. This also\r\n       * ensures that for a very small output buffer, we emit at most\r\n       * one empty block.\r\n       */\r\n    }\r\n    if (bstate === BS_BLOCK_DONE) {\r\n      if (flush === Z_PARTIAL_FLUSH) {\r\n        trees._tr_align(s);\r\n      }\r\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\r\n\r\n        trees._tr_stored_block(s, 0, 0, false);\r\n        /* For a full flush, this empty block will be recognized\r\n         * as a special marker by inflate_sync().\r\n         */\r\n        if (flush === Z_FULL_FLUSH) {\r\n          /*** CLEAR_HASH(s); ***/             /* forget history */\r\n          zero(s.head); // Fill with NIL (= 0);\r\n\r\n          if (s.lookahead === 0) {\r\n            s.strstart = 0;\r\n            s.block_start = 0;\r\n            s.insert = 0;\r\n          }\r\n        }\r\n      }\r\n      flush_pending(strm);\r\n      if (strm.avail_out === 0) {\r\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\r\n        return Z_OK;\r\n      }\r\n    }\r\n  }\r\n  //Assert(strm->avail_out > 0, \"bug2\");\r\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\r\n\r\n  if (flush !== Z_FINISH) { return Z_OK; }\r\n  if (s.wrap <= 0) { return Z_STREAM_END; }\r\n\r\n  /* Write the trailer */\r\n  if (s.wrap === 2) {\r\n    put_byte(s, strm.adler & 0xff);\r\n    put_byte(s, (strm.adler >> 8) & 0xff);\r\n    put_byte(s, (strm.adler >> 16) & 0xff);\r\n    put_byte(s, (strm.adler >> 24) & 0xff);\r\n    put_byte(s, strm.total_in & 0xff);\r\n    put_byte(s, (strm.total_in >> 8) & 0xff);\r\n    put_byte(s, (strm.total_in >> 16) & 0xff);\r\n    put_byte(s, (strm.total_in >> 24) & 0xff);\r\n  }\r\n  else\r\n  {\r\n    putShortMSB(s, strm.adler >>> 16);\r\n    putShortMSB(s, strm.adler & 0xffff);\r\n  }\r\n\r\n  flush_pending(strm);\r\n  /* If avail_out is zero, the application will call deflate again\r\n   * to flush the rest.\r\n   */\r\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\r\n  /* write the trailer only once! */\r\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\r\n}\r\n\r\nfunction deflateEnd(strm) {\r\n  var status;\r\n\r\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\r\n    return Z_STREAM_ERROR;\r\n  }\r\n\r\n  status = strm.state.status;\r\n  if (status !== INIT_STATE &&\r\n    status !== EXTRA_STATE &&\r\n    status !== NAME_STATE &&\r\n    status !== COMMENT_STATE &&\r\n    status !== HCRC_STATE &&\r\n    status !== BUSY_STATE &&\r\n    status !== FINISH_STATE\r\n  ) {\r\n    return err(strm, Z_STREAM_ERROR);\r\n  }\r\n\r\n  strm.state = null;\r\n\r\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\r\n}\r\n\r\n\r\n/* =========================================================================\r\n * Initializes the compression dictionary from the given byte\r\n * sequence without producing any compressed output.\r\n */\r\nfunction deflateSetDictionary(strm, dictionary) {\r\n  var dictLength = dictionary.length;\r\n\r\n  var s;\r\n  var str, n;\r\n  var wrap;\r\n  var avail;\r\n  var next;\r\n  var input;\r\n  var tmpDict;\r\n\r\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\r\n    return Z_STREAM_ERROR;\r\n  }\r\n\r\n  s = strm.state;\r\n  wrap = s.wrap;\r\n\r\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\r\n    return Z_STREAM_ERROR;\r\n  }\r\n\r\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\r\n  if (wrap === 1) {\r\n    /* adler32(strm->adler, dictionary, dictLength); */\r\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\r\n  }\r\n\r\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\r\n\r\n  /* if dictionary would fill window, just replace the history */\r\n  if (dictLength >= s.w_size) {\r\n    if (wrap === 0) {            /* already empty otherwise */\r\n      /*** CLEAR_HASH(s); ***/\r\n      zero(s.head); // Fill with NIL (= 0);\r\n      s.strstart = 0;\r\n      s.block_start = 0;\r\n      s.insert = 0;\r\n    }\r\n    /* use the tail */\r\n    // dictionary = dictionary.slice(dictLength - s.w_size);\r\n    tmpDict = new utils.Buf8(s.w_size);\r\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\r\n    dictionary = tmpDict;\r\n    dictLength = s.w_size;\r\n  }\r\n  /* insert dictionary into window and hash */\r\n  avail = strm.avail_in;\r\n  next = strm.next_in;\r\n  input = strm.input;\r\n  strm.avail_in = dictLength;\r\n  strm.next_in = 0;\r\n  strm.input = dictionary;\r\n  fill_window(s);\r\n  while (s.lookahead >= MIN_MATCH) {\r\n    str = s.strstart;\r\n    n = s.lookahead - (MIN_MATCH - 1);\r\n    do {\r\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\r\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\r\n\r\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\r\n\r\n      s.head[s.ins_h] = str;\r\n      str++;\r\n    } while (--n);\r\n    s.strstart = str;\r\n    s.lookahead = MIN_MATCH - 1;\r\n    fill_window(s);\r\n  }\r\n  s.strstart += s.lookahead;\r\n  s.block_start = s.strstart;\r\n  s.insert = s.lookahead;\r\n  s.lookahead = 0;\r\n  s.match_length = s.prev_length = MIN_MATCH - 1;\r\n  s.match_available = 0;\r\n  strm.next_in = next;\r\n  strm.input = input;\r\n  strm.avail_in = avail;\r\n  s.wrap = wrap;\r\n  return Z_OK;\r\n}\r\n\r\n\r\nexports.deflateInit = deflateInit;\r\nexports.deflateInit2 = deflateInit2;\r\nexports.deflateReset = deflateReset;\r\nexports.deflateResetKeep = deflateResetKeep;\r\nexports.deflateSetHeader = deflateSetHeader;\r\nexports.deflate = deflate;\r\nexports.deflateEnd = deflateEnd;\r\nexports.deflateSetDictionary = deflateSetDictionary;\r\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\r\n\r\n/* Not implemented\r\nexports.deflateBound = deflateBound;\r\nexports.deflateCopy = deflateCopy;\r\nexports.deflateParams = deflateParams;\r\nexports.deflatePending = deflatePending;\r\nexports.deflatePrime = deflatePrime;\r\nexports.deflateTune = deflateTune;\r\n*/\r\n\r\n},{\"../utils/common\":5,\"./adler32\":7,\"./crc32\":8,\"./messages\":10,\"./trees\":11}],10:[function(require,module,exports){\r\n'use strict';\r\n\r\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\r\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\r\n//\r\n// This software is provided 'as-is', without any express or implied\r\n// warranty. In no event will the authors be held liable for any damages\r\n// arising from the use of this software.\r\n//\r\n// Permission is granted to anyone to use this software for any purpose,\r\n// including commercial applications, and to alter it and redistribute it\r\n// freely, subject to the following restrictions:\r\n//\r\n// 1. The origin of this software must not be misrepresented; you must not\r\n//   claim that you wrote the original software. If you use this software\r\n//   in a product, an acknowledgment in the product documentation would be\r\n//   appreciated but is not required.\r\n// 2. Altered source versions must be plainly marked as such, and must not be\r\n//   misrepresented as being the original software.\r\n// 3. This notice may not be removed or altered from any source distribution.\r\n\r\nmodule.exports = {\r\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\r\n  1:      'stream end',          /* Z_STREAM_END      1  */\r\n  0:      '',                    /* Z_OK              0  */\r\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\r\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\r\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\r\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\r\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\r\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\r\n};\r\n\r\n},{}],11:[function(require,module,exports){\r\n'use strict';\r\n\r\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\r\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\r\n//\r\n// This software is provided 'as-is', without any express or implied\r\n// warranty. In no event will the authors be held liable for any damages\r\n// arising from the use of this software.\r\n//\r\n// Permission is granted to anyone to use this software for any purpose,\r\n// including commercial applications, and to alter it and redistribute it\r\n// freely, subject to the following restrictions:\r\n//\r\n// 1. The origin of this software must not be misrepresented; you must not\r\n//   claim that you wrote the original software. If you use this software\r\n//   in a product, an acknowledgment in the product documentation would be\r\n//   appreciated but is not required.\r\n// 2. Altered source versions must be plainly marked as such, and must not be\r\n//   misrepresented as being the original software.\r\n// 3. This notice may not be removed or altered from any source distribution.\r\n\r\n/* eslint-disable space-unary-ops */\r\n\r\nvar utils = require('../utils/common');\r\n\r\n/* Public constants ==========================================================*/\r\n/* ===========================================================================*/\r\n\r\n\r\n//var Z_FILTERED          = 1;\r\n//var Z_HUFFMAN_ONLY      = 2;\r\n//var Z_RLE               = 3;\r\nvar Z_FIXED               = 4;\r\n//var Z_DEFAULT_STRATEGY  = 0;\r\n\r\n/* Possible values of the data_type field (though see inflate()) */\r\nvar Z_BINARY              = 0;\r\nvar Z_TEXT                = 1;\r\n//var Z_ASCII             = 1; // = Z_TEXT\r\nvar Z_UNKNOWN             = 2;\r\n\r\n/*============================================================================*/\r\n\r\n\r\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\r\n\r\n// From zutil.h\r\n\r\nvar STORED_BLOCK = 0;\r\nvar STATIC_TREES = 1;\r\nvar DYN_TREES    = 2;\r\n/* The three kinds of block type */\r\n\r\nvar MIN_MATCH    = 3;\r\nvar MAX_MATCH    = 258;\r\n/* The minimum and maximum match lengths */\r\n\r\n// From deflate.h\r\n/* ===========================================================================\r\n * Internal compression state.\r\n */\r\n\r\nvar LENGTH_CODES  = 29;\r\n/* number of length codes, not counting the special END_BLOCK code */\r\n\r\nvar LITERALS      = 256;\r\n/* number of literal bytes 0..255 */\r\n\r\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\r\n/* number of Literal or Length codes, including the END_BLOCK code */\r\n\r\nvar D_CODES       = 30;\r\n/* number of distance codes */\r\n\r\nvar BL_CODES      = 19;\r\n/* number of codes used to transfer the bit lengths */\r\n\r\nvar HEAP_SIZE     = 2 * L_CODES + 1;\r\n/* maximum heap size */\r\n\r\nvar MAX_BITS      = 15;\r\n/* All codes must not exceed MAX_BITS bits */\r\n\r\nvar Buf_size      = 16;\r\n/* size of bit buffer in bi_buf */\r\n\r\n\r\n/* ===========================================================================\r\n * Constants\r\n */\r\n\r\nvar MAX_BL_BITS = 7;\r\n/* Bit length codes must not exceed MAX_BL_BITS bits */\r\n\r\nvar END_BLOCK   = 256;\r\n/* end of block literal code */\r\n\r\nvar REP_3_6     = 16;\r\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\r\n\r\nvar REPZ_3_10   = 17;\r\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\r\n\r\nvar REPZ_11_138 = 18;\r\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\r\n\r\n/* eslint-disable comma-spacing,array-bracket-spacing */\r\nvar extra_lbits =   /* extra bits for each length code */\r\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\r\n\r\nvar extra_dbits =   /* extra bits for each distance code */\r\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\r\n\r\nvar extra_blbits =  /* extra bits for each bit length code */\r\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\r\n\r\nvar bl_order =\r\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\r\n/* eslint-enable comma-spacing,array-bracket-spacing */\r\n\r\n/* The lengths of the bit length codes are sent in order of decreasing\r\n * probability, to avoid transmitting the lengths for unused bit length codes.\r\n */\r\n\r\n/* ===========================================================================\r\n * Local data. These are initialized only once.\r\n */\r\n\r\n// We pre-fill arrays with 0 to avoid uninitialized gaps\r\n\r\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\r\n\r\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\r\nvar static_ltree  = new Array((L_CODES + 2) * 2);\r\nzero(static_ltree);\r\n/* The static literal tree. Since the bit lengths are imposed, there is no\r\n * need for the L_CODES extra codes used during heap construction. However\r\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\r\n * below).\r\n */\r\n\r\nvar static_dtree  = new Array(D_CODES * 2);\r\nzero(static_dtree);\r\n/* The static distance tree. (Actually a trivial tree since all codes use\r\n * 5 bits.)\r\n */\r\n\r\nvar _dist_code    = new Array(DIST_CODE_LEN);\r\nzero(_dist_code);\r\n/* Distance codes. The first 256 values correspond to the distances\r\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\r\n * the 15 bit distances.\r\n */\r\n\r\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\r\nzero(_length_code);\r\n/* length code for each normalized match length (0 == MIN_MATCH) */\r\n\r\nvar base_length   = new Array(LENGTH_CODES);\r\nzero(base_length);\r\n/* First normalized length for each code (0 = MIN_MATCH) */\r\n\r\nvar base_dist     = new Array(D_CODES);\r\nzero(base_dist);\r\n/* First normalized distance for each code (0 = distance of 1) */\r\n\r\n\r\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\r\n\r\n  this.static_tree  = static_tree;  /* static tree or NULL */\r\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\r\n  this.extra_base   = extra_base;   /* base index for extra_bits */\r\n  this.elems        = elems;        /* max number of elements in the tree */\r\n  this.max_length   = max_length;   /* max bit length for the codes */\r\n\r\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\r\n  this.has_stree    = static_tree && static_tree.length;\r\n}\r\n\r\n\r\nvar static_l_desc;\r\nvar static_d_desc;\r\nvar static_bl_desc;\r\n\r\n\r\nfunction TreeDesc(dyn_tree, stat_desc) {\r\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\r\n  this.max_code = 0;            /* largest code with non zero frequency */\r\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\r\n}\r\n\r\n\r\n\r\nfunction d_code(dist) {\r\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Output a short LSB first on the stream.\r\n * IN assertion: there is enough room in pendingBuf.\r\n */\r\nfunction put_short(s, w) {\r\n//    put_byte(s, (uch)((w) & 0xff));\r\n//    put_byte(s, (uch)((ush)(w) >> 8));\r\n  s.pending_buf[s.pending++] = (w) & 0xff;\r\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Send a value on a given number of bits.\r\n * IN assertion: length <= 16 and value fits in length bits.\r\n */\r\nfunction send_bits(s, value, length) {\r\n  if (s.bi_valid > (Buf_size - length)) {\r\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\r\n    put_short(s, s.bi_buf);\r\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\r\n    s.bi_valid += length - Buf_size;\r\n  } else {\r\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\r\n    s.bi_valid += length;\r\n  }\r\n}\r\n\r\n\r\nfunction send_code(s, c, tree) {\r\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Reverse the first len bits of a code, using straightforward code (a faster\r\n * method would use a table)\r\n * IN assertion: 1 <= len <= 15\r\n */\r\nfunction bi_reverse(code, len) {\r\n  var res = 0;\r\n  do {\r\n    res |= code & 1;\r\n    code >>>= 1;\r\n    res <<= 1;\r\n  } while (--len > 0);\r\n  return res >>> 1;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Flush the bit buffer, keeping at most 7 bits in it.\r\n */\r\nfunction bi_flush(s) {\r\n  if (s.bi_valid === 16) {\r\n    put_short(s, s.bi_buf);\r\n    s.bi_buf = 0;\r\n    s.bi_valid = 0;\r\n\r\n  } else if (s.bi_valid >= 8) {\r\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\r\n    s.bi_buf >>= 8;\r\n    s.bi_valid -= 8;\r\n  }\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Compute the optimal bit lengths for a tree and update the total bit length\r\n * for the current block.\r\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\r\n *    above are the tree nodes sorted by increasing frequency.\r\n * OUT assertions: the field len is set to the optimal bit length, the\r\n *     array bl_count contains the frequencies for each bit length.\r\n *     The length opt_len is updated; static_len is also updated if stree is\r\n *     not null.\r\n */\r\nfunction gen_bitlen(s, desc)\r\n//    deflate_state *s;\r\n//    tree_desc *desc;    /* the tree descriptor */\r\n{\r\n  var tree            = desc.dyn_tree;\r\n  var max_code        = desc.max_code;\r\n  var stree           = desc.stat_desc.static_tree;\r\n  var has_stree       = desc.stat_desc.has_stree;\r\n  var extra           = desc.stat_desc.extra_bits;\r\n  var base            = desc.stat_desc.extra_base;\r\n  var max_length      = desc.stat_desc.max_length;\r\n  var h;              /* heap index */\r\n  var n, m;           /* iterate over the tree elements */\r\n  var bits;           /* bit length */\r\n  var xbits;          /* extra bits */\r\n  var f;              /* frequency */\r\n  var overflow = 0;   /* number of elements with bit length too large */\r\n\r\n  for (bits = 0; bits <= MAX_BITS; bits++) {\r\n    s.bl_count[bits] = 0;\r\n  }\r\n\r\n  /* In a first pass, compute the optimal bit lengths (which may\r\n   * overflow in the case of the bit length tree).\r\n   */\r\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\r\n\r\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\r\n    n = s.heap[h];\r\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\r\n    if (bits > max_length) {\r\n      bits = max_length;\r\n      overflow++;\r\n    }\r\n    tree[n * 2 + 1]/*.Len*/ = bits;\r\n    /* We overwrite tree[n].Dad which is no longer needed */\r\n\r\n    if (n > max_code) { continue; } /* not a leaf node */\r\n\r\n    s.bl_count[bits]++;\r\n    xbits = 0;\r\n    if (n >= base) {\r\n      xbits = extra[n - base];\r\n    }\r\n    f = tree[n * 2]/*.Freq*/;\r\n    s.opt_len += f * (bits + xbits);\r\n    if (has_stree) {\r\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\r\n    }\r\n  }\r\n  if (overflow === 0) { return; }\r\n\r\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\r\n  /* This happens for example on obj2 and pic of the Calgary corpus */\r\n\r\n  /* Find the first bit length which could increase: */\r\n  do {\r\n    bits = max_length - 1;\r\n    while (s.bl_count[bits] === 0) { bits--; }\r\n    s.bl_count[bits]--;      /* move one leaf down the tree */\r\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\r\n    s.bl_count[max_length]--;\r\n    /* The brother of the overflow item also moves one step up,\r\n     * but this does not affect bl_count[max_length]\r\n     */\r\n    overflow -= 2;\r\n  } while (overflow > 0);\r\n\r\n  /* Now recompute all bit lengths, scanning in increasing frequency.\r\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\r\n   * lengths instead of fixing only the wrong ones. This idea is taken\r\n   * from 'ar' written by Haruhiko Okumura.)\r\n   */\r\n  for (bits = max_length; bits !== 0; bits--) {\r\n    n = s.bl_count[bits];\r\n    while (n !== 0) {\r\n      m = s.heap[--h];\r\n      if (m > max_code) { continue; }\r\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\r\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\r\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\r\n        tree[m * 2 + 1]/*.Len*/ = bits;\r\n      }\r\n      n--;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Generate the codes for a given tree and bit counts (which need not be\r\n * optimal).\r\n * IN assertion: the array bl_count contains the bit length statistics for\r\n * the given tree and the field len is set for all tree elements.\r\n * OUT assertion: the field code is set for all tree elements of non\r\n *     zero code length.\r\n */\r\nfunction gen_codes(tree, max_code, bl_count)\r\n//    ct_data *tree;             /* the tree to decorate */\r\n//    int max_code;              /* largest code with non zero frequency */\r\n//    ushf *bl_count;            /* number of codes at each bit length */\r\n{\r\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\r\n  var code = 0;              /* running code value */\r\n  var bits;                  /* bit index */\r\n  var n;                     /* code index */\r\n\r\n  /* The distribution counts are first used to generate the code values\r\n   * without bit reversal.\r\n   */\r\n  for (bits = 1; bits <= MAX_BITS; bits++) {\r\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\r\n  }\r\n  /* Check that the bit counts in bl_count are consistent. The last code\r\n   * must be all ones.\r\n   */\r\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\r\n  //        \"inconsistent bit counts\");\r\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\r\n\r\n  for (n = 0;  n <= max_code; n++) {\r\n    var len = tree[n * 2 + 1]/*.Len*/;\r\n    if (len === 0) { continue; }\r\n    /* Now reverse the bits */\r\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\r\n\r\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\r\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\r\n  }\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Initialize the various 'constant' tables.\r\n */\r\nfunction tr_static_init() {\r\n  var n;        /* iterates over tree elements */\r\n  var bits;     /* bit counter */\r\n  var length;   /* length value */\r\n  var code;     /* code value */\r\n  var dist;     /* distance index */\r\n  var bl_count = new Array(MAX_BITS + 1);\r\n  /* number of codes at each bit length for an optimal tree */\r\n\r\n  // do check in _tr_init()\r\n  //if (static_init_done) return;\r\n\r\n  /* For some embedded targets, global variables are not initialized: */\r\n/*#ifdef NO_INIT_GLOBAL_POINTERS\r\n  static_l_desc.static_tree = static_ltree;\r\n  static_l_desc.extra_bits = extra_lbits;\r\n  static_d_desc.static_tree = static_dtree;\r\n  static_d_desc.extra_bits = extra_dbits;\r\n  static_bl_desc.extra_bits = extra_blbits;\r\n#endif*/\r\n\r\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\r\n  length = 0;\r\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\r\n    base_length[code] = length;\r\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\r\n      _length_code[length++] = code;\r\n    }\r\n  }\r\n  //Assert (length == 256, \"tr_static_init: length != 256\");\r\n  /* Note that the length 255 (match length 258) can be represented\r\n   * in two different ways: code 284 + 5 bits or code 285, so we\r\n   * overwrite length_code[255] to use the best encoding:\r\n   */\r\n  _length_code[length - 1] = code;\r\n\r\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\r\n  dist = 0;\r\n  for (code = 0; code < 16; code++) {\r\n    base_dist[code] = dist;\r\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\r\n      _dist_code[dist++] = code;\r\n    }\r\n  }\r\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\r\n  dist >>= 7; /* from now on, all distances are divided by 128 */\r\n  for (; code < D_CODES; code++) {\r\n    base_dist[code] = dist << 7;\r\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\r\n      _dist_code[256 + dist++] = code;\r\n    }\r\n  }\r\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\r\n\r\n  /* Construct the codes of the static literal tree */\r\n  for (bits = 0; bits <= MAX_BITS; bits++) {\r\n    bl_count[bits] = 0;\r\n  }\r\n\r\n  n = 0;\r\n  while (n <= 143) {\r\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\r\n    n++;\r\n    bl_count[8]++;\r\n  }\r\n  while (n <= 255) {\r\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\r\n    n++;\r\n    bl_count[9]++;\r\n  }\r\n  while (n <= 279) {\r\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\r\n    n++;\r\n    bl_count[7]++;\r\n  }\r\n  while (n <= 287) {\r\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\r\n    n++;\r\n    bl_count[8]++;\r\n  }\r\n  /* Codes 286 and 287 do not exist, but we must include them in the\r\n   * tree construction to get a canonical Huffman tree (longest code\r\n   * all ones)\r\n   */\r\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\r\n\r\n  /* The static distance tree is trivial: */\r\n  for (n = 0; n < D_CODES; n++) {\r\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\r\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\r\n  }\r\n\r\n  // Now data ready and we can init static trees\r\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\r\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\r\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\r\n\r\n  //static_init_done = true;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Initialize a new block.\r\n */\r\nfunction init_block(s) {\r\n  var n; /* iterates over tree elements */\r\n\r\n  /* Initialize the trees. */\r\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\r\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\r\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\r\n\r\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\r\n  s.opt_len = s.static_len = 0;\r\n  s.last_lit = s.matches = 0;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Flush the bit buffer and align the output on a byte boundary\r\n */\r\nfunction bi_windup(s)\r\n{\r\n  if (s.bi_valid > 8) {\r\n    put_short(s, s.bi_buf);\r\n  } else if (s.bi_valid > 0) {\r\n    //put_byte(s, (Byte)s->bi_buf);\r\n    s.pending_buf[s.pending++] = s.bi_buf;\r\n  }\r\n  s.bi_buf = 0;\r\n  s.bi_valid = 0;\r\n}\r\n\r\n/* ===========================================================================\r\n * Copy a stored block, storing first the length and its\r\n * one's complement if requested.\r\n */\r\nfunction copy_block(s, buf, len, header)\r\n//DeflateState *s;\r\n//charf    *buf;    /* the input data */\r\n//unsigned len;     /* its length */\r\n//int      header;  /* true if block header must be written */\r\n{\r\n  bi_windup(s);        /* align on byte boundary */\r\n\r\n  if (header) {\r\n    put_short(s, len);\r\n    put_short(s, ~len);\r\n  }\r\n//  while (len--) {\r\n//    put_byte(s, *buf++);\r\n//  }\r\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\r\n  s.pending += len;\r\n}\r\n\r\n/* ===========================================================================\r\n * Compares to subtrees, using the tree depth as tie breaker when\r\n * the subtrees have equal frequency. This minimizes the worst case length.\r\n */\r\nfunction smaller(tree, n, m, depth) {\r\n  var _n2 = n * 2;\r\n  var _m2 = m * 2;\r\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\r\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\r\n}\r\n\r\n/* ===========================================================================\r\n * Restore the heap property by moving down the tree starting at node k,\r\n * exchanging a node with the smallest of its two sons if necessary, stopping\r\n * when the heap property is re-established (each father smaller than its\r\n * two sons).\r\n */\r\nfunction pqdownheap(s, tree, k)\r\n//    deflate_state *s;\r\n//    ct_data *tree;  /* the tree to restore */\r\n//    int k;               /* node to move down */\r\n{\r\n  var v = s.heap[k];\r\n  var j = k << 1;  /* left son of k */\r\n  while (j <= s.heap_len) {\r\n    /* Set j to the smallest of the two sons: */\r\n    if (j < s.heap_len &&\r\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\r\n      j++;\r\n    }\r\n    /* Exit if v is smaller than both sons */\r\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\r\n\r\n    /* Exchange v with the smallest son */\r\n    s.heap[k] = s.heap[j];\r\n    k = j;\r\n\r\n    /* And continue down the tree, setting j to the left son of k */\r\n    j <<= 1;\r\n  }\r\n  s.heap[k] = v;\r\n}\r\n\r\n\r\n// inlined manually\r\n// var SMALLEST = 1;\r\n\r\n/* ===========================================================================\r\n * Send the block data compressed using the given Huffman trees\r\n */\r\nfunction compress_block(s, ltree, dtree)\r\n//    deflate_state *s;\r\n//    const ct_data *ltree; /* literal tree */\r\n//    const ct_data *dtree; /* distance tree */\r\n{\r\n  var dist;           /* distance of matched string */\r\n  var lc;             /* match length or unmatched char (if dist == 0) */\r\n  var lx = 0;         /* running index in l_buf */\r\n  var code;           /* the code to send */\r\n  var extra;          /* number of extra bits to send */\r\n\r\n  if (s.last_lit !== 0) {\r\n    do {\r\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\r\n      lc = s.pending_buf[s.l_buf + lx];\r\n      lx++;\r\n\r\n      if (dist === 0) {\r\n        send_code(s, lc, ltree); /* send a literal byte */\r\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\r\n      } else {\r\n        /* Here, lc is the match length - MIN_MATCH */\r\n        code = _length_code[lc];\r\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\r\n        extra = extra_lbits[code];\r\n        if (extra !== 0) {\r\n          lc -= base_length[code];\r\n          send_bits(s, lc, extra);       /* send the extra length bits */\r\n        }\r\n        dist--; /* dist is now the match distance - 1 */\r\n        code = d_code(dist);\r\n        //Assert (code < D_CODES, \"bad d_code\");\r\n\r\n        send_code(s, code, dtree);       /* send the distance code */\r\n        extra = extra_dbits[code];\r\n        if (extra !== 0) {\r\n          dist -= base_dist[code];\r\n          send_bits(s, dist, extra);   /* send the extra distance bits */\r\n        }\r\n      } /* literal or match pair ? */\r\n\r\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\r\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\r\n      //       \"pendingBuf overflow\");\r\n\r\n    } while (lx < s.last_lit);\r\n  }\r\n\r\n  send_code(s, END_BLOCK, ltree);\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Construct one Huffman tree and assigns the code bit strings and lengths.\r\n * Update the total bit length for the current block.\r\n * IN assertion: the field freq is set for all tree elements.\r\n * OUT assertions: the fields len and code are set to the optimal bit length\r\n *     and corresponding code. The length opt_len is updated; static_len is\r\n *     also updated if stree is not null. The field max_code is set.\r\n */\r\nfunction build_tree(s, desc)\r\n//    deflate_state *s;\r\n//    tree_desc *desc; /* the tree descriptor */\r\n{\r\n  var tree     = desc.dyn_tree;\r\n  var stree    = desc.stat_desc.static_tree;\r\n  var has_stree = desc.stat_desc.has_stree;\r\n  var elems    = desc.stat_desc.elems;\r\n  var n, m;          /* iterate over heap elements */\r\n  var max_code = -1; /* largest code with non zero frequency */\r\n  var node;          /* new node being created */\r\n\r\n  /* Construct the initial heap, with least frequent element in\r\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\r\n   * heap[0] is not used.\r\n   */\r\n  s.heap_len = 0;\r\n  s.heap_max = HEAP_SIZE;\r\n\r\n  for (n = 0; n < elems; n++) {\r\n    if (tree[n * 2]/*.Freq*/ !== 0) {\r\n      s.heap[++s.heap_len] = max_code = n;\r\n      s.depth[n] = 0;\r\n\r\n    } else {\r\n      tree[n * 2 + 1]/*.Len*/ = 0;\r\n    }\r\n  }\r\n\r\n  /* The pkzip format requires that at least one distance code exists,\r\n   * and that at least one bit should be sent even if there is only one\r\n   * possible code. So to avoid special checks later on we force at least\r\n   * two codes of non zero frequency.\r\n   */\r\n  while (s.heap_len < 2) {\r\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\r\n    tree[node * 2]/*.Freq*/ = 1;\r\n    s.depth[node] = 0;\r\n    s.opt_len--;\r\n\r\n    if (has_stree) {\r\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\r\n    }\r\n    /* node is 0 or 1 so it does not have extra bits */\r\n  }\r\n  desc.max_code = max_code;\r\n\r\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\r\n   * establish sub-heaps of increasing lengths:\r\n   */\r\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\r\n\r\n  /* Construct the Huffman tree by repeatedly combining the least two\r\n   * frequent nodes.\r\n   */\r\n  node = elems;              /* next internal node of the tree */\r\n  do {\r\n    //pqremove(s, tree, n);  /* n = node of least frequency */\r\n    /*** pqremove ***/\r\n    n = s.heap[1/*SMALLEST*/];\r\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\r\n    pqdownheap(s, tree, 1/*SMALLEST*/);\r\n    /***/\r\n\r\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\r\n\r\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\r\n    s.heap[--s.heap_max] = m;\r\n\r\n    /* Create a new node father of n and m */\r\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\r\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\r\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\r\n\r\n    /* and insert the new node in the heap */\r\n    s.heap[1/*SMALLEST*/] = node++;\r\n    pqdownheap(s, tree, 1/*SMALLEST*/);\r\n\r\n  } while (s.heap_len >= 2);\r\n\r\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\r\n\r\n  /* At this point, the fields freq and dad are set. We can now\r\n   * generate the bit lengths.\r\n   */\r\n  gen_bitlen(s, desc);\r\n\r\n  /* The field len is now set, we can generate the bit codes */\r\n  gen_codes(tree, max_code, s.bl_count);\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Scan a literal or distance tree to determine the frequencies of the codes\r\n * in the bit length tree.\r\n */\r\nfunction scan_tree(s, tree, max_code)\r\n//    deflate_state *s;\r\n//    ct_data *tree;   /* the tree to be scanned */\r\n//    int max_code;    /* and its largest code of non zero frequency */\r\n{\r\n  var n;                     /* iterates over all tree elements */\r\n  var prevlen = -1;          /* last emitted length */\r\n  var curlen;                /* length of current code */\r\n\r\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\r\n\r\n  var count = 0;             /* repeat count of the current code */\r\n  var max_count = 7;         /* max repeat count */\r\n  var min_count = 4;         /* min repeat count */\r\n\r\n  if (nextlen === 0) {\r\n    max_count = 138;\r\n    min_count = 3;\r\n  }\r\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\r\n\r\n  for (n = 0; n <= max_code; n++) {\r\n    curlen = nextlen;\r\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\r\n\r\n    if (++count < max_count && curlen === nextlen) {\r\n      continue;\r\n\r\n    } else if (count < min_count) {\r\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\r\n\r\n    } else if (curlen !== 0) {\r\n\r\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\r\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\r\n\r\n    } else if (count <= 10) {\r\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\r\n\r\n    } else {\r\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\r\n    }\r\n\r\n    count = 0;\r\n    prevlen = curlen;\r\n\r\n    if (nextlen === 0) {\r\n      max_count = 138;\r\n      min_count = 3;\r\n\r\n    } else if (curlen === nextlen) {\r\n      max_count = 6;\r\n      min_count = 3;\r\n\r\n    } else {\r\n      max_count = 7;\r\n      min_count = 4;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Send a literal or distance tree in compressed form, using the codes in\r\n * bl_tree.\r\n */\r\nfunction send_tree(s, tree, max_code)\r\n//    deflate_state *s;\r\n//    ct_data *tree; /* the tree to be scanned */\r\n//    int max_code;       /* and its largest code of non zero frequency */\r\n{\r\n  var n;                     /* iterates over all tree elements */\r\n  var prevlen = -1;          /* last emitted length */\r\n  var curlen;                /* length of current code */\r\n\r\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\r\n\r\n  var count = 0;             /* repeat count of the current code */\r\n  var max_count = 7;         /* max repeat count */\r\n  var min_count = 4;         /* min repeat count */\r\n\r\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\r\n  if (nextlen === 0) {\r\n    max_count = 138;\r\n    min_count = 3;\r\n  }\r\n\r\n  for (n = 0; n <= max_code; n++) {\r\n    curlen = nextlen;\r\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\r\n\r\n    if (++count < max_count && curlen === nextlen) {\r\n      continue;\r\n\r\n    } else if (count < min_count) {\r\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\r\n\r\n    } else if (curlen !== 0) {\r\n      if (curlen !== prevlen) {\r\n        send_code(s, curlen, s.bl_tree);\r\n        count--;\r\n      }\r\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\r\n      send_code(s, REP_3_6, s.bl_tree);\r\n      send_bits(s, count - 3, 2);\r\n\r\n    } else if (count <= 10) {\r\n      send_code(s, REPZ_3_10, s.bl_tree);\r\n      send_bits(s, count - 3, 3);\r\n\r\n    } else {\r\n      send_code(s, REPZ_11_138, s.bl_tree);\r\n      send_bits(s, count - 11, 7);\r\n    }\r\n\r\n    count = 0;\r\n    prevlen = curlen;\r\n    if (nextlen === 0) {\r\n      max_count = 138;\r\n      min_count = 3;\r\n\r\n    } else if (curlen === nextlen) {\r\n      max_count = 6;\r\n      min_count = 3;\r\n\r\n    } else {\r\n      max_count = 7;\r\n      min_count = 4;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Construct the Huffman tree for the bit lengths and return the index in\r\n * bl_order of the last bit length code to send.\r\n */\r\nfunction build_bl_tree(s) {\r\n  var max_blindex;  /* index of last bit length code of non zero freq */\r\n\r\n  /* Determine the bit length frequencies for literal and distance trees */\r\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\r\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\r\n\r\n  /* Build the bit length tree: */\r\n  build_tree(s, s.bl_desc);\r\n  /* opt_len now includes the length of the tree representations, except\r\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\r\n   */\r\n\r\n  /* Determine the number of bit length codes to send. The pkzip format\r\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\r\n   * 3 but the actual value used is 4.)\r\n   */\r\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\r\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\r\n      break;\r\n    }\r\n  }\r\n  /* Update opt_len to include the bit length tree and counts */\r\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\r\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\r\n  //        s->opt_len, s->static_len));\r\n\r\n  return max_blindex;\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Send the header for a block using dynamic Huffman trees: the counts, the\r\n * lengths of the bit length codes, the literal tree and the distance tree.\r\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\r\n */\r\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\r\n//    deflate_state *s;\r\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\r\n{\r\n  var rank;                    /* index in bl_order */\r\n\r\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\r\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\r\n  //        \"too many codes\");\r\n  //Tracev((stderr, \"\\nbl counts: \"));\r\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\r\n  send_bits(s, dcodes - 1,   5);\r\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\r\n  for (rank = 0; rank < blcodes; rank++) {\r\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\r\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\r\n  }\r\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\r\n\r\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\r\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\r\n\r\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\r\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Check if the data type is TEXT or BINARY, using the following algorithm:\r\n * - TEXT if the two conditions below are satisfied:\r\n *    a) There are no non-portable control characters belonging to the\r\n *       \"black list\" (0..6, 14..25, 28..31).\r\n *    b) There is at least one printable character belonging to the\r\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\r\n * - BINARY otherwise.\r\n * - The following partially-portable control characters form a\r\n *   \"gray list\" that is ignored in this detection algorithm:\r\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\r\n * IN assertion: the fields Freq of dyn_ltree are set.\r\n */\r\nfunction detect_data_type(s) {\r\n  /* black_mask is the bit mask of black-listed bytes\r\n   * set bits 0..6, 14..25, and 28..31\r\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\r\n   */\r\n  var black_mask = 0xf3ffc07f;\r\n  var n;\r\n\r\n  /* Check for non-textual (\"black-listed\") bytes. */\r\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\r\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\r\n      return Z_BINARY;\r\n    }\r\n  }\r\n\r\n  /* Check for textual (\"white-listed\") bytes. */\r\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\r\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\r\n    return Z_TEXT;\r\n  }\r\n  for (n = 32; n < LITERALS; n++) {\r\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\r\n      return Z_TEXT;\r\n    }\r\n  }\r\n\r\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\r\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\r\n   */\r\n  return Z_BINARY;\r\n}\r\n\r\n\r\nvar static_init_done = false;\r\n\r\n/* ===========================================================================\r\n * Initialize the tree data structures for a new zlib stream.\r\n */\r\nfunction _tr_init(s)\r\n{\r\n\r\n  if (!static_init_done) {\r\n    tr_static_init();\r\n    static_init_done = true;\r\n  }\r\n\r\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\r\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\r\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\r\n\r\n  s.bi_buf = 0;\r\n  s.bi_valid = 0;\r\n\r\n  /* Initialize the first block of the first file: */\r\n  init_block(s);\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Send a stored block\r\n */\r\nfunction _tr_stored_block(s, buf, stored_len, last)\r\n//DeflateState *s;\r\n//charf *buf;       /* input block */\r\n//ulg stored_len;   /* length of input block */\r\n//int last;         /* one if this is the last block for a file */\r\n{\r\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\r\n  copy_block(s, buf, stored_len, true); /* with header */\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Send one empty static block to give enough lookahead for inflate.\r\n * This takes 10 bits, of which 7 may remain in the bit buffer.\r\n */\r\nfunction _tr_align(s) {\r\n  send_bits(s, STATIC_TREES << 1, 3);\r\n  send_code(s, END_BLOCK, static_ltree);\r\n  bi_flush(s);\r\n}\r\n\r\n\r\n/* ===========================================================================\r\n * Determine the best encoding for the current block: dynamic trees, static\r\n * trees or store, and output the encoded block to the zip file.\r\n */\r\nfunction _tr_flush_block(s, buf, stored_len, last)\r\n//DeflateState *s;\r\n//charf *buf;       /* input block, or NULL if too old */\r\n//ulg stored_len;   /* length of input block */\r\n//int last;         /* one if this is the last block for a file */\r\n{\r\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\r\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\r\n\r\n  /* Build the Huffman trees unless a stored block is forced */\r\n  if (s.level > 0) {\r\n\r\n    /* Check if the file is binary or text */\r\n    if (s.strm.data_type === Z_UNKNOWN) {\r\n      s.strm.data_type = detect_data_type(s);\r\n    }\r\n\r\n    /* Construct the literal and distance trees */\r\n    build_tree(s, s.l_desc);\r\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\r\n    //        s->static_len));\r\n\r\n    build_tree(s, s.d_desc);\r\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\r\n    //        s->static_len));\r\n    /* At this point, opt_len and static_len are the total bit lengths of\r\n     * the compressed block data, excluding the tree representations.\r\n     */\r\n\r\n    /* Build the bit length tree for the above two trees, and get the index\r\n     * in bl_order of the last bit length code to send.\r\n     */\r\n    max_blindex = build_bl_tree(s);\r\n\r\n    /* Determine the best encoding. Compute the block lengths in bytes. */\r\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\r\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\r\n\r\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\r\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\r\n    //        s->last_lit));\r\n\r\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\r\n\r\n  } else {\r\n    // Assert(buf != (char*)0, \"lost buf\");\r\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\r\n  }\r\n\r\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\r\n    /* 4: two words for the lengths */\r\n\r\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\r\n     * Otherwise we can't have processed more than WSIZE input bytes since\r\n     * the last block flush, because compression would have been\r\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\r\n     * transform a block into a stored block.\r\n     */\r\n    _tr_stored_block(s, buf, stored_len, last);\r\n\r\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\r\n\r\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\r\n    compress_block(s, static_ltree, static_dtree);\r\n\r\n  } else {\r\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\r\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\r\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\r\n  }\r\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\r\n  /* The above check is made mod 2^32, for files larger than 512 MB\r\n   * and uLong implemented on 32 bits.\r\n   */\r\n  init_block(s);\r\n\r\n  if (last) {\r\n    bi_windup(s);\r\n  }\r\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\r\n  //       s->compressed_len-7*last));\r\n}\r\n\r\n/* ===========================================================================\r\n * Save the match info and tally the frequency counts. Return true if\r\n * the current block must be flushed.\r\n */\r\nfunction _tr_tally(s, dist, lc)\r\n//    deflate_state *s;\r\n//    unsigned dist;  /* distance of matched string */\r\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\r\n{\r\n  //var out_length, in_length, dcode;\r\n\r\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\r\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\r\n\r\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\r\n  s.last_lit++;\r\n\r\n  if (dist === 0) {\r\n    /* lc is the unmatched char */\r\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\r\n  } else {\r\n    s.matches++;\r\n    /* Here, lc is the match length - MIN_MATCH */\r\n    dist--;             /* dist = match distance - 1 */\r\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\r\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\r\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\r\n\r\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\r\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\r\n  }\r\n\r\n// (!) This block is disabled in zlib defaults,\r\n// don't enable it for binary compatibility\r\n\r\n//#ifdef TRUNCATE_BLOCK\r\n//  /* Try to guess if it is profitable to stop the current block here */\r\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\r\n//    /* Compute an upper bound for the compressed length */\r\n//    out_length = s.last_lit*8;\r\n//    in_length = s.strstart - s.block_start;\r\n//\r\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\r\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\r\n//    }\r\n//    out_length >>>= 3;\r\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\r\n//    //       s->last_lit, in_length, out_length,\r\n//    //       100L - out_length*100L/in_length));\r\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\r\n//      return true;\r\n//    }\r\n//  }\r\n//#endif\r\n\r\n  return (s.last_lit === s.lit_bufsize - 1);\r\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\r\n   * on 16 bit machines and because stored blocks are restricted to\r\n   * 64K-1 bytes.\r\n   */\r\n}\r\n\r\nexports._tr_init  = _tr_init;\r\nexports._tr_stored_block = _tr_stored_block;\r\nexports._tr_flush_block  = _tr_flush_block;\r\nexports._tr_tally = _tr_tally;\r\nexports._tr_align = _tr_align;\r\n\r\n},{\"../utils/common\":5}],12:[function(require,module,exports){\r\n'use strict';\r\n\r\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\r\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\r\n//\r\n// This software is provided 'as-is', without any express or implied\r\n// warranty. In no event will the authors be held liable for any damages\r\n// arising from the use of this software.\r\n//\r\n// Permission is granted to anyone to use this software for any purpose,\r\n// including commercial applications, and to alter it and redistribute it\r\n// freely, subject to the following restrictions:\r\n//\r\n// 1. The origin of this software must not be misrepresented; you must not\r\n//   claim that you wrote the original software. If you use this software\r\n//   in a product, an acknowledgment in the product documentation would be\r\n//   appreciated but is not required.\r\n// 2. Altered source versions must be plainly marked as such, and must not be\r\n//   misrepresented as being the original software.\r\n// 3. This notice may not be removed or altered from any source distribution.\r\n\r\nfunction ZStream() {\r\n  /* next input byte */\r\n  this.input = null; // JS specific, because we have no pointers\r\n  this.next_in = 0;\r\n  /* number of bytes available at input */\r\n  this.avail_in = 0;\r\n  /* total number of input bytes read so far */\r\n  this.total_in = 0;\r\n  /* next output byte should be put there */\r\n  this.output = null; // JS specific, because we have no pointers\r\n  this.next_out = 0;\r\n  /* remaining free space at output */\r\n  this.avail_out = 0;\r\n  /* total number of bytes output so far */\r\n  this.total_out = 0;\r\n  /* last error message, NULL if no error */\r\n  this.msg = ''/*Z_NULL*/;\r\n  /* not visible by applications */\r\n  this.state = null;\r\n  /* best guess about the data type: binary or text */\r\n  this.data_type = 2/*Z_UNKNOWN*/;\r\n  /* adler32 value of the uncompressed data */\r\n  this.adler = 0;\r\n}\r\n\r\nmodule.exports = ZStream;\r\n\r\n},{}]},{},[3])(3)\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}