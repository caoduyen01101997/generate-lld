{"ast":null,"code":";\n(function (root, factory) {\n  // istanbul ignore next\n  if (typeof define === \"function\" && define.amd) {\n    // istanbul ignore next\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    // istanbul ignore next\n    root.regexpToAst = factory();\n  }\n})(typeof self !== \"undefined\" ?\n// istanbul ignore next\nself : this, function () {\n  // references\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  function RegExpParser() {}\n  RegExpParser.prototype.saveState = function () {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  };\n  RegExpParser.prototype.restoreState = function (newState) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  };\n  RegExpParser.prototype.pattern = function (input) {\n    // parser state\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    var value = this.disjunction();\n    this.consumeChar(\"/\");\n    var flags = {\n      type: \"Flags\",\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n    return {\n      type: \"Pattern\",\n      flags: flags,\n      value: value\n    };\n  };\n  RegExpParser.prototype.disjunction = function () {\n    var alts = [];\n    alts.push(this.alternative());\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n    return {\n      type: \"Disjunction\",\n      value: alts\n    };\n  };\n  RegExpParser.prototype.alternative = function () {\n    var terms = [];\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n    return {\n      type: \"Alternative\",\n      value: terms\n    };\n  };\n  RegExpParser.prototype.term = function () {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  };\n  RegExpParser.prototype.assertion = function () {\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\"\n        };\n      case \"$\":\n        return {\n          type: \"EndAnchor\"\n        };\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\"\n            };\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\"\n            };\n        }\n        // istanbul ignore next\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n      case \"(\":\n        this.consumeChar(\"?\");\n        var type;\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n        ASSERT_EXISTS(type);\n        var disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type: type,\n          value: disjunction\n        };\n    }\n    // istanbul ignore next\n    ASSERT_NEVER_REACH_HERE();\n  };\n  RegExpParser.prototype.quantifier = function (isBacktracking) {\n    var range;\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n      case \"{\":\n        var atLeast = this.integerIncludingZero();\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast: atLeast,\n              atMost: atLeast\n            };\n            break;\n          case \",\":\n            var atMost;\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast: atLeast,\n                atMost: atMost\n              };\n            } else {\n              range = {\n                atLeast: atLeast,\n                atMost: Infinity\n              };\n            }\n            this.consumeChar(\"}\");\n            break;\n        }\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n          return undefined;\n        }\n        ASSERT_EXISTS(range);\n        break;\n    }\n\n    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n    // causes severe performance degradations\n    if (isBacktracking === true && range === undefined) {\n      return undefined;\n    }\n    ASSERT_EXISTS(range);\n    if (this.peekChar(0) === \"?\") {\n      this.consumeChar(\"?\");\n      range.greedy = false;\n    } else {\n      range.greedy = true;\n    }\n    range.type = \"Quantifier\";\n    return range;\n  };\n  RegExpParser.prototype.atom = function () {\n    var atom;\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n      case \"[\":\n        atom = this.characterClass();\n        break;\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n    if (atom === undefined && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n    ASSERT_EXISTS(atom);\n    if (this.isQuantifier()) {\n      atom.quantifier = this.quantifier();\n    }\n    return atom;\n  };\n  RegExpParser.prototype.dotAll = function () {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  };\n  RegExpParser.prototype.atomEscape = function () {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n  RegExpParser.prototype.decimalEscapeAtom = function () {\n    var value = this.positiveInteger();\n    return {\n      type: \"GroupBackReference\",\n      value: value\n    };\n  };\n  RegExpParser.prototype.characterClassEscape = function () {\n    var set;\n    var complement = false;\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n      case \"w\":\n        set = wordCharCodes;\n        break;\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n    ASSERT_EXISTS(set);\n    return {\n      type: \"Set\",\n      value: set,\n      complement: complement\n    };\n  };\n  RegExpParser.prototype.controlEscapeAtom = function () {\n    var escapeCode;\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n      case \"t\":\n        escapeCode = cc(\"\\t\");\n        break;\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n    ASSERT_EXISTS(escapeCode);\n    return {\n      type: \"Character\",\n      value: escapeCode\n    };\n  };\n  RegExpParser.prototype.controlLetterEscapeAtom = function () {\n    this.consumeChar(\"c\");\n    var letter = this.popChar();\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n    var letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return {\n      type: \"Character\",\n      value: letterCode\n    };\n  };\n  RegExpParser.prototype.nulCharacterAtom = function () {\n    // TODO implement '[lookahead ∉ DecimalDigit]'\n    // TODO: for the deprecated octal escape sequence\n    this.consumeChar(\"0\");\n    return {\n      type: \"Character\",\n      value: cc(\"\\0\")\n    };\n  };\n  RegExpParser.prototype.hexEscapeSequenceAtom = function () {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  };\n  RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function () {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  };\n  RegExpParser.prototype.identityEscapeAtom = function () {\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n    var escapedChar = this.popChar();\n    return {\n      type: \"Character\",\n      value: cc(escapedChar)\n    };\n  };\n  RegExpParser.prototype.classPatternCharacterAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \"]\":\n        throw Error(\"TBD\");\n      default:\n        var nextChar = this.popChar();\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n  RegExpParser.prototype.characterClass = function () {\n    var set = [];\n    var complement = false;\n    this.consumeChar(\"[\");\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n    while (this.isClassAtom()) {\n      var from = this.classAtom();\n      var isFromSingleChar = from.type === \"Character\";\n      if (isFromSingleChar && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        var to = this.classAtom();\n        var isToSingleChar = to.type === \"Character\";\n\n        // a range can only be used when both sides are single characters\n        if (isToSingleChar) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n          set.push({\n            from: from.value,\n            to: to.value\n          });\n        } else {\n          // literal dash\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n    this.consumeChar(\"]\");\n    return {\n      type: \"Set\",\n      complement: complement,\n      value: set\n    };\n  };\n  RegExpParser.prototype.classAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\":\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n      case \"\\\\\":\n        return this.classEscape();\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  };\n  RegExpParser.prototype.classEscape = function () {\n    this.consumeChar(\"\\\\\");\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return {\n          type: \"Character\",\n          value: cc(\"\\u0008\")\n        };\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n      case \"0\":\n        return this.nulCharacterAtom();\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n  RegExpParser.prototype.group = function () {\n    var capturing = true;\n    this.consumeChar(\"(\");\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n      default:\n        this.groupIdx++;\n        break;\n    }\n    var value = this.disjunction();\n    this.consumeChar(\")\");\n    var groupAst = {\n      type: \"Group\",\n      capturing: capturing,\n      value: value\n    };\n    if (capturing) {\n      groupAst.idx = this.groupIdx;\n    }\n    return groupAst;\n  };\n  RegExpParser.prototype.positiveInteger = function () {\n    var number = this.popChar();\n\n    // istanbul ignore next - can't ever get here due to previous lookahead checks\n    // still implementing this error checking in case this ever changes.\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  };\n  RegExpParser.prototype.integerIncludingZero = function () {\n    var number = this.popChar();\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n    return parseInt(number, 10);\n  };\n  RegExpParser.prototype.patternCharacter = function () {\n    var nextChar = this.popChar();\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\":\n      // istanbul ignore next\n      case \"\\r\":\n      // istanbul ignore next\n      case \"\\u2028\":\n      // istanbul ignore next\n      case \"\\u2029\":\n      // istanbul ignore next\n      case \"^\":\n      // istanbul ignore next\n      case \"$\":\n      // istanbul ignore next\n      case \"\\\\\":\n      // istanbul ignore next\n      case \".\":\n      // istanbul ignore next\n      case \"*\":\n      // istanbul ignore next\n      case \"+\":\n      // istanbul ignore next\n      case \"?\":\n      // istanbul ignore next\n      case \"(\":\n      // istanbul ignore next\n      case \")\":\n      // istanbul ignore next\n      case \"[\":\n      // istanbul ignore next\n      case \"|\":\n        // istanbul ignore next\n        throw Error(\"TBD\");\n      default:\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n  RegExpParser.prototype.isRegExpFlag = function () {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  RegExpParser.prototype.isRangeDash = function () {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  };\n  RegExpParser.prototype.isDigit = function () {\n    return decimalPattern.test(this.peekChar(0));\n  };\n  RegExpParser.prototype.isClassAtom = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  };\n  RegExpParser.prototype.isTerm = function () {\n    return this.isAtom() || this.isAssertion();\n  };\n  RegExpParser.prototype.isAtom = function () {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\": // atomEscape\n      case \"[\": // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n      case \"(\":\n        // group\n        return true;\n      default:\n        return false;\n    }\n  };\n  RegExpParser.prototype.isAssertion = function () {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n          default:\n            return false;\n        }\n      // '(?=' or '(?!'\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n      default:\n        return false;\n    }\n  };\n  RegExpParser.prototype.isQuantifier = function () {\n    var prevState = this.saveState();\n    try {\n      return this.quantifier(true) !== undefined;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  };\n  RegExpParser.prototype.isPatternCharacter = function () {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n      default:\n        return true;\n    }\n  };\n  RegExpParser.prototype.parseHexDigits = function (howMany) {\n    var hexString = \"\";\n    for (var i = 0; i < howMany; i++) {\n      var hexChar = this.popChar();\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n      hexString += hexChar;\n    }\n    var charCode = parseInt(hexString, 16);\n    return {\n      type: \"Character\",\n      value: charCode\n    };\n  };\n  RegExpParser.prototype.peekChar = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n    return this.input[this.idx + howMuch];\n  };\n  RegExpParser.prototype.popChar = function () {\n    var nextChar = this.peekChar(0);\n    this.consumeChar();\n    return nextChar;\n  };\n  RegExpParser.prototype.consumeChar = function (char) {\n    if (char !== undefined && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n    this.idx++;\n  };\n\n  // consts and utilities\n  var hexDigitPattern = /[0-9a-fA-F]/;\n  var decimalPattern = /[0-9]/;\n  var decimalPatternNoZero = /[1-9]/;\n  function cc(char) {\n    return char.charCodeAt(0);\n  }\n  function insertToSet(item, set) {\n    if (item.length !== undefined) {\n      item.forEach(function (subItem) {\n        set.push(subItem);\n      });\n    } else {\n      set.push(item);\n    }\n  }\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw \"duplicate flag \" + flagKey;\n    }\n    flagObj[flagKey] = true;\n  }\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error(\"Internal Error - Should never get here!\");\n    }\n  }\n\n  // istanbul ignore next\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n  var i;\n  var digitsCharCodes = [];\n  for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n  }\n  var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\n  for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n  }\n  for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n  var whitespaceCodes = [cc(\" \"), cc(\"\\f\"), cc(\"\\n\"), cc(\"\\r\"), cc(\"\\t\"), cc(\"\\v\"), cc(\"\\t\"), cc(\"\\u00a0\"), cc(\"\\u1680\"), cc(\"\\u2000\"), cc(\"\\u2001\"), cc(\"\\u2002\"), cc(\"\\u2003\"), cc(\"\\u2004\"), cc(\"\\u2005\"), cc(\"\\u2006\"), cc(\"\\u2007\"), cc(\"\\u2008\"), cc(\"\\u2009\"), cc(\"\\u200a\"), cc(\"\\u2028\"), cc(\"\\u2029\"), cc(\"\\u202f\"), cc(\"\\u205f\"), cc(\"\\u3000\"), cc(\"\\ufeff\")];\n  function BaseRegExpVisitor() {}\n  BaseRegExpVisitor.prototype.visitChildren = function (node) {\n    for (var key in node) {\n      var child = node[key];\n      /* istanbul ignore else */\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== undefined) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach(function (subChild) {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  };\n  BaseRegExpVisitor.prototype.visit = function (node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n      case \"Set\":\n        this.visitSet(node);\n        break;\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n    this.visitChildren(node);\n  };\n  BaseRegExpVisitor.prototype.visitPattern = function (node) {};\n  BaseRegExpVisitor.prototype.visitFlags = function (node) {};\n  BaseRegExpVisitor.prototype.visitDisjunction = function (node) {};\n  BaseRegExpVisitor.prototype.visitAlternative = function (node) {};\n\n  // Assertion\n  BaseRegExpVisitor.prototype.visitStartAnchor = function (node) {};\n  BaseRegExpVisitor.prototype.visitEndAnchor = function (node) {};\n  BaseRegExpVisitor.prototype.visitWordBoundary = function (node) {};\n  BaseRegExpVisitor.prototype.visitNonWordBoundary = function (node) {};\n  BaseRegExpVisitor.prototype.visitLookahead = function (node) {};\n  BaseRegExpVisitor.prototype.visitNegativeLookahead = function (node) {};\n\n  // atoms\n  BaseRegExpVisitor.prototype.visitCharacter = function (node) {};\n  BaseRegExpVisitor.prototype.visitSet = function (node) {};\n  BaseRegExpVisitor.prototype.visitGroup = function (node) {};\n  BaseRegExpVisitor.prototype.visitGroupBackReference = function (node) {};\n  BaseRegExpVisitor.prototype.visitQuantifier = function (node) {};\n  return {\n    RegExpParser: RegExpParser,\n    BaseRegExpVisitor: BaseRegExpVisitor,\n    VERSION: \"0.4.0\"\n  };\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","regexpToAst","self","RegExpParser","prototype","saveState","idx","input","groupIdx","restoreState","newState","pattern","consumeChar","value","disjunction","flags","type","global","ignoreCase","multiLine","unicode","sticky","isRegExpFlag","popChar","addFlag","length","Error","substring","alts","push","alternative","peekChar","terms","isTerm","term","isAssertion","assertion","atom","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","quantifier","isBacktracking","range","atLeast","atMost","Infinity","integerIncludingZero","isDigit","undefined","greedy","dotAll","atomEscape","characterClass","group","isPatternCharacter","patternCharacter","isQuantifier","complement","cc","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","set","digitsCharCodes","whitespaceCodes","wordCharCodes","escapeCode","letter","test","letterCode","toUpperCase","charCodeAt","parseHexDigits","escapedChar","classPatternCharacterAtom","nextChar","isClassAtom","from","classAtom","isFromSingleChar","isRangeDash","to","isToSingleChar","insertToSet","classEscape","capturing","groupAst","number","decimalPatternNoZero","decimalPattern","parseInt","howMuch","isAtom","prevState","e","howMany","hexString","i","hexChar","hexDigitPattern","charCode","char","item","forEach","subItem","flagObj","flagKey","obj","concat","BaseRegExpVisitor","visitChildren","node","key","child","hasOwnProperty","visit","Array","isArray","subChild","visitPattern","visitFlags","visitDisjunction","visitAlternative","visitStartAnchor","visitEndAnchor","visitWordBoundary","visitNonWordBoundary","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","visitGroup","visitGroupBackReference","visitQuantifier","VERSION"],"sources":["D:/sourcecode/create-json-type/your-app/generate-lld/node_modules/regexp-to-ast/lib/regexp-to-ast.js"],"sourcesContent":[";(function(root, factory) {\r\n    // istanbul ignore next\r\n    if (typeof define === \"function\" && define.amd) {\r\n        // istanbul ignore next\r\n        define([], factory)\r\n    } else if (typeof module === \"object\" && module.exports) {\r\n        module.exports = factory()\r\n    } else {\r\n        // istanbul ignore next\r\n        root.regexpToAst = factory()\r\n    }\r\n})(\r\n    typeof self !== \"undefined\"\r\n        ? // istanbul ignore next\r\n          self\r\n        : this,\r\n    function() {\r\n        // references\r\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\r\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\r\n        function RegExpParser() {}\r\n\r\n        RegExpParser.prototype.saveState = function() {\r\n            return {\r\n                idx: this.idx,\r\n                input: this.input,\r\n                groupIdx: this.groupIdx\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.restoreState = function(newState) {\r\n            this.idx = newState.idx\r\n            this.input = newState.input\r\n            this.groupIdx = newState.groupIdx\r\n        }\r\n\r\n        RegExpParser.prototype.pattern = function(input) {\r\n            // parser state\r\n            this.idx = 0\r\n            this.input = input\r\n            this.groupIdx = 0\r\n\r\n            this.consumeChar(\"/\")\r\n            var value = this.disjunction()\r\n            this.consumeChar(\"/\")\r\n\r\n            var flags = {\r\n                type: \"Flags\",\r\n                global: false,\r\n                ignoreCase: false,\r\n                multiLine: false,\r\n                unicode: false,\r\n                sticky: false\r\n            }\r\n\r\n            while (this.isRegExpFlag()) {\r\n                switch (this.popChar()) {\r\n                    case \"g\":\r\n                        addFlag(flags, \"global\")\r\n                        break\r\n                    case \"i\":\r\n                        addFlag(flags, \"ignoreCase\")\r\n                        break\r\n                    case \"m\":\r\n                        addFlag(flags, \"multiLine\")\r\n                        break\r\n                    case \"u\":\r\n                        addFlag(flags, \"unicode\")\r\n                        break\r\n                    case \"y\":\r\n                        addFlag(flags, \"sticky\")\r\n                        break\r\n                }\r\n            }\r\n\r\n            if (this.idx !== this.input.length) {\r\n                throw Error(\r\n                    \"Redundant input: \" + this.input.substring(this.idx)\r\n                )\r\n            }\r\n            return { type: \"Pattern\", flags: flags, value: value }\r\n        }\r\n\r\n        RegExpParser.prototype.disjunction = function() {\r\n            var alts = []\r\n            alts.push(this.alternative())\r\n\r\n            while (this.peekChar() === \"|\") {\r\n                this.consumeChar(\"|\")\r\n                alts.push(this.alternative())\r\n            }\r\n\r\n            return { type: \"Disjunction\", value: alts }\r\n        }\r\n\r\n        RegExpParser.prototype.alternative = function() {\r\n            var terms = []\r\n\r\n            while (this.isTerm()) {\r\n                terms.push(this.term())\r\n            }\r\n\r\n            return { type: \"Alternative\", value: terms }\r\n        }\r\n\r\n        RegExpParser.prototype.term = function() {\r\n            if (this.isAssertion()) {\r\n                return this.assertion()\r\n            } else {\r\n                return this.atom()\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.assertion = function() {\r\n            switch (this.popChar()) {\r\n                case \"^\":\r\n                    return { type: \"StartAnchor\" }\r\n                case \"$\":\r\n                    return { type: \"EndAnchor\" }\r\n                // '\\b' or '\\B'\r\n                case \"\\\\\":\r\n                    switch (this.popChar()) {\r\n                        case \"b\":\r\n                            return { type: \"WordBoundary\" }\r\n                        case \"B\":\r\n                            return { type: \"NonWordBoundary\" }\r\n                    }\r\n                    // istanbul ignore next\r\n                    throw Error(\"Invalid Assertion Escape\")\r\n                // '(?=' or '(?!'\r\n                case \"(\":\r\n                    this.consumeChar(\"?\")\r\n\r\n                    var type\r\n                    switch (this.popChar()) {\r\n                        case \"=\":\r\n                            type = \"Lookahead\"\r\n                            break\r\n                        case \"!\":\r\n                            type = \"NegativeLookahead\"\r\n                            break\r\n                    }\r\n                    ASSERT_EXISTS(type)\r\n\r\n                    var disjunction = this.disjunction()\r\n\r\n                    this.consumeChar(\")\")\r\n\r\n                    return { type: type, value: disjunction }\r\n            }\r\n            // istanbul ignore next\r\n            ASSERT_NEVER_REACH_HERE()\r\n        }\r\n\r\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\r\n            var range\r\n            switch (this.popChar()) {\r\n                case \"*\":\r\n                    range = {\r\n                        atLeast: 0,\r\n                        atMost: Infinity\r\n                    }\r\n                    break\r\n                case \"+\":\r\n                    range = {\r\n                        atLeast: 1,\r\n                        atMost: Infinity\r\n                    }\r\n                    break\r\n                case \"?\":\r\n                    range = {\r\n                        atLeast: 0,\r\n                        atMost: 1\r\n                    }\r\n                    break\r\n                case \"{\":\r\n                    var atLeast = this.integerIncludingZero()\r\n                    switch (this.popChar()) {\r\n                        case \"}\":\r\n                            range = {\r\n                                atLeast: atLeast,\r\n                                atMost: atLeast\r\n                            }\r\n                            break\r\n                        case \",\":\r\n                            var atMost\r\n                            if (this.isDigit()) {\r\n                                atMost = this.integerIncludingZero()\r\n                                range = {\r\n                                    atLeast: atLeast,\r\n                                    atMost: atMost\r\n                                }\r\n                            } else {\r\n                                range = {\r\n                                    atLeast: atLeast,\r\n                                    atMost: Infinity\r\n                                }\r\n                            }\r\n                            this.consumeChar(\"}\")\r\n                            break\r\n                    }\r\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\r\n                    // causes severe performance degradations\r\n                    if (isBacktracking === true && range === undefined) {\r\n                        return undefined\r\n                    }\r\n                    ASSERT_EXISTS(range)\r\n                    break\r\n            }\r\n\r\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\r\n            // causes severe performance degradations\r\n            if (isBacktracking === true && range === undefined) {\r\n                return undefined\r\n            }\r\n\r\n            ASSERT_EXISTS(range)\r\n\r\n            if (this.peekChar(0) === \"?\") {\r\n                this.consumeChar(\"?\")\r\n                range.greedy = false\r\n            } else {\r\n                range.greedy = true\r\n            }\r\n\r\n            range.type = \"Quantifier\"\r\n            return range\r\n        }\r\n\r\n        RegExpParser.prototype.atom = function() {\r\n            var atom\r\n            switch (this.peekChar()) {\r\n                case \".\":\r\n                    atom = this.dotAll()\r\n                    break\r\n                case \"\\\\\":\r\n                    atom = this.atomEscape()\r\n                    break\r\n                case \"[\":\r\n                    atom = this.characterClass()\r\n                    break\r\n                case \"(\":\r\n                    atom = this.group()\r\n                    break\r\n            }\r\n\r\n            if (atom === undefined && this.isPatternCharacter()) {\r\n                atom = this.patternCharacter()\r\n            }\r\n\r\n            ASSERT_EXISTS(atom)\r\n\r\n            if (this.isQuantifier()) {\r\n                atom.quantifier = this.quantifier()\r\n            }\r\n\r\n            return atom\r\n        }\r\n\r\n        RegExpParser.prototype.dotAll = function() {\r\n            this.consumeChar(\".\")\r\n            return {\r\n                type: \"Set\",\r\n                complement: true,\r\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.atomEscape = function() {\r\n            this.consumeChar(\"\\\\\")\r\n\r\n            switch (this.peekChar()) {\r\n                case \"1\":\r\n                case \"2\":\r\n                case \"3\":\r\n                case \"4\":\r\n                case \"5\":\r\n                case \"6\":\r\n                case \"7\":\r\n                case \"8\":\r\n                case \"9\":\r\n                    return this.decimalEscapeAtom()\r\n                case \"d\":\r\n                case \"D\":\r\n                case \"s\":\r\n                case \"S\":\r\n                case \"w\":\r\n                case \"W\":\r\n                    return this.characterClassEscape()\r\n                case \"f\":\r\n                case \"n\":\r\n                case \"r\":\r\n                case \"t\":\r\n                case \"v\":\r\n                    return this.controlEscapeAtom()\r\n                case \"c\":\r\n                    return this.controlLetterEscapeAtom()\r\n                case \"0\":\r\n                    return this.nulCharacterAtom()\r\n                case \"x\":\r\n                    return this.hexEscapeSequenceAtom()\r\n                case \"u\":\r\n                    return this.regExpUnicodeEscapeSequenceAtom()\r\n                default:\r\n                    return this.identityEscapeAtom()\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.decimalEscapeAtom = function() {\r\n            var value = this.positiveInteger()\r\n\r\n            return { type: \"GroupBackReference\", value: value }\r\n        }\r\n\r\n        RegExpParser.prototype.characterClassEscape = function() {\r\n            var set\r\n            var complement = false\r\n            switch (this.popChar()) {\r\n                case \"d\":\r\n                    set = digitsCharCodes\r\n                    break\r\n                case \"D\":\r\n                    set = digitsCharCodes\r\n                    complement = true\r\n                    break\r\n                case \"s\":\r\n                    set = whitespaceCodes\r\n                    break\r\n                case \"S\":\r\n                    set = whitespaceCodes\r\n                    complement = true\r\n                    break\r\n                case \"w\":\r\n                    set = wordCharCodes\r\n                    break\r\n                case \"W\":\r\n                    set = wordCharCodes\r\n                    complement = true\r\n                    break\r\n            }\r\n\r\n            ASSERT_EXISTS(set)\r\n\r\n            return { type: \"Set\", value: set, complement: complement }\r\n        }\r\n\r\n        RegExpParser.prototype.controlEscapeAtom = function() {\r\n            var escapeCode\r\n            switch (this.popChar()) {\r\n                case \"f\":\r\n                    escapeCode = cc(\"\\f\")\r\n                    break\r\n                case \"n\":\r\n                    escapeCode = cc(\"\\n\")\r\n                    break\r\n                case \"r\":\r\n                    escapeCode = cc(\"\\r\")\r\n                    break\r\n                case \"t\":\r\n                    escapeCode = cc(\"\\t\")\r\n                    break\r\n                case \"v\":\r\n                    escapeCode = cc(\"\\v\")\r\n                    break\r\n            }\r\n            ASSERT_EXISTS(escapeCode)\r\n\r\n            return { type: \"Character\", value: escapeCode }\r\n        }\r\n\r\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\r\n            this.consumeChar(\"c\")\r\n            var letter = this.popChar()\r\n            if (/[a-zA-Z]/.test(letter) === false) {\r\n                throw Error(\"Invalid \")\r\n            }\r\n\r\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\r\n            return { type: \"Character\", value: letterCode }\r\n        }\r\n\r\n        RegExpParser.prototype.nulCharacterAtom = function() {\r\n            // TODO implement '[lookahead ∉ DecimalDigit]'\r\n            // TODO: for the deprecated octal escape sequence\r\n            this.consumeChar(\"0\")\r\n            return { type: \"Character\", value: cc(\"\\0\") }\r\n        }\r\n\r\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\r\n            this.consumeChar(\"x\")\r\n            return this.parseHexDigits(2)\r\n        }\r\n\r\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\r\n            this.consumeChar(\"u\")\r\n            return this.parseHexDigits(4)\r\n        }\r\n\r\n        RegExpParser.prototype.identityEscapeAtom = function() {\r\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\r\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\r\n            var escapedChar = this.popChar()\r\n            return { type: \"Character\", value: cc(escapedChar) }\r\n        }\r\n\r\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\r\n            switch (this.peekChar()) {\r\n                // istanbul ignore next\r\n                case \"\\n\":\r\n                // istanbul ignore next\r\n                case \"\\r\":\r\n                // istanbul ignore next\r\n                case \"\\u2028\":\r\n                // istanbul ignore next\r\n                case \"\\u2029\":\r\n                // istanbul ignore next\r\n                case \"\\\\\":\r\n                // istanbul ignore next\r\n                case \"]\":\r\n                    throw Error(\"TBD\")\r\n                default:\r\n                    var nextChar = this.popChar()\r\n                    return { type: \"Character\", value: cc(nextChar) }\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.characterClass = function() {\r\n            var set = []\r\n            var complement = false\r\n            this.consumeChar(\"[\")\r\n            if (this.peekChar(0) === \"^\") {\r\n                this.consumeChar(\"^\")\r\n                complement = true\r\n            }\r\n\r\n            while (this.isClassAtom()) {\r\n                var from = this.classAtom()\r\n                var isFromSingleChar = from.type === \"Character\"\r\n                if (isFromSingleChar && this.isRangeDash()) {\r\n                    this.consumeChar(\"-\")\r\n                    var to = this.classAtom()\r\n                    var isToSingleChar = to.type === \"Character\"\r\n\r\n                    // a range can only be used when both sides are single characters\r\n                    if (isToSingleChar) {\r\n                        if (to.value < from.value) {\r\n                            throw Error(\"Range out of order in character class\")\r\n                        }\r\n                        set.push({ from: from.value, to: to.value })\r\n                    } else {\r\n                        // literal dash\r\n                        insertToSet(from.value, set)\r\n                        set.push(cc(\"-\"))\r\n                        insertToSet(to.value, set)\r\n                    }\r\n                } else {\r\n                    insertToSet(from.value, set)\r\n                }\r\n            }\r\n\r\n            this.consumeChar(\"]\")\r\n\r\n            return { type: \"Set\", complement: complement, value: set }\r\n        }\r\n\r\n        RegExpParser.prototype.classAtom = function() {\r\n            switch (this.peekChar()) {\r\n                // istanbul ignore next\r\n                case \"]\":\r\n                // istanbul ignore next\r\n                case \"\\n\":\r\n                // istanbul ignore next\r\n                case \"\\r\":\r\n                // istanbul ignore next\r\n                case \"\\u2028\":\r\n                // istanbul ignore next\r\n                case \"\\u2029\":\r\n                    throw Error(\"TBD\")\r\n                case \"\\\\\":\r\n                    return this.classEscape()\r\n                default:\r\n                    return this.classPatternCharacterAtom()\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.classEscape = function() {\r\n            this.consumeChar(\"\\\\\")\r\n            switch (this.peekChar()) {\r\n                // Matches a backspace.\r\n                // (Not to be confused with \\b word boundary outside characterClass)\r\n                case \"b\":\r\n                    this.consumeChar(\"b\")\r\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\r\n                case \"d\":\r\n                case \"D\":\r\n                case \"s\":\r\n                case \"S\":\r\n                case \"w\":\r\n                case \"W\":\r\n                    return this.characterClassEscape()\r\n                case \"f\":\r\n                case \"n\":\r\n                case \"r\":\r\n                case \"t\":\r\n                case \"v\":\r\n                    return this.controlEscapeAtom()\r\n                case \"c\":\r\n                    return this.controlLetterEscapeAtom()\r\n                case \"0\":\r\n                    return this.nulCharacterAtom()\r\n                case \"x\":\r\n                    return this.hexEscapeSequenceAtom()\r\n                case \"u\":\r\n                    return this.regExpUnicodeEscapeSequenceAtom()\r\n                default:\r\n                    return this.identityEscapeAtom()\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.group = function() {\r\n            var capturing = true\r\n            this.consumeChar(\"(\")\r\n            switch (this.peekChar(0)) {\r\n                case \"?\":\r\n                    this.consumeChar(\"?\")\r\n                    this.consumeChar(\":\")\r\n                    capturing = false\r\n                    break\r\n                default:\r\n                    this.groupIdx++\r\n                    break\r\n            }\r\n            var value = this.disjunction()\r\n            this.consumeChar(\")\")\r\n\r\n            var groupAst = {\r\n                type: \"Group\",\r\n                capturing: capturing,\r\n                value: value\r\n            }\r\n\r\n            if (capturing) {\r\n                groupAst.idx = this.groupIdx\r\n            }\r\n\r\n            return groupAst\r\n        }\r\n\r\n        RegExpParser.prototype.positiveInteger = function() {\r\n            var number = this.popChar()\r\n\r\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\r\n            // still implementing this error checking in case this ever changes.\r\n            if (decimalPatternNoZero.test(number) === false) {\r\n                throw Error(\"Expecting a positive integer\")\r\n            }\r\n\r\n            while (decimalPattern.test(this.peekChar(0))) {\r\n                number += this.popChar()\r\n            }\r\n\r\n            return parseInt(number, 10)\r\n        }\r\n\r\n        RegExpParser.prototype.integerIncludingZero = function() {\r\n            var number = this.popChar()\r\n            if (decimalPattern.test(number) === false) {\r\n                throw Error(\"Expecting an integer\")\r\n            }\r\n\r\n            while (decimalPattern.test(this.peekChar(0))) {\r\n                number += this.popChar()\r\n            }\r\n\r\n            return parseInt(number, 10)\r\n        }\r\n\r\n        RegExpParser.prototype.patternCharacter = function() {\r\n            var nextChar = this.popChar()\r\n            switch (nextChar) {\r\n                // istanbul ignore next\r\n                case \"\\n\":\r\n                // istanbul ignore next\r\n                case \"\\r\":\r\n                // istanbul ignore next\r\n                case \"\\u2028\":\r\n                // istanbul ignore next\r\n                case \"\\u2029\":\r\n                // istanbul ignore next\r\n                case \"^\":\r\n                // istanbul ignore next\r\n                case \"$\":\r\n                // istanbul ignore next\r\n                case \"\\\\\":\r\n                // istanbul ignore next\r\n                case \".\":\r\n                // istanbul ignore next\r\n                case \"*\":\r\n                // istanbul ignore next\r\n                case \"+\":\r\n                // istanbul ignore next\r\n                case \"?\":\r\n                // istanbul ignore next\r\n                case \"(\":\r\n                // istanbul ignore next\r\n                case \")\":\r\n                // istanbul ignore next\r\n                case \"[\":\r\n                // istanbul ignore next\r\n                case \"|\":\r\n                    // istanbul ignore next\r\n                    throw Error(\"TBD\")\r\n                default:\r\n                    return { type: \"Character\", value: cc(nextChar) }\r\n            }\r\n        }\r\n        RegExpParser.prototype.isRegExpFlag = function() {\r\n            switch (this.peekChar(0)) {\r\n                case \"g\":\r\n                case \"i\":\r\n                case \"m\":\r\n                case \"u\":\r\n                case \"y\":\r\n                    return true\r\n                default:\r\n                    return false\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.isRangeDash = function() {\r\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\r\n        }\r\n\r\n        RegExpParser.prototype.isDigit = function() {\r\n            return decimalPattern.test(this.peekChar(0))\r\n        }\r\n\r\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\r\n            if (howMuch === undefined) {\r\n                howMuch = 0\r\n            }\r\n\r\n            switch (this.peekChar(howMuch)) {\r\n                case \"]\":\r\n                case \"\\n\":\r\n                case \"\\r\":\r\n                case \"\\u2028\":\r\n                case \"\\u2029\":\r\n                    return false\r\n                default:\r\n                    return true\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.isTerm = function() {\r\n            return this.isAtom() || this.isAssertion()\r\n        }\r\n\r\n        RegExpParser.prototype.isAtom = function() {\r\n            if (this.isPatternCharacter()) {\r\n                return true\r\n            }\r\n\r\n            switch (this.peekChar(0)) {\r\n                case \".\":\r\n                case \"\\\\\": // atomEscape\r\n                case \"[\": // characterClass\r\n                // TODO: isAtom must be called before isAssertion - disambiguate\r\n                case \"(\": // group\r\n                    return true\r\n                default:\r\n                    return false\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.isAssertion = function() {\r\n            switch (this.peekChar(0)) {\r\n                case \"^\":\r\n                case \"$\":\r\n                    return true\r\n                // '\\b' or '\\B'\r\n                case \"\\\\\":\r\n                    switch (this.peekChar(1)) {\r\n                        case \"b\":\r\n                        case \"B\":\r\n                            return true\r\n                        default:\r\n                            return false\r\n                    }\r\n                // '(?=' or '(?!'\r\n                case \"(\":\r\n                    return (\r\n                        this.peekChar(1) === \"?\" &&\r\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\r\n                    )\r\n                default:\r\n                    return false\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.isQuantifier = function() {\r\n            var prevState = this.saveState()\r\n            try {\r\n                return this.quantifier(true) !== undefined\r\n            } catch (e) {\r\n                return false\r\n            } finally {\r\n                this.restoreState(prevState)\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.isPatternCharacter = function() {\r\n            switch (this.peekChar()) {\r\n                case \"^\":\r\n                case \"$\":\r\n                case \"\\\\\":\r\n                case \".\":\r\n                case \"*\":\r\n                case \"+\":\r\n                case \"?\":\r\n                case \"(\":\r\n                case \")\":\r\n                case \"[\":\r\n                case \"|\":\r\n                case \"/\":\r\n                case \"\\n\":\r\n                case \"\\r\":\r\n                case \"\\u2028\":\r\n                case \"\\u2029\":\r\n                    return false\r\n                default:\r\n                    return true\r\n            }\r\n        }\r\n\r\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\r\n            var hexString = \"\"\r\n            for (var i = 0; i < howMany; i++) {\r\n                var hexChar = this.popChar()\r\n                if (hexDigitPattern.test(hexChar) === false) {\r\n                    throw Error(\"Expecting a HexDecimal digits\")\r\n                }\r\n                hexString += hexChar\r\n            }\r\n            var charCode = parseInt(hexString, 16)\r\n            return { type: \"Character\", value: charCode }\r\n        }\r\n\r\n        RegExpParser.prototype.peekChar = function(howMuch) {\r\n            if (howMuch === undefined) {\r\n                howMuch = 0\r\n            }\r\n            return this.input[this.idx + howMuch]\r\n        }\r\n\r\n        RegExpParser.prototype.popChar = function() {\r\n            var nextChar = this.peekChar(0)\r\n            this.consumeChar()\r\n            return nextChar\r\n        }\r\n\r\n        RegExpParser.prototype.consumeChar = function(char) {\r\n            if (char !== undefined && this.input[this.idx] !== char) {\r\n                throw Error(\r\n                    \"Expected: '\" +\r\n                        char +\r\n                        \"' but found: '\" +\r\n                        this.input[this.idx] +\r\n                        \"' at offset: \" +\r\n                        this.idx\r\n                )\r\n            }\r\n\r\n            if (this.idx >= this.input.length) {\r\n                throw Error(\"Unexpected end of input\")\r\n            }\r\n            this.idx++\r\n        }\r\n\r\n        // consts and utilities\r\n        var hexDigitPattern = /[0-9a-fA-F]/\r\n        var decimalPattern = /[0-9]/\r\n        var decimalPatternNoZero = /[1-9]/\r\n\r\n        function cc(char) {\r\n            return char.charCodeAt(0)\r\n        }\r\n\r\n        function insertToSet(item, set) {\r\n            if (item.length !== undefined) {\r\n                item.forEach(function(subItem) {\r\n                    set.push(subItem)\r\n                })\r\n            } else {\r\n                set.push(item)\r\n            }\r\n        }\r\n\r\n        function addFlag(flagObj, flagKey) {\r\n            if (flagObj[flagKey] === true) {\r\n                throw \"duplicate flag \" + flagKey\r\n            }\r\n\r\n            flagObj[flagKey] = true\r\n        }\r\n\r\n        function ASSERT_EXISTS(obj) {\r\n            // istanbul ignore next\r\n            if (obj === undefined) {\r\n                throw Error(\"Internal Error - Should never get here!\")\r\n            }\r\n        }\r\n\r\n        // istanbul ignore next\r\n        function ASSERT_NEVER_REACH_HERE() {\r\n            throw Error(\"Internal Error - Should never get here!\")\r\n        }\r\n\r\n        var i\r\n        var digitsCharCodes = []\r\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\r\n            digitsCharCodes.push(i)\r\n        }\r\n\r\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\r\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\r\n            wordCharCodes.push(i)\r\n        }\r\n\r\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\r\n            wordCharCodes.push(i)\r\n        }\r\n\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\r\n        var whitespaceCodes = [\r\n            cc(\" \"),\r\n            cc(\"\\f\"),\r\n            cc(\"\\n\"),\r\n            cc(\"\\r\"),\r\n            cc(\"\\t\"),\r\n            cc(\"\\v\"),\r\n            cc(\"\\t\"),\r\n            cc(\"\\u00a0\"),\r\n            cc(\"\\u1680\"),\r\n            cc(\"\\u2000\"),\r\n            cc(\"\\u2001\"),\r\n            cc(\"\\u2002\"),\r\n            cc(\"\\u2003\"),\r\n            cc(\"\\u2004\"),\r\n            cc(\"\\u2005\"),\r\n            cc(\"\\u2006\"),\r\n            cc(\"\\u2007\"),\r\n            cc(\"\\u2008\"),\r\n            cc(\"\\u2009\"),\r\n            cc(\"\\u200a\"),\r\n            cc(\"\\u2028\"),\r\n            cc(\"\\u2029\"),\r\n            cc(\"\\u202f\"),\r\n            cc(\"\\u205f\"),\r\n            cc(\"\\u3000\"),\r\n            cc(\"\\ufeff\")\r\n        ]\r\n\r\n        function BaseRegExpVisitor() {}\r\n\r\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\r\n            for (var key in node) {\r\n                var child = node[key]\r\n                /* istanbul ignore else */\r\n                if (node.hasOwnProperty(key)) {\r\n                    if (child.type !== undefined) {\r\n                        this.visit(child)\r\n                    } else if (Array.isArray(child)) {\r\n                        child.forEach(function(subChild) {\r\n                            this.visit(subChild)\r\n                        }, this)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        BaseRegExpVisitor.prototype.visit = function(node) {\r\n            switch (node.type) {\r\n                case \"Pattern\":\r\n                    this.visitPattern(node)\r\n                    break\r\n                case \"Flags\":\r\n                    this.visitFlags(node)\r\n                    break\r\n                case \"Disjunction\":\r\n                    this.visitDisjunction(node)\r\n                    break\r\n                case \"Alternative\":\r\n                    this.visitAlternative(node)\r\n                    break\r\n                case \"StartAnchor\":\r\n                    this.visitStartAnchor(node)\r\n                    break\r\n                case \"EndAnchor\":\r\n                    this.visitEndAnchor(node)\r\n                    break\r\n                case \"WordBoundary\":\r\n                    this.visitWordBoundary(node)\r\n                    break\r\n                case \"NonWordBoundary\":\r\n                    this.visitNonWordBoundary(node)\r\n                    break\r\n                case \"Lookahead\":\r\n                    this.visitLookahead(node)\r\n                    break\r\n                case \"NegativeLookahead\":\r\n                    this.visitNegativeLookahead(node)\r\n                    break\r\n                case \"Character\":\r\n                    this.visitCharacter(node)\r\n                    break\r\n                case \"Set\":\r\n                    this.visitSet(node)\r\n                    break\r\n                case \"Group\":\r\n                    this.visitGroup(node)\r\n                    break\r\n                case \"GroupBackReference\":\r\n                    this.visitGroupBackReference(node)\r\n                    break\r\n                case \"Quantifier\":\r\n                    this.visitQuantifier(node)\r\n                    break\r\n            }\r\n\r\n            this.visitChildren(node)\r\n        }\r\n\r\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\r\n\r\n        // Assertion\r\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\r\n\r\n        // atoms\r\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\r\n\r\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\r\n\r\n        return {\r\n            RegExpParser: RegExpParser,\r\n            BaseRegExpVisitor: BaseRegExpVisitor,\r\n            VERSION: \"0.4.0\"\r\n        }\r\n    }\r\n)\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}